<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="google-site-verification" content="OygqOu5ag2msfxKdoW4kv7IaMA8U_vhkjSB-0ACnYu0"><meta name="baidu-site-verification" content="Z5ri1zLORu"><meta baidu-gxt-verify-token="3f82708dfb1582c8656e06f6ca97fe35"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2"><link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"6.4.2",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="异步代码的异常处理通常都比较让人头疼，而协程则再一次展现了它的威力。"><meta property="og:type" content="article"><meta property="og:title" content="破解 Kotlin 协程(4) - 异常处理篇"><meta property="og:url" content="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/index.html"><meta property="og:site_name" content="Bennyhuo"><meta property="og:description" content="异步代码的异常处理通常都比较让人头疼，而协程则再一次展现了它的威力。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"><meta property="article:published_time" content="2019-04-22T16:00:00.000Z"><meta property="article:modified_time" content="2020-02-03T08:48:04.401Z"><meta property="article:author" content="Bennyhuo"><meta property="article:tag" content="Kotlin 协程 异常处理"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"><link rel="alternate" href="/atom.xml" title="Bennyhuo" type="application/atom+xml"><link rel="canonical" href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>破解 Kotlin 协程(4) - 异常处理篇 | Bennyhuo</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?8158efd7e8cf52cfb7d8420b33755ca8";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Bennyhuo</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">编程、教学 & Kotlin</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-project"><a href="/project/" rel="section"><i class="menu-item-icon fa fa-fw fa-podcast"></i><br>项目</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Bennyhuo"><meta itemprop="description" content="发布编程教学视频，技术分享"><meta itemprop="image" content="/assets/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Bennyhuo"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">破解 Kotlin 协程(4) - 异常处理篇</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-04-23 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-23T00:00:00+08:00">2019-04-23</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-02-03 16:48:04" itemprop="dateModified" datetime="2020-02-03T16:48:04+08:00">2020-02-03</time> </span><span id="/2019/04/23/coroutine-exceptions/" class="leancloud_visitors" data-flag-title="破解 Kotlin 协程(4) - 异常处理篇"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">13k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">21 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>异步代码的异常处理通常都比较让人头疼，而协程则再一次展现了它的威力。</p></blockquote><a id="more"></a><h2 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h2><p>我们在前面一篇文章当中提到了这样一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Callback = (User) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(callback: <span class="type">Callback</span>)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通常会定义这样的回调接口来实现异步数据的请求，我们可以很方便的将它转换成协程的接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    getUser &#123;</span><br><span class="line">        continuation.resume(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并最终交给按钮点击事件或者其他事件去触发这个异步请求：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserBtn.setOnClickListener &#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        userNameView.text = getUserCoroutine().name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，既然是请求，总会有失败的情形，而我们这里并没有对错误的处理，接下来我们就完善这个例子。</p><h2 id="2-添加异常处理逻辑"><a href="#2-添加异常处理逻辑" class="headerlink" title="2. 添加异常处理逻辑"></a>2. 添加异常处理逻辑</h2><p>首先我们加上异常回调接口函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callback</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们在改造一下我们的 <code>getUserCoroutine</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class="line">    getUser(<span class="keyword">object</span> : Callback&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            continuation.resume(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            continuation.resumeWithException(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到，我们似乎就是完全把 <code>Callback</code> 转换成了一个 <code>Continuation</code>，在调用的时候我们只需要：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userNameView.text = getUserCoroutine().name</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        userNameView.text = <span class="string">"Get User Error: <span class="variable">$e</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，你没看错，一个异步的请求异常，我们只需要在我们的代码中捕获就可以了，这样做的好处就是，请求的全流程异常都可以在一个 <code>try ... catch ...</code> 当中捕获，那么我们可以说真正做到了把异步代码变成了同步的写法。</p><p>如果你一直在用 RxJava 处理这样的逻辑，那么你的请求接口可能是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserObservable</span><span class="params">()</span></span>: Single&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Single.create&lt;User&gt; &#123; emitter -&gt;</span><br><span class="line">        getUser(<span class="keyword">object</span> : Callback&lt;User&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">                emitter.onSuccess(value)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                emitter.onError(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时大概是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getUserObservable()</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe (&#123; user -&gt;</span><br><span class="line">            userNameView.text = user.name</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            userNameView.text = <span class="string">"Get User Error: <span class="variable">$it</span>"</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>其实你很容易就能发现在这里 RxJava 做的事儿跟协程的目的是一样的，只不过协程用了一种更自然的方式。</p><blockquote><p>也许你已经对 RxJava 很熟悉并且感到很自然，但相比之下，RxJava 的代码比协程的复杂度更高，更让人费解，这一点我们后面的文章中也会持续用例子来说明这一点。</p></blockquote><h2 id="3-全局异常处理"><a href="#3-全局异常处理" class="headerlink" title="3. 全局异常处理"></a>3. 全局异常处理</h2><p>线程也好、RxJava 也好，都有全局处理异常的方式，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler &#123;t: Thread, e: Throwable -&gt;</span><br><span class="line">        <span class="comment">//handle exception here</span></span><br><span class="line">        println(<span class="string">"Thread '<span class="subst">$&#123;t.name&#125;</span>' throws an exception with message '<span class="subst">$&#123;e.message&#125;</span>'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> ArithmeticException(<span class="string">"Hey!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以为线程设置全局的异常捕获，当然也可以为 RxJava 来设置全局异常捕获：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RxJavaPlugins.setErrorHandler(e -&gt; &#123;</span><br><span class="line">        <span class="comment">//handle exception here</span></span><br><span class="line">        println(<span class="string">"Throws an exception with message '<span class="subst">$&#123;e.message&#125;</span>'"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>协程显然也可以做到这一点。类似于通过 <code>Thread.setUncaughtExceptionHandler</code> 为线程设置一个异常捕获器，我们也可以为每一个协程单独设置 <code>CoroutineExceptionHandler</code>，这样协程内部未捕获的异常就可以通过它来捕获：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        log(<span class="string">"Throws an exception with message: <span class="subst">$&#123;throwable.message&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    GlobalScope.launch(exceptionHandler) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException(<span class="string">"Hey!"</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">19:06:35:087 [main] 1</span><br><span class="line">19:06:35:208 [DefaultDispatcher-worker-1 @coroutine#1] Throws an exception with message: Hey!</span><br><span class="line">19:06:35:211 [DefaultDispatcher-worker-1 @coroutine#1] 2</span><br></pre></td></tr></table></figure><p><code>CoroutineExceptionHandler</code> 竟然也是一个上下文，协程的这个上下文可真是灵魂一般的存在，这倒是一点儿也不让人感到意外。</p><p>当然，这并不算是一个全局的异常捕获，因为它只能捕获对应协程内未捕获的异常，如果你想做到真正的全局捕获，在 Jvm 上我们可以自己定义一个捕获类实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalCoroutineExceptionHandler</span>: <span class="type">CoroutineExceptionHandler &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptionHandler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleException</span><span class="params">(context: <span class="type">CoroutineContext</span>, exception: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Coroutine exception: <span class="variable">$exception</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 classpath 中创建 META-INF/services/kotlinx.coroutines.CoroutineExceptionHandler，文件名实际上就是 <code>CoroutineExceptionHandler</code> 的全类名，文件内容就写我们的实现类的全类名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.bennyhuo.coroutines.sample2.exceptions.GlobalCoroutineExceptionHandler</span><br></pre></td></tr></table></figure><p>这样协程中没有被捕获的异常就会最终交给它处理。</p><blockquote><p>Jvm 上全局 <code>CoroutineExceptionHandler</code> 的配置，本质上是对 <code>ServiceLoader</code> 的应用，之前我们在讲 <code>Dispatchers.Main</code> 的时候提到过，Jvm 上它的实现也是通过 <code>ServiceLoader</code> 来加载的。</p></blockquote><p>需要明确的一点是，通过 <code>async</code> 启动的协程出现未捕获的异常时会忽略 <code>CoroutineExceptionHandler</code>，这与 <code>launch</code> 的设计思路是不同的。</p><h2 id="4-异常传播"><a href="#4-异常传播" class="headerlink" title="4. 异常传播"></a>4. 异常传播</h2><p>异常传播还涉及到协程作用域的概念，例如我们启动协程的时候一直都是用的 <code>GlobalScope</code>，意味着这是一个独立的顶级协程作用域，此外还有 <code>coroutineScope { ... }</code> 以及 <code>supervisorScope { ... }</code>。</p><ul><li>通过 GlobeScope 启动的协程单独启动一个协程作用域，内部的子协程遵从默认的作用域规则。通过 GlobeScope 启动的协程“自成一派”。</li><li>coroutineScope 是继承外部 Job 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常也会向上传递给父协程。它更适合一系列对等的协程并发的完成一项工作，任何一个子协程异常退出，那么整体都将退出，简单来说就是”一损俱损“。这也是协程内部再启动子协程的默认作用域。</li><li>supervisorScope 同样继承外部作用域的上下文，但其内部的取消操作是单向传播的，父协程向子协程传播，反过来则不然，这意味着子协程出了异常并不会影响父协程以及其他兄弟协程。它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，简单来说就是”自作自受“，例如 UI，我点击一个按钮出了异常，其实并不会影响手机状态栏的刷新。需要注意的是，supervisorScope 内部启动的子协程内部再启动子协程，如无明确指出，则遵守默认作用域规则，也即 supervisorScope 只作用域其直接子协程。</li></ul><p>这么说还是比较抽象，因此我们拿一些例子来分析一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        coroutineScope &#123; <span class="comment">//①</span></span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            launch &#123; <span class="comment">// ②</span></span><br><span class="line">                log(<span class="number">3</span>)</span><br><span class="line">                launch &#123; <span class="comment">// ③ </span></span><br><span class="line">                    log(<span class="number">4</span>)</span><br><span class="line">                    delay(<span class="number">100</span>)</span><br><span class="line">                    <span class="keyword">throw</span> ArithmeticException(<span class="string">"Hey!!"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="number">5</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            log(<span class="number">6</span>)</span><br><span class="line">            <span class="keyword">val</span> job = launch &#123; <span class="comment">// ④</span></span><br><span class="line">                log(<span class="number">7</span>)</span><br><span class="line">                delay(<span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="number">8</span>)</span><br><span class="line">                 job.join()</span><br><span class="line">                log(<span class="string">"9"</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                log(<span class="string">"10. <span class="variable">$e</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="number">11</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">"12. <span class="variable">$e</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">13</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这例子稍微有点儿复杂，但也不难理解，我们在一个 <code>coroutineScope</code> 当中启动了两个协程 ②④，在 ② 当中启动了一个子协程 ③，作用域直接创建的协程记为①。那么 ③ 当中抛异常会发生什么呢？我们先来看下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">11:37:36:208 [main] 1</span><br><span class="line">11:37:36:255 [main] 2</span><br><span class="line">11:37:36:325 [DefaultDispatcher-worker-1] 3</span><br><span class="line">11:37:36:325 [DefaultDispatcher-worker-1] 5</span><br><span class="line">11:37:36:326 [DefaultDispatcher-worker-3] 4</span><br><span class="line">11:37:36:331 [main] 6</span><br><span class="line">11:37:36:336 [DefaultDispatcher-worker-1] 7</span><br><span class="line">11:37:36:336 [main] 8</span><br><span class="line">11:37:36:441 [DefaultDispatcher-worker-1] 10. kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job&#x3D;ScopeCoroutine&#123;Cancelling&#125;@2bc92d2f</span><br><span class="line">11:37:36:445 [DefaultDispatcher-worker-1] 12. java.lang.ArithmeticException: Hey!!</span><br><span class="line">11:37:36:445 [DefaultDispatcher-worker-1] 13</span><br></pre></td></tr></table></figure><p>注意两个位置，一个是 10，我们调用 <code>join</code>，收到了一个取消异常，在协程当中支持取消的操作的suspend方法在取消时会抛出一个 <code>CancellationException</code>，这类似于线程中对 <code>InterruptException</code> 的响应，遇到这种情况表示 <code>join</code> 调用所在的协程已经被取消了，那么这个取消究竟是怎么回事呢？</p><p>原来协程 ③ 抛出了未捕获的异常，进入了异常完成的状态，它与父协程 ② 之间遵循默认的作用域规则，因此 ③ 会通知它的父协程也就是 ② 取消，② 根据作用域规则通知父协程 ① 也就是整个作用域取消，这是一个自下而上的一次传播，这样身处 ① 当中的 <code>job.join</code> 调用就会抛异常，也就是 10 处的结果了。如果不是很理解这个操作，想一下我们说到的，<code>coroutineScope</code> 内部启动的协程就是“一损俱损”。实际上由于父协程 ① 被取消，协程④ 也不能幸免，如果大家有兴趣的话，也可以对 ④ 当中的 <code>delay</code>进行捕获，一样会收获一枚取消异常。</p><p>还有一个位置就是 12，这个是我们对 <code>coroutineScope</code> 整体的一个捕获，如果 <code>coroutineScope</code> 内部以为异常而结束，那么我们是可以对它直接 <code>try ... catch ...</code> 来捕获这个异常的，这再一次表明协程把异步的异常处理到同步代码逻辑当中。</p><p>那么如果我们把 <code>coroutineScope</code> 换成 <code>supervisorScope</code>，其他不变，运行结果会是怎样呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">11:52:48:632 [main] 1</span><br><span class="line">11:52:48:694 [main] 2</span><br><span class="line">11:52:48:875 [main] 6</span><br><span class="line">11:52:48:892 [DefaultDispatcher-worker-1 @coroutine#1] 3</span><br><span class="line">11:52:48:895 [DefaultDispatcher-worker-1 @coroutine#1] 5</span><br><span class="line">11:52:48:900 [DefaultDispatcher-worker-3 @coroutine#3] 4</span><br><span class="line">11:52:48:905 [DefaultDispatcher-worker-2 @coroutine#2] 7</span><br><span class="line">11:52:48:907 [main] 8</span><br><span class="line">Exception in thread &quot;DefaultDispatcher-worker-3 @coroutine#3&quot; java.lang.ArithmeticException: Hey!!</span><br><span class="line">	at com.bennyhuo.coroutines.sample2.exceptions.ScopesKt$main$2$1$1.invokeSuspend(Scopes.kt:17)</span><br><span class="line">	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)</span><br><span class="line">	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:238)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)</span><br><span class="line">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 9</span><br><span class="line">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 11</span><br><span class="line">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 13</span><br></pre></td></tr></table></figure><p>我们可以看到，1-8 的输出其实没有本质区别，顺序上的差异是线程调度的前后造成的，并不会影响协程的语义。差别主要在于 9 与 10、11与12的区别，如果把 scope 换成 <code>supervisorScope</code>，我们发现 ③ 的异常并没有影响作用域以及作用域内的其他子协程的执行，也就是我们所说的“自作自受”。</p><p>这个例子其实我们再稍做一些改动，为 ② 和 ③ 增加一个 <code>CoroutineExceptionHandler</code>，就可以证明我们前面提到的另外一个结论：</p><p>首先我们定义一个 <code>CoroutineExceptionHandler</code>，我们通过上下文获取一下异常对应的协程的名字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">    log(<span class="string">"<span class="subst">$&#123;coroutineContext[CoroutineName]&#125;</span> <span class="variable">$throwable</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，基于前面的例子我们为 ② 和 ③ 添加 <code>CoroutineExceptionHandler</code> 和名字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">supervisorScope &#123; <span class="comment">//①</span></span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    launch(exceptionHandler + CoroutineName(<span class="string">"②"</span>)) &#123; <span class="comment">// ②</span></span><br><span class="line">        log(<span class="number">3</span>)</span><br><span class="line">        launch(exceptionHandler + CoroutineName(<span class="string">"③"</span>)) &#123; <span class="comment">// ③</span></span><br><span class="line">            log(<span class="number">4</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再运行这段程序，结果就比较有意思了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">07:30:11:519 [DefaultDispatcher-worker-1] CoroutineName(②) java.lang.ArithmeticException: Hey!!</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们发现触发的 <code>CoroutineExceptionHandler</code> 竟然是协程 ② 的，意外吗？不意外，因为我们前面已经提到，对于 <code>supervisorScope</code> 的子协程 （例如 ②）的子协程（例如 ③），如果没有明确指出，它是遵循默认的作用于规则的，也就是 <code>coroutineScope</code> 的规则了，出现未捕获的异常会尝试传递给父协程并尝试取消父协程。</p><p>究竟使用什么 Scope，大家自己根据实际情况来确定，我给出一些建议：</p><ul><li>对于没有协程作用域，但需要启动协程的时候，适合用 GlobalScope</li><li>对于已经有协程作用域的情况（例如通过 GlobalScope 启动的协程体内），直接用协程启动器启动</li><li>对于明确要求子协程之间相互独立不干扰时，使用 supervisorScope</li><li>对于通过标准库 API 创建的协程，这样的协程比较底层，没有 Job、作用域等概念的支撑，例如我们前面提到过 suspend main 就是这种情况，对于这种情况优先考虑通过 coroutineScope 创建作用域；更进一步，大家尽量不要直接使用标准库 API，除非你对 Kotlin 的协程机制非常熟悉。</li></ul><p>当然，对于可能出异常的情况，请大家尽量做好异常处理，不要将问题复杂化。</p><h3 id="5-join-和-await"><a href="#5-join-和-await" class="headerlink" title="5. join 和 await"></a>5. join 和 await</h3><p>前面我们举例子一直用的是 <code>launch</code>，启动协程其实常用的还有 <code>async</code>、<code>actor</code> 和 <code>produce</code>，其中 <code>actor</code> 和 <code>launch</code> 的行为类似，在未捕获的异常出现以后，会被当做为处理的异常抛出，就像前面的例子那样。而 <code>async</code> 和 <code>produce</code> 则主要是用来输出结果的，他们内部的异常只在外部消费他们的结果时抛出。这两组协程的启动器，你也可以认为分别是“消费者”和“生产者”，消费者异常立即抛出，生产者只有结果消费时抛出异常。</p><blockquote><p><code>actor</code> 和 <code>produce</code> 这两个 API 目前处于比较微妙的境地，可能会被废弃或者后续提供替代方案，不建议大家使用，我们在这里就不展开细讲了。</p></blockquote><p>那么消费结果指的是什么呢？对于 <code>async</code> 来讲，就是 <code>await</code>，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = GlobalScope.async&lt;<span class="built_in">Int</span>&gt; &#123; </span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> value = deferred.await()</span><br><span class="line">        log(<span class="string">"1. <span class="variable">$value</span>"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">"2. <span class="variable">$e</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个从逻辑上很好理解，我们调用 <code>await</code> 时，期望 <code>deferred</code> 能够给我们提供一个合适的结果，但它因为出异常，没有办法做到这一点，因此只好给我们丢出一个异常了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13:25:14:693 [main] 2. java.lang.ArithmeticException</span><br></pre></td></tr></table></figure><p>我们自己实现的 <code>getUserCoroutine</code> 也属于类似的情况，在获取结果时，如果请求出了异常，我们就只能拿到一个异常，而不是正常的结果。相比之下，<code>join</code> 就有趣的多了，它只关注是否执行完，至于是因为什么完成，它不关心，因此如果我们在这里替换成 <code>join</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = GlobalScope.async&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred.join()</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">"2. <span class="variable">$e</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就会发现，异常被吞掉了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13:26:15:034 [main] 1</span><br></pre></td></tr></table></figure><p>如果例子当中我们用 <code>launch</code> 替换 <code>async</code>，<code>join</code> 处仍然不会有任何异常抛出，还是那句话，它只关心有没有完成，至于怎么完成的它不关心。不同之处在于， <code>launch</code> 中未捕获的异常与 <code>async</code> 的处理方式不同，<code>launch</code> 会直接抛出给父协程，如果没有父协程（顶级作用域中）或者处于 <code>supervisorScope</code> 中父协程不响应，那么就交给上下文中指定的 <code>CoroutineExceptionHandler</code>处理，如果没有指定，那传给全局的 <code>CoroutineExceptionHandler</code> 等等，而 <code>async</code> 则要等 <code>await</code> 来消费。</p><blockquote><p>不管是哪个启动器，在应用了作用域之后，都会按照作用域的语义进行异常扩散，进而触发相应的取消操作，对于 <code>async</code> 来说就算不调用 <code>await</code> 来获取这个异常，它也会在 <code>coroutineScope</code> 当中触发父协程的取消逻辑，这一点请大家注意。</p></blockquote><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><p>这一篇我们讲了协程的异常处理。这一块儿稍微显得有点儿复杂，但仔细理一下主要有三条线：</p><ol><li><strong>协程内部异常处理流程</strong>：launch 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看作用域的定义，如果取消成功，那么异常传递给父协程，否则传递给启动时上下文中配置的 CoroutineExceptionHandler 中，如果没有配置，会查找全局（JVM上）的 CoroutineExceptionHandler 进行处理，如果仍然没有，那么就将异常交给当前线程的 UncaughtExceptionHandler 处理；而 async 则在未捕获的异常出现时同样会尝试取消父协程，但不管是否能够取消成功都不会后其他后续的异常处理，直到用户主动调用 await 时将异常抛出。</li><li><strong>异常在作用域内的传播</strong>：当协程出现异常时，会根据当前作用域触发异常传递，GlobalScope 会创建一个独立的作用域，所谓“自成一派”，而 在 coroutineScope 当中协程异常会触发父协程的取消，进而将整个协程作用域取消掉，如果对 coroutineScope 整体进行捕获，也可以捕获到该异常，所谓“一损俱损”；如果是 supervisorScope，那么子协程的异常不会向上传递，所谓“自作自受”。</li><li><strong>join 和 await 的不同</strong>：join 只关心协程是否执行完，await 则关心运行的结果，因此 join 在协程出现异常时也不会抛出该异常，而 await 则会；考虑到作用域的问题，如果协程抛异常，可能会导致父协程的取消，因此调用 join 时尽管不会对协程本身的异常进行抛出，但如果 join 调用所在的协程被取消，那么它会抛出取消异常，这一点需要留意。</li></ol><p>如果大家能把这三点理解清楚了，那么协程的异常处理可以说就非常清晰了。文中因为异常传播的原因，我们提到了取消，但没有展开详细讨论，后面我们将会专门针对取消输出一篇文章，帮助大家加深理解。</p><h3 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h3><p>join 在父协程被取消时有一个 bug 会导致不抛出取消异常，我在准备本文时发现该问题，目前已经提交到官方并得到了修复，预计合入到 1.2.1 发版，大家有兴趣可以查看这个 issue：<a href="https://github.com/Kotlin/kotlinx.coroutines/issues/1123" target="_blank" rel="noopener">No CancellationException thrown when join on a crashed Job</a>。</p><p>当然，这个 bug 对于生成环境的影响很小，大家也不要担心。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p></div><div class="popular-posts-header">相关推荐</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2019/04/30/coroutine-cancellation/" rel="bookmark">破解 Kotlin 协程(5) - 协程取消篇</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2019/09/16/coroutine-channel/" rel="bookmark">破解 Kotlin 协程(9) - Channel 篇</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2019/04/11/coroutine-dispatchers/" rel="bookmark">破解 Kotlin 协程(3) - 协程调度篇</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2019/12/01/coroutine-implementations/" rel="bookmark">破解 Kotlin 协程 番外篇(2) - 协程的几类常见的实现</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2019/05/26/coroutine-sequence/" rel="bookmark">破解 Kotlin 协程(7) - 序列生成器篇</a></div></li></ul><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Bennyhuo</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/" title="破解 Kotlin 协程(4) - 异常处理篇">https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/kotlin/" rel="tag"># Kotlin</a> <a href="/tags/coroutine/" rel="tag"># Coroutine</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/04/11/coroutine-dispatchers/" rel="next" title="破解 Kotlin 协程(3) - 协程调度篇"><i class="fa fa-chevron-left"></i> 破解 Kotlin 协程(3) - 协程调度篇</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/04/30/coroutine-cancellation/" rel="prev" title="破解 Kotlin 协程(5) - 协程取消篇">破解 Kotlin 协程(5) - 协程取消篇 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div id="gitalk-container"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/assets/avatar.jpg" alt="Bennyhuo"><p class="site-author-name" itemprop="name">Bennyhuo</p><p class="site-description motion-element" itemprop="description">发布编程教学视频，技术分享</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/%20%7C%7C%20archive"><span class="site-state-item-count">29</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">18</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/enbandari" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-globe"></i>GitHub</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-引子"><span class="nav-number">1.</span> <span class="nav-text">1. 引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-添加异常处理逻辑"><span class="nav-number">2.</span> <span class="nav-text">2. 添加异常处理逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-全局异常处理"><span class="nav-number">3.</span> <span class="nav-text">3. 全局异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-异常传播"><span class="nav-number">4.</span> <span class="nav-text">4. 异常传播</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-join-和-await"><span class="nav-number">4.1.</span> <span class="nav-text">5. join 和 await</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-小结"><span class="nav-number">4.2.</span> <span class="nav-text">6. 小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#附加说明"><span class="nav-number">4.3.</span> <span class="nav-text">附加说明</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Bennyhuo</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">178k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">4:56</span></div><script async src="/lib/busuanzi/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span> <span class="post-meta-divider">|</span> <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span> <span class="post-meta-divider">|</span><div class="powered-by">由 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> 强力驱动 v4.2.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a class="theme-link" target="_blank" rel="external nofollow" href="https://theme-next.org">NexT.Pisces</a> v6.4.2</div><div class="footer-custom"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener">京ICP备16022265号-3</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script><script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script><script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script><script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://geektutu.github.io/hexo-theme-geektutu/js/gitalk.min.js"></script><script src="/js/src/md5.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"7d2353275afc8d2a5ba3",clientSecret:"b43a5cabf6064d62cd3fea35adde9609ca49887f",repo:"Bennyhuo",owner:"enbandari",admin:["enbandari"],id:md5(location.pathname),distractionFreeMode:"true"});gitalk.render("gitalk-container")</script><script>function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "FicBFjnnYPST748WV6dmgumh-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "FicBFjnnYPST748WV6dmgumh-gzGzoHsz",
                'X-LC-Key': "9GE81hTRn176FdLAdUrJBWON",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>