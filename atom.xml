<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bennyhuo</title>
  
  <subtitle>编程、教学 &amp; Kotlin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.bennyhuo.com/"/>
  <updated>2019-12-01T09:39:57.884Z</updated>
  <id>https://www.bennyhuo.com/</id>
  
  <author>
    <name>Bennyhuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>父类返回子类类型的函数写法</title>
    <link href="https://www.bennyhuo.com/2019/12/01/this-type/"/>
    <id>https://www.bennyhuo.com/2019/12/01/this-type/</id>
    <published>2019-12-01T09:39:57.884Z</published>
    <updated>2019-12-01T09:39:57.884Z</updated>
    
    <content type="html"><![CDATA[<p>今天的话题很简单，分享下也许对大家可以有帮助或者有启发。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>一看题目，有点儿晕。看个例子马上就明白了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBuilder</span></span>() &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> retryLimit = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">retryLimit</span><span class="params">(retryLimit: <span class="type">Int</span>)</span></span>: EventBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: PollingEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有这么一个类，一看就是要写 Builder 模式。不过由于我们的这个 Event 的类型比较多，因此希望写一个父类，来一个子类感受下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisposableEventBuilder</span> : <span class="type">EventBuilder</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> delay: <span class="built_in">Long</span> = <span class="number">0L</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(delay: <span class="type">Long</span>)</span></span>: DisposableEventBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> = <span class="keyword">object</span>: DisposableEvent(name, delay)&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDisposableEvent</span><span class="params">()</span></span> &#123;</span><br><span class="line">            callback.onEvent(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去也没啥大毛病，用一下吧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DisposableEventBuilder().retryLimit(<span class="number">3</span>)</span><br><span class="line">        .delay(<span class="number">60_000</span>) <span class="comment">// ERROR!! </span></span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure><p>我们调用完父类的 <code>retryLimit</code> 方法后，想要设置下 <code>delay</code>，结果发现没有这个方法。</p><blockquote><p>“我 X，这什么玩意儿”，你嘟囔了一句。</p></blockquote><a id="more"></a><p>因为返回的是父类，所以链式调用掉链子了。这就尴尬了。</p><h2 id="2-Scala-的解法"><a href="#2-Scala-的解法" class="headerlink" title="2. Scala 的解法"></a>2. Scala 的解法</h2><p>如果这段代码用 Scala 写，那么用 <code>this.type</code> 就简直完美的解决了这个问题：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> retryLimit: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retryLimit</span></span>(retryLimit: <span class="type">Int</span>): <span class="keyword">this</span><span class="class">.<span class="keyword">type</span> </span>= &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubBuilder</span> <span class="keyword">extends</span> <span class="title">SuperBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> delay: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delay</span></span>(delay: <span class="type">Long</span>): <span class="type">SubBuilder</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">SubBuilder</span>().retryLimit(<span class="number">3</span>).delay(<span class="number">60000</span>)</span><br></pre></td></tr></table></figure><p>一点儿毛病都么有。</p><p>Kotlin 有这个特性吗？并没有。</p><h2 id="3-Kotlin-的解法"><a href="#3-Kotlin-的解法" class="headerlink" title="3. Kotlin 的解法"></a>3. Kotlin 的解法</h2><p>Kotlin 倒也不是没有办法解决这个问题，用下泛型就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBuilder</span>&lt;<span class="type">T : EventBuilder&lt;T</span>&gt;&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> retryLimit = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">retryLimit</span><span class="params">(retryLimit: <span class="type">Int</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: PollingEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个泛型给父类加了一个泛型参数，这个参数则必须是当前类的子类，那么这样的话我们就可以在返回自身类型的位置返回 T 这个类型了。</p><p>子类的改动就很简单了，只需要给父类加一个泛型参数为自己的类型即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisposableEventBuilder</span> : <span class="type">EventBuilder</span>&lt;<span class="type">DisposableEventBuilder</span>&gt;</span>() &#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的什么也不用动，这时候我们的链式调用就没啥问题了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DisposableEventBuilder().retryLimit(<span class="number">3</span>)</span><br><span class="line">        .delay(<span class="number">60_000</span>) <span class="comment">// OK!!</span></span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure><p>这一点上 Kotlin 和 Java 其实是一致的，所以你也可以用 Java 写出类似的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperBuilder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SuperBuilder</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> retryLimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">retryLimit</span><span class="params">(<span class="keyword">int</span> retryLimit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubBuilder</span> <span class="keyword">extends</span> <span class="title">SuperBuilder</span>&lt;<span class="title">SubBuilder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SuperBuilder <span class="title">delay</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，今天就先这样~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的话题很简单，分享下也许对大家可以有帮助或者有启发。&lt;/p&gt;&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;一看题目，有点儿晕。看个例子马上就明白了：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;EventBuilder&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; retryLimit = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;retryLimit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(retryLimit: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;: EventBuilder &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.retryLimit = retryLimit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;: PollingEvent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们有这么一个类，一看就是要写 Builder 模式。不过由于我们的这个 Event 的类型比较多，因此希望写一个父类，来一个子类感受下：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DisposableEventBuilder&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;EventBuilder&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; delay: &lt;span class=&quot;built_in&quot;&gt;Long&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0L&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(delay: &lt;span class=&quot;type&quot;&gt;Long&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;: DisposableEventBuilder &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.delay = delay&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;: DisposableEvent(name, delay)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onDisposableEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            callback.onEvent(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;看上去也没啥大毛病，用一下吧：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DisposableEventBuilder().retryLimit(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .delay(&lt;span class=&quot;number&quot;&gt;60_000&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// ERROR!! &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们调用完父类的 &lt;code&gt;retryLimit&lt;/code&gt; 方法后，想要设置下 &lt;code&gt;delay&lt;/code&gt;，结果发现没有这个方法。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“我 X，这什么玩意儿”，你嘟囔了一句。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>== 与 equals 居然结果不一样！</title>
    <link href="https://www.bennyhuo.com/2019/12/01/nan-equals/"/>
    <id>https://www.bennyhuo.com/2019/12/01/nan-equals/</id>
    <published>2019-12-01T09:39:57.883Z</published>
    <updated>2019-12-01T09:39:57.883Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与-equals-意见不一致的情况"><a href="#与-equals-意见不一致的情况" class="headerlink" title="== 与 equals 意见不一致的情况"></a>== 与 equals 意见不一致的情况</h3><p>Kotlin 当中 == 和 equals 是等价的，所以所有用 equals 的地方都可以用 == 来替换。</p><p>一般情况下这种说法是没问题的，连 IDE 也都会提示你：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532962022762.jpg" alt></p><p>要不要换呢？这个就看哪种更有表现力了对不，对于这种情况，换了也就换了~但事情总是有例外，例如：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964071854.jpg" alt></p><p>这回居然不提示我了！所以这里面一定有鬼！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(equals)</span><br><span class="line">println(equals2)</span><br></pre></td></tr></table></figure><p>你们猜猜结果如何？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964821915.jpg" alt><br>我去，说好的 == 等价于 equals 呢？</p><p>完了完了，这下说不好了。。扎心了老铁。。官方文档还能不能信啊。。。</p><a id="more"></a><p>以上运行结果是 kotlin.jvm 的，那么我们试试 kotlin.js，结果一样。Kotlin Native 说，他们俩的立场并不能代码我的，但我的结果与他们一样。。。所以这个不是 bug 呵。大家意见这么一致，是不是也想告诉我们点儿什么呢？</p><blockquote><p>NaN = Not a Number</p></blockquote><p>NaN 说了，我可是一翻脸不认人的主，我翻脸了连我自己都不认！额这，，么尴尬么。</p><h3 id="Jvm-的为什么"><a href="#Jvm-的为什么" class="headerlink" title="Jvm 的为什么"></a>Jvm 的为什么</h3><p>下面我们来剖析下在 Java 虚拟机上 == 和 equals 遇到 NaN 时都发生了什么吧。从字节码上来看，</p><p>== 映射成了 Java 虚拟机的指令，也就是 Java 代码中的 ==，按照规定，NaN 是不等于任何数值包括自己的，也就是说这个指令在任何值与 NaN 作比较时都会返回 false。字节码如下图所示：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532971508271.jpg" alt></p><p>而 equals 则映射成了 Java Float 的 equals 方法调用，我们来看下这个方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Float)</span><br><span class="line">           &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>floatToIntBits</code> 的结果，主要返回浮点型的二进制表示，对于 NaN，那就是 0x7fc00000 了，这个是 IEEE 754 的规定。所以 equals 的执行 在 Java 虚拟机上就成了一个整数的比较，那么很显然会返回 true 了。</p><h3 id="JavaScript-的为什么"><a href="#JavaScript-的为什么" class="headerlink" title="JavaScript 的为什么"></a>JavaScript 的为什么</h3><p>在 Js Target 上，我们很容易的就可以看到编译后的 JavaScript：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> equals_0 = kotlin_js_internal_FloatCompanionObject.NaN === kotlin_js_internal_FloatCompanionObject.NaN;</span><br><span class="line"><span class="keyword">var</span> equals2 = equals(kotlin_js_internal_FloatCompanionObject.NaN, kotlin_js_internal_FloatCompanionObject.NaN);</span><br></pre></td></tr></table></figure><p>而 <code>kotlin_js_internal_FloatCompanionObject.NaN</code> 又等价于 <code>Number.NaN</code>，因此上面的代码其实就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> equals_0 = <span class="built_in">Number</span>.NaN === <span class="built_in">Number</span>.NaN;</span><br><span class="line"><span class="keyword">var</span> equals2 = equals(<span class="built_in">Number</span>.NaN, <span class="built_in">Number</span>.NaN);</span><br></pre></td></tr></table></figure><p>对于第一行，JavaScript 与 Java 一样，规定 NaN 与自己不相等，所以返回 false，我们来看下第二行的 equals 函数的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Kotlin.equals = <span class="function"><span class="keyword">function</span> (<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj2 == <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj2 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj1 !== obj1) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj2 !== obj2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj1 === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj1.equals === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj1.equals(obj2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj1 === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> obj2 === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj1 === obj2 &amp;&amp; (obj1 !== <span class="number">0</span> || <span class="number">1</span> / obj1 === <span class="number">1</span> / obj2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj1 === obj2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532983608746.jpg" alt></p><p>这一句其实就是为 NaN 量身定做的，如果 obj1 跟自己不相等，那么一定是 NaN，就剩下的就看 obj2 是不是 NaN了。</p><h3 id="其他情况的讨论"><a href="#其他情况的讨论" class="headerlink" title="其他情况的讨论"></a>其他情况的讨论</h3><p>对于 NaN 在 == 与 equals 上表现出的不一致的情况，也是与平台相关的，而且 NaN 这个家伙本身的定义就是“六亲不认”，因此也讨论它的值的相等性是很无聊的一件事——除了看下 Kotlin 在各平台上的编译结果外。</p><p>实际上对于基本类型，Kotlin 的 == 和 equals 确实会做出不同的编译映射处理，但这样的处理在除了 NaN 外的所有场景下结果都是一致的，因此这二者可以认为除了 NaN 之外的所有情形下都是等价的。</p><hr><ul><li>Bennyhuo 所在的组招 Android 暑期实习生，有机会转正哦~</li><li>腾讯地图数据业务，坐标 <strong>北京中关村</strong></li><li>有兴趣的小伙伴可以发简历到 <a href="mailto:bennyhuo@kotliner.cn" target="_blank" rel="noopener">bennyhuo@kotliner.cn</a> 哈~</li></ul><hr><p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;与-equals-意见不一致的情况&quot;&gt;&lt;a href=&quot;#与-equals-意见不一致的情况&quot; class=&quot;headerlink&quot; title=&quot;== 与 equals 意见不一致的情况&quot;&gt;&lt;/a&gt;== 与 equals 意见不一致的情况&lt;/h3&gt;&lt;p&gt;Kotlin 当中 == 和 equals 是等价的，所以所有用 equals 的地方都可以用 == 来替换。&lt;/p&gt;&lt;p&gt;一般情况下这种说法是没问题的，连 IDE 也都会提示你：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532962022762.jpg&quot; alt&gt;&lt;/p&gt;&lt;p&gt;要不要换呢？这个就看哪种更有表现力了对不，对于这种情况，换了也就换了~但事情总是有例外，例如：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964071854.jpg&quot; alt&gt;&lt;/p&gt;&lt;p&gt;这回居然不提示我了！所以这里面一定有鬼！&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;println(equals)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println(equals2)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;你们猜猜结果如何？&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964821915.jpg&quot; alt&gt;&lt;br&gt;我去，说好的 == 等价于 equals 呢？&lt;/p&gt;&lt;p&gt;完了完了，这下说不好了。。扎心了老铁。。官方文档还能不能信啊。。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏</title>
    <link href="https://www.bennyhuo.com/2019/12/01/kotlin_native_jni/"/>
    <id>https://www.bennyhuo.com/2019/12/01/kotlin_native_jni/</id>
    <published>2019-12-01T09:39:57.882Z</published>
    <updated>2019-12-01T09:39:57.882Z</updated>
    
    <content type="html"><![CDATA[<p>我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 <code>CName</code> 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。</p><p>后来，我发现根本不需要这么麻烦啊。</p><a id="more"></a><p>我们知道 JNI 如果不通过动态注册的话，Java native 方法与 C 函数的映射关系其实就是一个固定的命名规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java_包名_类名_方法名</span><br></pre></td></tr></table></figure><p>换句话说，如果我们在 Java 中加载的 so 库的符号表里面有这么一个函数，它的名字按照标准的 C 函数命名修饰方法修饰，并且修饰之前符合上面的规则，那么 Java 的 native 方法就可以与之对应上。</p><p>那么假如我们有下面的 Java 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJni</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String  <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们只要保证 so 库当中存在一个函数名为 <code>Java_com_example_hellojni_HelloJni_stringFromJNI</code> 并且返回 <code>jstring</code> 函数就行，至于这个 so 库是由 C 还是 C++ 还是 golang，其实无所谓——自然，Kotlin Native也不在话下。</p><p>我们可以用 CLion 创建一个 Kotlin Native 的工程，在 gradle 当中配置为 Android 的动态链接库：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">kotlin &#123;</span><br><span class="line">    targets &#123;</span><br><span class="line">        fromPreset(presets.androidNativeArm32, <span class="string">'HelloWorld'</span>) <span class="comment">// ① 配置为 Android 的工程</span></span><br><span class="line"></span><br><span class="line">        configure([HelloWorld]) &#123;</span><br><span class="line">            compilations.main.outputKinds <span class="string">'DYNAMIC'</span> <span class="comment">// ② 配置为动态链接库</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后随便创建一个文件，写一个全局函数，并用 <code>CName</code> 进行标注如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.cinterop.*</span><br><span class="line"><span class="keyword">import</span> platform.android.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_stringFromJNI"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stringFromJNI</span><span class="params">(env: <span class="type">CPointer</span>&lt;<span class="type">JNIEnvVar</span>&gt;, thiz: <span class="type">jobject</span>)</span></span>: jstring &#123;</span><br><span class="line">    memScoped &#123;</span><br><span class="line">        <span class="keyword">return</span> env.pointed.pointed!!.NewStringUTF!!.invoke(env, <span class="string">"This is from Kotlin Native!!"</span>.cstr.ptr)!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到，实际上 Kotlin Native 已经帮我们把 jni.h 这个头文件的互调用配置搞定了，因此我们可以直接导入 <code>jstring</code> 这样的类型。</p><p>然后编译得到一个 so 库 libknlib.so（名字取决于我们的 gradle 工程名），我们可以把它放到我们的 Android 工程当中，在运行时加载它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">"knlib"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样运行时就可以调用 <code>stringFromJNI</code> 这个方法啦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TextView tv = (TextView)findViewById(R.id.hello_textview);</span><br><span class="line">tv.setText(stringFromJNI());</span><br></pre></td></tr></table></figure><p>接下来我再给大家看几个例子：</p><p>首先，在 Kotlin Native 当中使用 Android 的日志 Api 打印日志：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_sayHello"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">"Kn"</span>, <span class="string">"Hello %s"</span>, <span class="string">"Native"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，在 Kotlin Native 当中调用 Java 的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="meta-string">"Java_com_example_hellojni_HelloJni_callLoop"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callLoop</span><span class="params">(env: <span class="type">CPointer</span>&lt;<span class="type">JNIEnvVar</span>&gt;, thiz: <span class="type">jobject</span>)</span></span>: jstring &#123;</span><br><span class="line">    memScoped &#123;</span><br><span class="line">        <span class="keyword">val</span> jniEnvVal = env.pointed.pointed!!</span><br><span class="line">        <span class="keyword">val</span> jclass = jniEnvVal.GetObjectClass!!.invoke(env, thiz)</span><br><span class="line">        <span class="keyword">val</span> methodId = jniEnvVal.GetMethodID!!.invoke(env, jclass, <span class="string">"callFromNative"</span>.cstr.ptr, <span class="string">"()Ljava/lang/String;"</span>.cstr.ptr)</span><br><span class="line">        <span class="keyword">return</span> jniEnvVal.CallObjectMethodA!!.invoke(env, thiz, methodId, <span class="literal">null</span>) <span class="keyword">as</span> jstring</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>callFromNative</code> 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">callFromNative</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is from Java!!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Kotlin Native 本身就是兼容 C 的，因此 C 能干的自然 Kotlin Native 也可以，这样一来我们其实可以使用 Kotlin 将 Android App 上到虚拟机下到 Native 的代码全部使用 Kotlin 来编写，真是不要太强大。</p><p>本文涉及源码参见：<a href="https://github.com/enbandari/hello-kni" target="_blank" rel="noopener">hello-kni</a></p><hr><p>转载请注明出处：微信公众号 Kotlin</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 &lt;code&gt;CName&lt;/code&gt; 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。&lt;/p&gt;&lt;p&gt;后来，我发现根本不需要这么麻烦啊。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于 Node.js 环境的 KotlinJs 工程的完美搭建</title>
    <link href="https://www.bennyhuo.com/2019/12/01/kotlin-nodejs/"/>
    <id>https://www.bennyhuo.com/2019/12/01/kotlin-nodejs/</id>
    <published>2019-12-01T09:39:57.881Z</published>
    <updated>2019-12-01T09:39:57.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要这样一篇文章"><a href="#为什么需要这样一篇文章" class="headerlink" title="为什么需要这样一篇文章"></a>为什么需要这样一篇文章</h3><p>我们知道 Kotlin 对 Jvm 的支持实在是太好了，以至于我们创建一个 Java 工程，配置一下 Kotlin 的编译插件和标准库就可以很轻松愉快的开始玩耍，什么互调用、什么单步调试都没有毛病——毕竟 KotlinJvm 与 Java 无论从使用上还是从生态上都尽可能的保持了一致，构建也主要用了 gradle，所以从 Java 到 Kotlin 的切换可谓是无缝衔接。</p><p>而 Kotlin 同样支持的 JavaScript 就似乎有点儿麻烦了，毕竟二者所处的生态差异略大，KotlinJs 仍然主要采用 gradle 构建，而 JavaScript 的话，例如 Node.js，就使用 npm/yarn 安装管理依赖了。想想可能还是有点儿别扭，你当然可以自己创建一个简单的 KotlinJs 工程，并且自己负责管理 node_modules，但那样的话，node_modules 的依赖并不会被 KotlinJs 直接依赖到，还需要管理 JavaScript 映射到 Kotlin 的接口依赖，例如 jQuery 在 Kotlinjs 侧就有一个接口库方便 Kotlin 以类型安全的方式调用，不过你还是要自己安装好 jQuery 才行，很麻烦对吧。</p><p>这一节我们将给大家展示如何搭建一个基于 Node.js 的相对完美的 KotlinJs 的开发环境，这个环境可以做到：</p><ul><li>依赖只需要在 Gradle 中统一管理即可，node_modules 会被自动安装</li><li>右键运行 Kotlin 中的 main 函数，就像我们在 KotlinJvm 当中一样</li><li>单步调试 Kotlin 代码，全程对 JavaScript 的编译结果无感知</li></ul><p>基于这个工程，大家就可以很愉快的测试 KotlinJs 的特性啦，就像我们在 KotlinJvm 上面那样，毫无违和感。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先，你需要一个 IntelliJ Idea Utilmate，俗称的 IU。为什么呢？因为我们需要 IDE 支持 Gradle，所以 WebStorm 就不行啦。</p><p>接着，你需要在 IU 中安装 NodeJS 插件，如图：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519977140851.jpg" alt></p><p>我的 IU 已经安装了 NodeJS 的插件，因此在左侧可以看到，如果你没有安装，那么点击 Browse repositories 搜索安装即可。安装完成后重启 IU。</p><p>最后，为了能够正常运行 Node.js 程序，请大家提前安装好 Node，这个就比较简单了，我就不多说啦。</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建工程其实也比较简单，选 Gradle，再选择 Kotlin(JavaScript) 即可，后面的根据你的实际情况配置即可。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519983002372.jpg" alt></p><p>工程创建完成后，等待 Gradle sync 完成，会得到下图所示的工程目录结构，非常熟悉对不对：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520002020882.jpg" alt></p><h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>我们直接在 src/main/kotlin 下面创建一个目录，例如 com/bennyhuo/kotlin/js，创建一个 Main.kt 文件，写下著名的一小步：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，这时候你就可以看到 IDE 提示你这个东西可以直接运行：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520003818003.jpg" alt></p><p>点击这个按钮，或者右键 main 函数，你都可以看到运行它的选项，点击之~</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520004304111.jpg" alt></p><p>首先你要选择一个合适的 node 环境，其次这个图提示我们要正确的 JavaScript 路径，由于我们实际上运行的是 Kotlin 编译生成的 JavaScript 文件，因此不要 care 下面的这个 Error，直接点击 run，下一个对话框再点击 “Continue Anyway”。</p><p>当然这时候肯定是会报错的，它会报错说没有 kotlin 这个东西，因为默认情况下 KotlinJs 编译得到的 JavaScript 是 plain 类型的，引用的依赖都需要作为全局变量出现。我们要配置它为 commonjs 或者 umd，在 gradle 最后填下以下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compileKotlin2Js &#123;</span><br><span class="line">    kotlinOptions.moduleKind = <span class="string">'commonjs'</span></span><br><span class="line">    kotlinOptions.sourceMap = <span class="literal">true</span></span><br><span class="line">    kotlinOptions.metaInfo = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的两项配置主要是为了调试用，比如单步调试映射代码位置等等。</p><p>这时候你当然可以选择继续运行了，不过还是会报错，虽然编译的结果已经能够主动去 <code>require(&#39;kotlin&#39;)</code>，但这个 kotlin 在哪儿呢？我们并没有主动去安装它，甚至我们从一开始就声称是基于 node.js 的，我们连 npm init 都没有做过，我们所有的依赖都在 gradle 当中配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">"org.jetbrains.kotlin:kotlin-stdlib-js"</span></span><br><span class="line">    testImplementation <span class="string">"org.jetbrains.kotlin:kotlin-test-js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这怎么能运行得起来呢？</p><p>因此我们还需要一个插件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.jetbrains.kotlin.frontend'</span></span><br></pre></td></tr></table></figure><p>为了依赖这个插件，我们需要添加一个仓库，毕竟这个插件还没有发布到 jcenter 的公共仓库或者 gradle 的插件仓库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">"https://dl.bintray.com/kotlin/kotlin-eap"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">"org.jetbrains.kotlin:kotlin-frontend-plugin:0.0.45"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们耐心的 sync 一下 gradle，你就会发现 build 目录下多了一些东西：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520010125911.jpg" alt></p><p>而这正包含了我们所需要的运行时依赖。kotlin frontend 这个插件会帮我们把 gradle 中配置的依赖也一并通过 npm 安装，它还可以在 gradle 当中为 npm 配置依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kotlinFrontend &#123;</span><br><span class="line">    npm &#123;</span><br><span class="line">        dependency <span class="string">"style-loader"</span> <span class="comment">// production dependency</span></span><br><span class="line">        devDependency <span class="string">"karma"</span>     <span class="comment">// development dependency</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还支持 webpack 。</p><p>好啦，这时候再运行咱们的程序，就会得到结果：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520011485464.jpg" alt></p><h2 id="体验一把-KotlinJs-的协程"><a href="#体验一把-KotlinJs-的协程" class="headerlink" title="体验一把 KotlinJs 的协程"></a>体验一把 KotlinJs 的协程</h2><p>首先添加依赖：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.jetbrains.kotlinx:kotlinx-coroutines-core-js:1.1.1'</span></span><br></pre></td></tr></table></figure><p>接着，编写我们的 Kotlin 代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"[<span class="subst">$&#123;Date().toLocaleTimeString()&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        log(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">val</span> result = withContext(coroutineContext) &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">4</span>)</span><br><span class="line">            <span class="string">"HelloWorld"</span></span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">"5. <span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520012610528.jpg" alt></p><p>单步调试无需任何特殊配置，直接打断点，点 debug 运行的按钮即可：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013471387.jpg" alt></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013961599.jpg" alt></p><p>我们可以看到 result 的值正是协程内部返回的 HelloWorld。</p><p>是不是很美？</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然，在最开始运行的时候会被配置 JavaScript 文件的路径恶心一把，但这个并不会有太多影响，整体体验已经非常不错了。嗯，公司正好有个做了半年的 NodeJs 项目，感觉可以玩一把了，反正组里用啥我说了算 ٩(๑&gt;◡&lt;๑)۶</p><blockquote><p>从此，小伙伴们与 KotlinJs 过上了幸福的生活~</p></blockquote><hr><ul><li>Bennyhuo 所在的组招 Android 实习生啦</li><li>主要面向 2020（暑期实习）或者2021 （日常实习）年毕业的计算机相关专业本科及以上的在校生</li><li>Java 基础扎实者优先，熟悉 Kotlin 优先</li><li>腾讯地图相关业务，坐标 <strong>北京中关村</strong></li><li>有兴趣的小伙伴可以发简历到 <a href="mailto:bennyhuo@kotliner.cn" target="_blank" rel="noopener">bennyhuo@kotliner.cn</a> 哈~</li></ul><hr><p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么需要这样一篇文章&quot;&gt;&lt;a href=&quot;#为什么需要这样一篇文章&quot; class=&quot;headerlink&quot; title=&quot;为什么需要这样一篇文章&quot;&gt;&lt;/a&gt;为什么需要这样一篇文章&lt;/h3&gt;&lt;p&gt;我们知道 Kotlin 对 Jvm 的支持实在是太好了，以至于我们创建一个 Java 工程，配置一下 Kotlin 的编译插件和标准库就可以很轻松愉快的开始玩耍，什么互调用、什么单步调试都没有毛病——毕竟 KotlinJvm 与 Java 无论从使用上还是从生态上都尽可能的保持了一致，构建也主要用了 gradle，所以从 Java 到 Kotlin 的切换可谓是无缝衔接。&lt;/p&gt;&lt;p&gt;而 Kotlin 同样支持的 JavaScript 就似乎有点儿麻烦了，毕竟二者所处的生态差异略大，KotlinJs 仍然主要采用 gradle 构建，而 JavaScript 的话，例如 Node.js，就使用 npm/yarn 安装管理依赖了。想想可能还是有点儿别扭，你当然可以自己创建一个简单的 KotlinJs 工程，并且自己负责管理 node_modules，但那样的话，node_modules 的依赖并不会被 KotlinJs 直接依赖到，还需要管理 JavaScript 映射到 Kotlin 的接口依赖，例如 jQuery 在 Kotlinjs 侧就有一个接口库方便 Kotlin 以类型安全的方式调用，不过你还是要自己安装好 jQuery 才行，很麻烦对吧。&lt;/p&gt;&lt;p&gt;这一节我们将给大家展示如何搭建一个基于 Node.js 的相对完美的 KotlinJs 的开发环境，这个环境可以做到：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;依赖只需要在 Gradle 中统一管理即可，node_modules 会被自动安装&lt;/li&gt;&lt;li&gt;右键运行 Kotlin 中的 main 函数，就像我们在 KotlinJvm 当中一样&lt;/li&gt;&lt;li&gt;单步调试 Kotlin 代码，全程对 JavaScript 的编译结果无感知&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;基于这个工程，大家就可以很愉快的测试 KotlinJs 的特性啦，就像我们在 KotlinJvm 上面那样，毫无违和感。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法</title>
    <link href="https://www.bennyhuo.com/2019/12/01/kotlin-native-jni-dynamic/"/>
    <id>https://www.bennyhuo.com/2019/12/01/kotlin-native-jni-dynamic/</id>
    <published>2019-12-01T09:39:57.880Z</published>
    <updated>2019-12-01T09:39:57.880Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章我讲了用 <code>@CName</code> 这个神奇的注解，可以配置 Kotlin Native 函数在符号表中的名字，进而根据 Jni 静态绑定的规则来对应到 Java native 方法，但实际开发当中我们更喜欢用动态注册的方式，因为一方面不受名字的约束，不影响代码重构，函数名也相对美观，另一方面调用起来也相对高效，节省了静态绑定的查找过程。</p><a id="more"></a><p>如果大家习惯用 C 写动态绑定的代码，那么 Kotlin Native 写起来思路也是很简单的，只要依样画葫芦，就可以写出来，我们先给出代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="meta-string">"JNI_OnLoad"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">JNI_OnLoad</span><span class="params">(vm: <span class="type">CPointer</span>&lt;<span class="type">JavaVMVar</span>&gt;, preserved: <span class="type">COpaquePointer</span>)</span></span>: jint &#123;</span><br><span class="line">    <span class="keyword">return</span> memScoped &#123;</span><br><span class="line">        <span class="keyword">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br><span class="line">        <span class="keyword">val</span> vmValue = vm.pointed.pointed!!</span><br><span class="line">        <span class="keyword">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br><span class="line">        __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">"Kn"</span>, <span class="string">"JNI_OnLoad"</span>)</span><br><span class="line">        <span class="keyword">if</span>(result == JNI_OK)&#123;</span><br><span class="line">            <span class="keyword">val</span> env = envStorage.pointed!!.pointed!!</span><br><span class="line">            <span class="keyword">val</span> jclass = env.FindClass!!(envStorage.value, <span class="string">"com/example/hellojni/HelloJni"</span>.cstr.ptr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class="number">1</span>)</span><br><span class="line">            jniMethod[<span class="number">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class="line">            jniMethod[<span class="number">0</span>].name = <span class="string">"sayHello2"</span>.cstr.ptr</span><br><span class="line">            jniMethod[<span class="number">0</span>].signature = <span class="string">"()V"</span>.cstr.ptr</span><br><span class="line">            env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">"Kn"</span>, <span class="string">"register say hello2, %d, %d"</span>, sizeOf&lt;CPointerVar&lt;JNINativeMethod&gt;&gt;(), sizeOf&lt;JNINativeMethod&gt;())</span><br><span class="line">        &#125;</span><br><span class="line">        JNI_VERSION_1_6</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是先通过 <code>CName</code> 注解搞定 <code>JNI_OnLoad</code> 函数，让 Java 虚拟机能够在加载 so 库的时候找到这个入口函数，那么我们接下来就是纯调用 Jni 的 C 接口了。</p><p>再说下 <code>memScope</code> 这个东西，C 当中内存管理是人工不智能的，Kotlin Native 则有自己的内存管理机制，因此如果我们需要在 Kotlin Native 当中访问 C 接口，并且创建 C 变量，就需要通过 <code>memScope</code> 来提醒 Kotlin Native 这些变量需要来统一管理。</p><p>获取 JNIEnv 的指针时我们首先构造了一个指针的左值类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br></pre></td></tr></table></figure><p>这么说有些奇怪，总之在 C 的指针类型向 Kotlin Native 映射时，<code>CPointer</code> 的左值类型会映射成 <code>CPointerVar</code>，我现在对 Kotlin Native 与 C 的交互还没有仔细研究，就暂时不展开说了，等后面有机会再系统介绍 Kotlin Native 的细节。</p><p>接下来我们看这句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> vmValue = vm.pointed.pointed!!</span><br></pre></td></tr></table></figure><p>C 版本的定义 <code>JavaVM</code> 其实本身也是一个指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNIInvokeInterface</span>* <span class="title">JavaVM</span>;</span></span><br></pre></td></tr></table></figure><p>因此两个 <code>pointed</code> 的调用相当于获取到了 <code>JNIInvokeInterface</code> 这个结构体，于是后面我们就可以用它持有的函数指针进行获取 <code>JNIEnv</code> 的操作了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br></pre></td></tr></table></figure><p>再稍微提一个事儿，那就是这些类型从 C 的角度映射过来，空类型安全自然是无法保证的，因此我们会见到各种 <code>!!</code> 的使用，这样实际上对于开发来讲非常不友好。因此理想的状况是，我们用 Kotlin Native 对 C 接口进行封装，将这些底层的工作按照 Kotlin 的风格进行转换，这样我们使用起来就会容易得多——官方的 AndroidNativeActivity 的例子当中提供了 JniBridge 及一系列的类其实就是做了这样一件事儿，只不过还不算太完整。</p><p>接下来我们要实现动态绑定了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jclass = env.FindClass!!(envStorage.value, <span class="string">"com/example/hellojni/HelloJni"</span>.cstr.ptr)</span><br><span class="line"><span class="keyword">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class="number">1</span>)</span><br><span class="line">jniMethod[<span class="number">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class="line">jniMethod[<span class="number">0</span>].name = <span class="string">"sayHello2"</span>.cstr.ptr</span><br><span class="line">jniMethod[<span class="number">0</span>].signature = <span class="string">"()V"</span>.cstr.ptr</span><br><span class="line">env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里面也向大家展示了如何将 Kotlin 函数转为 C 的函数指针，总体来讲思路还是很简单的，毕竟我们只是照猫画虎。</p><p>问题也是很显然的，如果你也尝试这样做了，一定被这些映射过来的接口函数的签名给搞晕过：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">var</span> RegisterNatives: kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.CFunction&lt;(kotlinx.cinterop.CPointer&lt;platform.android.JNIEnvVar <span class="comment">/* = kotlinx.cinterop.CPointerVarOf&lt;platform.android.JNIEnv <span class="comment">/* = kotlinx.cinterop.CPointer&lt;platform.android.JNINativeInterface&gt; */</span>&gt; */</span>&gt;?, platform.android.jclass? <span class="comment">/* = kotlinx.cinterop.CPointer&lt;out kotlinx.cinterop.CPointed&gt;? */</span>, kotlinx.cinterop.CPointer&lt;platform.android.JNINativeMethod&gt;?, platform.android.jint <span class="comment">/* = kotlin.Int */</span>) -&gt; platform.android.jint <span class="comment">/* = kotlin.Int */</span>&gt;&gt;? <span class="comment">/* compiled code */</span></span><br></pre></td></tr></table></figure><p>这其实就是 <code>RegisterNatives</code> 这个函数指针的签名，它接受 JNIEnv 的值，jclass，以及一个 JNINativeMethod 结构体的数组和这个数组的长度作为参数，但我们点进去看源码或者看函数前面却需要看这么一大堆东西，直接晕菜。</p><p>这其实也是目前 Kotlin Native 比较麻烦的问题之一：开发体验。尽管 1.0-Beta 出来之后，相比过去要好了许多，但开发体验似乎仍然有待提高，这其实也会直接影响开发者的涌入。</p><p>简单来说，这篇文章没什么太大的技术含量，只是对上一篇文章的一个补充。</p><p>本文涉及源码参见：<a href="https://github.com/enbandari/hello-kni" target="_blank" rel="noopener">hello-kni</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章我讲了用 &lt;code&gt;@CName&lt;/code&gt; 这个神奇的注解，可以配置 Kotlin Native 函数在符号表中的名字，进而根据 Jni 静态绑定的规则来对应到 Java native 方法，但实际开发当中我们更喜欢用动态注册的方式，因为一方面不受名字的约束，不影响代码重构，函数名也相对美观，另一方面调用起来也相对高效，节省了静态绑定的查找过程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin 社区资源介绍</title>
    <link href="https://www.bennyhuo.com/2019/12/01/kotlin-community-cn/"/>
    <id>https://www.bennyhuo.com/2019/12/01/kotlin-community-cn/</id>
    <published>2019-12-01T09:39:57.878Z</published>
    <updated>2019-12-01T09:39:57.878Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。</p><a id="more"></a><ol><li><strong><a href="https://www.kotlincn.net" target="_blank" rel="noopener">Kotlin 中文官网</a></strong>，官网的中文镜像，有社区大佬负责及时跟进翻译，是中文学习的首选资料。</li><li><strong><a href="https://www.kotliner.cn" target="_blank" rel="noopener">Kotlin 中文博客</a></strong>，官方博客的中文镜像，有社区大佬负责及时跟进翻译，可以及时获取 Kotlin 官方的最新动态。</li><li><strong><a href="https://discuss.kotliner.cn" target="_blank" rel="noopener">Kotlin 中文论坛</a></strong>，与官方论坛风格一致，保持原汁原味，大家可以在上面交流学习心得。</li><li><strong>微信公众号 Kotlin</strong>，账号从 2016 年 10月创建，至今已经持续更新两年，主要是我在使用 Kotlin 或者教学过程中的一些经验分享。</li></ol><p>欢迎关注 Kotlin 公众号：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg" alt="Kotlin 公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>也许你需要这个为数据类生成 DeepCopy 方法的库</title>
    <link href="https://www.bennyhuo.com/2019/12/01/deepcopy/"/>
    <id>https://www.bennyhuo.com/2019/12/01/deepcopy/</id>
    <published>2019-12-01T09:39:57.876Z</published>
    <updated>2019-12-01T09:39:57.876Z</updated>
    
    <content type="html"><![CDATA[<p>前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。</p><a id="more"></a><h2 id="我们有什么拷贝的需求？"><a href="#我们有什么拷贝的需求？" class="headerlink" title="我们有什么拷贝的需求？"></a>我们有什么拷贝的需求？</h2><p>我们知道 Kotlin 的 data class 出厂自带了一套 <code>copy</code> 方法，这个 <code>copy</code> 方法呢，就是实打实的一个浅拷贝，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure><p>它的 <code>copy</code> 方法其实就相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name)</span></span> = GitUser(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成员是 <code>val</code> 那倒也还好，可如果是另一个数据类呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)</span><br></pre></td></tr></table></figure><p>我们如果需要 <code>copy</code> 一下 <code>Owner</code> 的话，我们就会发现新实例与旧实例共享了 <code>GitUser</code> 和 <code>Project</code> 的实例，万一项目的名称是可以改的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">var</span> name: String)</span><br></pre></td></tr></table></figure><p>新实例的 <code>project</code> 的名称我想更改一下，结果发现老实例的也被改了。</p><p>所以你需要一个 DeepCopy 的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deepCopy</span><span class="params">(gitUser: <span class="type">GitUser</span> = this.gitUser, project: <span class="type">Project</span> = this.project)</span></span>: Owner &#123;</span><br><span class="line">        <span class="keyword">return</span> Owner(gitUser.copy(), project.copy())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你这时候想，虽然 <code>GitUser</code> 和 <code>Project</code> 这两个数据类内部的字段都是基本类型，用 <code>copy</code> 进行复制似乎也问题不大，可如果它们的成员当中也存在数据类呢？所以，你需要为每一个数据类定制一个 <code>deepCopy</code> 方法。。。</p><h2 id="来来来，先实现个简单的"><a href="#来来来，先实现个简单的" class="headerlink" title="来来来，先实现个简单的"></a>来来来，先实现个简单的</h2><p>天哪。那岂不是要写死了。</p><p>不过问题不大，我们总是会想办法让编译器或者运行时来帮我们搞定一切，于是我想到了要不要写个 Kotlin 的编译期插件呢，正巧 KotlinConf 也有人分享了一下这个话题，不过由于目前这套机制还没有正式开放，就算我写了你们也不敢用，更何况我还不会写呢ψ(｀∇´)ψ</p><p>于是我想到了最简单的，用反射！用反射再配合 Kotlin 最优秀的特性之一的扩展方法，我们就可以为所有的类无缝提供一个 <code>deepCopy</code> 的扩展方法，当然，我们的目标是为数据类服务，所以其他类调用这个方法我们一概直接返回(～￣▽￣)～</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> T.<span class="title">deepCopy</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="comment">//①判断是否为数据类，不是的话直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>::<span class="class"><span class="keyword">class</span>.<span class="title">isData</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//②数据类一定有主构造器，不用怕，这里放心使用 !! 来转为非空类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>::<span class="class"><span class="keyword">class</span>.<span class="title">primaryConstructor</span>!!.<span class="title">let</span> </span>&#123; primaryConstructor -&gt;</span><br><span class="line">        primaryConstructor.parameters</span><br><span class="line">            .map &#123; parameter -&gt;</span><br><span class="line">                <span class="keyword">val</span> value =</span><br><span class="line">                    (<span class="keyword">this</span>::<span class="class"><span class="keyword">class</span> <span class="title">as</span> <span class="title">KClass</span>&lt;<span class="type">T</span>&gt;).<span class="title">declaredMemberProperties</span>.<span class="title">first</span> </span>&#123; it.name == parameter.name &#125;.<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line">                <span class="comment">//③如果主构造器参数类型为数据类，递归调用</span></span><br><span class="line">                <span class="keyword">if</span> ((parameter.type.classifier <span class="keyword">as</span>? KClass&lt;*&gt;)?.isData == <span class="literal">true</span>) &#123;</span><br><span class="line">                    parameter to value?.deepCopy()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parameter to value</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .toMap()</span><br><span class="line">            .let(primaryConstructor::callBy)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去很简单吧！正好秀一波反射的肌肉(￣▽￣)~*</p><p>其实反射还真挺简单的，不会反射的小伙伴们也不要害怕，现在大家都觉得反射有性能问题而不敢用，不会就不会吧(╯°□°）╯︵┻━┻</p><p>这个库我已经扔到 jcenter，因此你可以通过添加依赖来使用它：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.bennyhuo.kotlin:deepcopy-reflect:1.1.0'</span></span><br></pre></td></tr></table></figure><p>当然，这里由于是运行时才知道类型的构造器参数列表，因此没办法添加默认参数。但注解处理器可以呀，不信你瞧——</p><h2 id="来我们再试试注解处理器"><a href="#来我们再试试注解处理器" class="headerlink" title="来我们再试试注解处理器"></a>来我们再试试注解处理器</h2><p>注解处理器实现理论上是可以的。额，实际上当然也是可以的，不然这在 JetBrains 大会上讲过的东西要是不行的话，我可丢不起那人。。。</p><p>不过有些细节需要注意，我们在 Java 编译期的角度是无法认知哪些是数据类的，也没有什么所谓的主构造器一说，所以我们需要通过 <code>Metadata</code> 来获取到这些信息。</p><p>读取 <code>Metadata</code> 需要用到下面这个框架，其实 Kotlin 反射跟这个原理一样，不同之处在于反射在运行时读取，我们则在编译时读取：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">"org.jetbrains.kotlinx:kotlinx-metadata-jvm:0.0.4"</span></span><br></pre></td></tr></table></figure><p>读取的方法我就不细说啦，后面我会提供源码，大家有兴趣可以花两分钟详细阅读下ヽ(；´Д｀)ﾉ</p><p>需要提一句的是，我们通过注解处理器生成的 <code>deepCopy</code> 可以添加默认参数，这里有不少细节需要处理，也是得益于 <code>Metadata</code> 的信息。</p><p>下面给大家看看例子吧：</p><p>首先添加依赖，配置注解处理器：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    <span class="comment">//kotlinx-metadata-jvm 目前部署到了这个仓库</span></span><br><span class="line">    maven &#123; url <span class="string">"https://kotlin.bintray.com/kotlinx/"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">apply plugin: <span class="string">"kotlin-kapt"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    kapt <span class="string">'com.bennyhuo.kotlin:deepcopy-compiler:1.1.0'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.bennyhuo.kotlin:deepcopy-annotations:1.1.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着为我们的数据类配置注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GitUser</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)</span><br></pre></td></tr></table></figure><p>build 一下，生成了下面的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Owner.<span class="title">deepCopy</span><span class="params">(gitUser: <span class="type">GitUser</span> = this.gitUser, project: <span class="type">Project</span> = this.project)</span></span>: Owner =</span><br><span class="line">    Owner(gitUser.deepCopy(), project.deepCopy())</span><br></pre></td></tr></table></figure><p>我们看到，这已经跟出厂自带的 <code>copy</code> 很像了，不同之处就是我们会递归的检查哪些数据类被标注为 <code>DeepCopy</code>，如果标注，就递归调用对应的 <code>deepCopy</code> 函数。</p><p>其实如果不添加默认值，这个注解处理器非常容易写的，因为它不需要处理泛型，不需要处理与 Java 的类型映射，也不需要处理别名，一气呵成，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Owner.<span class="title">deepCopy</span><span class="params">()</span></span>: Owner = Owner(gitUser.deepCopy(), project.deepCopy())</span><br></pre></td></tr></table></figure><p>可是一旦加上了默认值，那就意味着我们需要为函数添加参数，那么我们就需要搞清楚参数的类型，是否协变，等等。但仍然问题不大，经过一下午的折腾（耽误了我看 KPL 季后赛了都），我们支持了参数类型有泛型实参，形参，星投影，甚至泛型参数嵌套，型变，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericParameter</span></span>(<span class="keyword">val</span> map: HashMap&lt;String, List&lt;String&gt;&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericParameterT</span>&lt;<span class="type">K: Number, V</span>&gt;</span>(<span class="keyword">val</span> map: HashMap&lt;K, V&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">StarProjection</span></span>(<span class="keyword">val</span> map: List&lt;Map&lt;*, String&gt;&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Variances1</span></span>(<span class="keyword">val</span> map: HashMap&lt;String, <span class="keyword">out</span> List&lt;Number&gt;&gt;)</span><br></pre></td></tr></table></figure><p>如果还有哪些情况没有覆盖到，那么尽管给我开 Issue 就好啦。</p><h2 id="项目详情"><a href="#项目详情" class="headerlink" title="项目详情"></a>项目详情</h2><p>这个项目在 11月17日的 JetBrains 大会上我已经提到过了，项目在 Github 上，地址：<a href="https://github.com/enbandari/KotlinDeepCopy" target="_blank" rel="noopener">https://github.com/enbandari/KotlinDeepCopy</a>，我知道公众号没法点地址，因此点击阅读原文，就可以很方便的找到它。</p><p>别犹豫了，Star 一波吧，千万别手软。</p><hr><p>转载请注明出处：微信公众号 Kotlin</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>注解处理器教程[全]</title>
    <link href="https://www.bennyhuo.com/2019/12/01/apt-tutorials/"/>
    <id>https://www.bennyhuo.com/2019/12/01/apt-tutorials/</id>
    <published>2019-12-01T09:39:57.863Z</published>
    <updated>2019-12-01T09:39:57.863Z</updated>
    
    <content type="html"><![CDATA[<p>我在做 <a href="https://coding.imooc.com/class/232.html" target="_blank" rel="noopener">基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计</a> 这门课的时候，顺便做了一个注解处理器的框架，叫 <a href="https://github.com/enbandari/TieGuanYin" target="_blank" rel="noopener">Tieguanyin(铁观音)</a>，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 <code>Intent</code> 来传递，有了这个框架我们就可以省去这个麻烦的步骤。</p><p>在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。</p><a id="more"></a><h1 id="视频源码"><a href="#视频源码" class="headerlink" title="视频源码"></a>视频源码</h1><p>见 Github 项目：<a href="https://github.com/enbandari/Apt-Tutorials" target="_blank" rel="noopener">Apt-Tutorials</a></p><h1 id="视频观看"><a href="#视频观看" class="headerlink" title="视频观看"></a>视频观看</h1><h2 id="1-课程简介"><a href="#1-课程简介" class="headerlink" title="1. 课程简介"></a>1. 课程简介</h2><p>作为课程的第一节，我们简单介绍了一下 Apt 的工作原理和流程，并对整个视频课程涉及的内容做了介绍。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/l0728uxh61x.html" target="_blank" rel="noopener">https://v.qq.com/x/page/l0728uxh61x.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=1</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1</a></p><h2 id="2-搭建工程"><a href="#2-搭建工程" class="headerlink" title="2. 搭建工程"></a>2. 搭建工程</h2><p>这一节主要介绍注解处理器工程的结构。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/o07284u5rju.html" target="_blank" rel="noopener">https://v.qq.com/x/page/o07284u5rju.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=2</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2" target="_blank" rel="noopener">https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2</a></p><h2 id="3-解析注解"><a href="#3-解析注解" class="headerlink" title="3. 解析注解"></a>3. 解析注解</h2><p>这一节主要介绍如何解析注解获取被标注的元素信息。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/z07286r97mz.html" target="_blank" rel="noopener">https://v.qq.com/x/page/z07286r97mz.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=3</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3</a></p><h2 id="4-生成常量"><a href="#4-生成常量" class="headerlink" title="4. 生成常量"></a>4. 生成常量</h2><p>这一节为被标注的属性生成一些常量字符串来作为它们的 Key，也展示了如何为生成的 Java 类添加常量。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/k0728tn7sty.html" target="_blank" rel="noopener">https://v.qq.com/x/page/k0728tn7sty.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=4" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=4</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP" target="_blank" rel="noopener">https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP</a></p><h2 id="5-生成-start-方法"><a href="#5-生成-start-方法" class="headerlink" title="5. 生成 start 方法"></a>5. 生成 start 方法</h2><p>这一节为被标注的 Activity 生成携带被标注的属性作为参数的 start 的方法，也展示了如何为生成的 Java 类添加方法。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/x0728j7j7a6.html" target="_blank" rel="noopener">https://v.qq.com/x/page/x0728j7j7a6.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=5" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=5</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5" target="_blank" rel="noopener">https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5</a></p><h2 id="6-生成注入和状态保存的方法"><a href="#6-生成注入和状态保存的方法" class="headerlink" title="6. 生成注入和状态保存的方法"></a>6. 生成注入和状态保存的方法</h2><p>这一节为被标注的 Activity 生成注入属性的 inject 方法和保存状态的 saveState 方法。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/d0728uitqdr.html" target="_blank" rel="noopener">https://v.qq.com/x/page/d0728uitqdr.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=6" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=6</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6" target="_blank" rel="noopener">https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6</a></p><h2 id="7-生成-Kotlin-代码"><a href="#7-生成-Kotlin-代码" class="headerlink" title="7. 生成 Kotlin 代码"></a>7. 生成 Kotlin 代码</h2><p>这一节主要通过为被标注的 Activity 生成扩展方法来介绍如何生成 Kotlin 代码。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/l0728y2inrf.html" target="_blank" rel="noopener">https://v.qq.com/x/page/l0728y2inrf.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=7" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=7</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7" target="_blank" rel="noopener">https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7</a></p><h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h2><p>这一节对整个课程作了一个总结。</p><p><strong>腾讯视频：</strong></p><p><a href="https://v.qq.com/x/page/m072848g85p.html" target="_blank" rel="noopener">https://v.qq.com/x/page/m072848g85p.html</a></p><p><strong>Bilibili：</strong></p><p><a href="https://www.bilibili.com/video/av32905508/?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/av32905508/?p=8</a></p><p><strong>Youtube：</strong></p><p><a href="https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8</a></p><hr><p>欢迎关注 Kotlin 公众号：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg" alt="Kotlin 公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在做 &lt;a href=&quot;https://coding.imooc.com/class/232.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计&lt;/a&gt; 这门课的时候，顺便做了一个注解处理器的框架，叫 &lt;a href=&quot;https://github.com/enbandari/TieGuanYin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tieguanyin(铁观音)&lt;/a&gt;，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 &lt;code&gt;Intent&lt;/code&gt; 来传递，有了这个框架我们就可以省去这个麻烦的步骤。&lt;/p&gt;&lt;p&gt;在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReleasableVar，可以为空的 Kotlin 非空类型 var</title>
    <link href="https://www.bennyhuo.com/2019/12/01/ReleasableVar/"/>
    <id>https://www.bennyhuo.com/2019/12/01/ReleasableVar/</id>
    <published>2019-12-01T09:39:57.862Z</published>
    <updated>2019-12-01T09:39:57.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-题外话：Hadi-的插件"><a href="#0-题外话：Hadi-的插件" class="headerlink" title="0. 题外话：Hadi 的插件"></a>0. 题外话：Hadi 的插件</h1><p>上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：</p><ul><li>Nyan Process Bar</li><li>Presentation Assistant</li></ul><p>也有同学问我ppt的，上周一的文章末尾有提供哈~</p><p>好了下面我们言归正传~</p><h1 id="1-描述下需求"><a href="#1-描述下需求" class="headerlink" title="1. 描述下需求"></a>1. 描述下需求</h1><p>前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 <code>null</code>，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> image: Bitmap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        image = <span class="literal">null</span> <span class="comment">// You cannot do that!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>你想着 Activity 的 <code>onStop</code> 调用了之后到被回收还得等一会儿呢，甚至 <code>onDestroy</code> 都会过一会儿才会被执行到，所以 <code>image</code> 可能会在内存被持有一段时间。所以幸好我们可以通过 <code>recycle</code> 方法先告诉 <code>Bitmap</code> 该释放内存了，不然的话我们只能等着 <code>Activity</code> 回收的时候 <code>image</code> 引用的对象才可以回收。</p><p>不可空类型能够置为 <code>null</code> 看上去是个合理的需求，只要我确定在这之后不再使用就好了。好吧，既然合理，我们就想想办法。</p><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><p>想来想去，这个只能官方提供一个方法了，就像 <code>lateinitVar::isInitialized</code> 一样，提供一个 <code>lateinitVar::release()</code> 然后把 backingfield 的值给清空了不就好了吗？</p><p>这么看来不用官方了，我们自己似乎也可以搞定，写个属性代理即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">releasableNotNull</span><span class="params">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> value ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">"Not Initialized or released already."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span> = value != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用的时候也很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar <span class="keyword">by</span> releasableNotNull&lt;String&gt;()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额，可是怎么才能调用到属性代理对象的方法呢？调用不到的话岂不是白折腾。。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isAccessible = <span class="literal">true</span></span><br><span class="line">    (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">"Delegate is null or is not an instance of ReleasableNotNull."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用反射其实可以很轻松的拿到代理对象的，那么这个故事就快要讲完了——不仅如此，我们还可以仿造 <code>lateinit</code> 定义一个判断是否初始化的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.isInitialized()</span><br><span class="line">            ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">"Delegate is null or is not an instance of ReleasableNotNull."</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="3-干掉反射"><a href="#3-干掉反射" class="headerlink" title="3. 干掉反射"></a>3. 干掉反射</h1><p>然后就有人说，我靠你居然用反射！你作弊！。。。。其实如果用反射，最好的办法是用 Java 反射直接设置为 <code>null</code>，但这个神不知鬼不觉的，你敢用么。算了算了，咱不用反射了好吧。</p><p>其实我们只需要对被代理的属性所在对象与属性代理对象进行绑定，我们就很轻易的通过 <code>KProperty0</code> 的 <code>receiver</code> 拿到属性代理对象了，所以我们需要的只是一个<code>WeakHashMap</code>，当然，这里雀神也提示我说小心对象的相等判断问题，因为这里我们希望每一个对象引用都是不同的，所以我从网上扒了一个 <code>WeakIdentityMap</code> 的集合，对应于有弱引用功能的 <code>IdentityHashMap</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> releasableRefs: WeakIdentityMap&lt;Any, MutableMap&lt;String, ReleasableNotNull&lt;*&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>那么我们只需要在前面的 <code>setValue</code> 当中绑定他们：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> map = releasableRefs[thisRef]</span><br><span class="line">            <span class="keyword">if</span>(map == <span class="literal">null</span>)&#123;</span><br><span class="line">                map = HashMap()</span><br><span class="line">                releasableRefs[thisRef] = map</span><br><span class="line">            &#125;</span><br><span class="line">            map[property.name] = <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>Map 里面又是一个 Map，这意思是说一个对象里面可能有多个成员被代理。接着改写我们的扩展方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> <span class="keyword">as</span>? CallableReference)?.let &#123;</span><br><span class="line">            releasableRefs[it.boundReceiver]?.<span class="keyword">get</span>(<span class="keyword">this</span>.name)?.isInitialized()</span><br><span class="line">        &#125; ?: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? CallableReference)?.let &#123;</span><br><span class="line">        releasableRefs[it.boundReceiver]?.<span class="keyword">get</span>(<span class="keyword">this</span>.name)?.release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-怎么用？"><a href="#4-怎么用？" class="headerlink" title="4. 怎么用？"></a>4. 怎么用？</h1><p>啊，我忘了一件最重要的事儿，也许有小伙伴还不知道 <code>KProperty0</code> 是啥，它其实就是一个顶级变量或者已经绑定完 <code>receiver</code> 的变量，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varInPackage = <span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="string">"World"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性我们通过下面的属性引用得到的就是 <code>KProperty0</code> 的实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::varInPackage</span><br><span class="line"></span><br><span class="line">Foo()::bar</span><br></pre></td></tr></table></figure><p>换句话说，我们开头给出的那个 <code>image</code> 的例子就可以这样写了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> image <span class="keyword">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        image.recycle()</span><br><span class="line">        ::image.release() <span class="comment">// You simply make the backing value null, thus making the gc of this Bitmap instance possible. </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-你想直接用？"><a href="#5-你想直接用？" class="headerlink" title="5. 你想直接用？"></a>5. 你想直接用？</h1><p>我已经把这东西扔到 jCenter了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0&quot;</span><br></pre></td></tr></table></figure><p>完整的源码其实也就那么前面那么几行，有兴趣也可以来我的 Github 给我点个 star：</p><p><a href="https://github.com/enbandari/ReleasableVar" target="_blank" rel="noopener">https://github.com/enbandari/ReleasableVar</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-题外话：Hadi-的插件&quot;&gt;&lt;a href=&quot;#0-题外话：Hadi-的插件&quot; class=&quot;headerlink&quot; title=&quot;0. 题外话：Hadi 的插件&quot;&gt;&lt;/a&gt;0. 题外话：Hadi 的插件&lt;/h1&gt;&lt;p&gt;上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Nyan Process Bar&lt;/li&gt;&lt;li&gt;Presentation Assistant&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也有同学问我ppt的，上周一的文章末尾有提供哈~&lt;/p&gt;&lt;p&gt;好了下面我们言归正传~&lt;/p&gt;&lt;h1 id=&quot;1-描述下需求&quot;&gt;&lt;a href=&quot;#1-描述下需求&quot; class=&quot;headerlink&quot; title=&quot;1. 描述下需求&quot;&gt;&lt;/a&gt;1. 描述下需求&lt;/h1&gt;&lt;p&gt;前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 &lt;code&gt;null&lt;/code&gt;，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainActivity&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Activity &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; image: Bitmap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onStart()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image = Bitmap.create(...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onStop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onStop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image.recycle()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        image = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// You cannot do that!!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新年 Flag 以及论坛的一个所谓“Kotlin 不完全兼容 Java”的问题</title>
    <link href="https://www.bennyhuo.com/2019/12/01/2019-02-05/"/>
    <id>https://www.bennyhuo.com/2019/12/01/2019-02-05/</id>
    <published>2019-12-01T09:39:57.861Z</published>
    <updated>2019-12-01T09:39:57.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-新年立个-Flag"><a href="#0-新年立个-Flag" class="headerlink" title="0. 新年立个 Flag"></a>0. 新年立个 Flag</h3><p>首先祝各位小伙伴在新的中国年里找到属于自己的奋斗方向，凝聚自己的奋斗方法，实现自己的奋斗目标。</p><p>每年春节 0 点之后都喜欢随便做点儿自己喜欢的事情。曾经有一年就是在这个时间憋出了一篇晦涩难懂的协程的文章，所以今年需要在 Kotlin 协程上多写点儿文章，也许也可以写点儿 lib，总之公众号在这一年的发力点，协程算一个，应该也不会局限于 Java 虚拟机。</p><p>我前一阵子写过几次用 Kotlin Native 作为 JNI 的底层实现的文章。Kotlin Native 尽管可能还不是很完美，但就像它的负责人说的，后面的版本就需要来偿还技术债了，毕竟它从诞生开始就面临了类似于我们国内任何一款互联网产品一样的境遇，它如果不够快，也许就赶不上这波节奏了。可能各方面体验还没有那么好，但它的全貌已经完全呈现在我们面前，所以我们要做的就是帮助它，把生态建立起来。所以今年公众号也会把 Kotlin Native 作为一个重点，也许年底我能鼓捣出一个让 KN 写 JNI 变得很方便的 wrapper 呢，希望我时间会比较充裕吧。</p><a id="more"></a><p>一月份实在太忙了，在公司忙，回家还忙，在群里开玩笑说公众号都要长草了，这让我十分痛心。这种状态大约会持续到 2月底，3月份我一定会回归。</p><p>下面我们说我们今天的正题：</p><h3 id="1-Kotlin-不能完全兼容-Java-吗？"><a href="#1-Kotlin-不能完全兼容-Java-吗？" class="headerlink" title="1. Kotlin 不能完全兼容 Java 吗？"></a>1. Kotlin 不能完全兼容 Java 吗？</h3><p>有位大概是被队友坑了的小伙伴，在论坛发帖求助，原帖内容如下：</p><hr><p><strong>原帖开始</strong></p><p>Kotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码 文档上这样说，<br>但是在实际使用上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">public</span> String message;</span><br><span class="line">    <span class="keyword">public</span> String mmm;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiException</span><span class="params">(Throwable throwable, <span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(throwable);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的ApiException 继承自 Exception ，Exception 继承Throwable ，Throwable 是有个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> detailMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kotlin中调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exception = ApiException(Throwable(),<span class="number">1</span>)</span><br><span class="line">exception.code <span class="comment">//正常</span></span><br><span class="line">exception.message <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure><p>错误信息如下：</p><blockquote><p>Overload resolution ambiguity. All these functions match. public final var message</p></blockquote><p>java中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ApiException(Throwable(),<span class="number">1</span>).message 完全正常</span><br></pre></td></tr></table></figure><p>java 代码已经打包成jar，显示 kotlin 中是无法完全调用已经 实现好的java 代码？是否有解决方法，特别是对用打包好的不能改的java代码，无法调用是致命的。</p><p><strong>原帖结束</strong></p><hr><p>看到这个问题，突然觉得以前大家写 Java 代码，得是有多乱，人家明明就已经有了 message，你再继承，再搞出一个来，到底是为什么呢。。。</p><p>题主说有可能是第三方 SDK 这样，没有办法修改源码，怎么办？</p><p>当然是去找到 SDK 的开发者当面 diss 啊。然后弃之不用 ：）</p><p>好啦，对于代码的坏味道，我们要犀利的抨击，不过解决办法还是可以提供一下的，例如帖子里面有个小伙伴说：</p><p>先用 Java 包装一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtApiException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(ApiException a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再在 Kotlin 里面这样调：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = ApiException()</span><br><span class="line"><span class="keyword">val</span> t = (a <span class="keyword">as</span> Throwable).message</span><br><span class="line"><span class="keyword">val</span> r = ExtApiException.getMessage(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ApiException.<span class="title">realMessage</span><span class="params">()</span></span> = ExtApiException.getMessage(<span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">val</span> i = a.realMessage()</span><br></pre></td></tr></table></figure><p>这个小伙伴的思路就很不错，为什么一定要用 Kotlin 兼容这样的代码呢，让 Java 自己收拾自己的烂摊子呗。</p><h3 id="2-为什么-message-会和-getMessage-纠缠不清？"><a href="#2-为什么-message-会和-getMessage-纠缠不清？" class="headerlink" title="2. 为什么 message 会和 getMessage 纠缠不清？"></a>2. 为什么 message 会和 getMessage 纠缠不清？</h3><p>这个问题的根本原因在于 Kotlin 自己定义了一套 Throwable，换句话说 ApiException 在 Kotlin 看来，是继承自 kotlin.Throwable 的，它当中没有 getMessage 方法，对应的是 message 这个成员：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Throwable</span> <span class="keyword">public</span> <span class="keyword">constructor</span></span>(message: kotlin.String?, cause: kotlin.Throwable?) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">val</span> message: kotlin.String? </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个与绝大多数合成属性的情况还不一样，如果是合成的属性，通常我们也可以直接访问对应的 get/set 方法。实际上我们自己定义的类如果不继承存在 Kotlin 到 Java 映射关系的类型，几乎不会遇到类似的问题。</p><h3 id="3-真的没有办法通过-Kotlin-实现访问吗？"><a href="#3-真的没有办法通过-Kotlin-实现访问吗？" class="headerlink" title="3. 真的没有办法通过 Kotlin 实现访问吗？"></a>3. 真的没有办法通过 Kotlin 实现访问吗？</h3><p>Kotlin 在编译到 JVM 上时，会把 Throwable 映射成 java.lang.Throwable，所以我们可以尝试把 ApiException 强转成 java.lang.Throwable，这样你就可以调用 getMessage 了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> exception = ApiException(Throwable(<span class="string">"ThrowableMessage"</span>),<span class="number">1</span>)</span><br><span class="line">println((exception <span class="keyword">as</span> java.lang.Throwable).getMessage())</span><br></pre></td></tr></table></figure><p>不过这时候我们仍然无法调用到 ApiException 的 message 成员（尽管这个设计很蠢。。。），不过没有关系，因为 ApiException 的 message 与kotlin.Throwable 的 message 类型不同，区别在于一个是 var 另一个是 val，以及一个是平台类型 String! 另一个是 String?，通过这两个区别，我们都可以用一些手段让编译器自动帮我们选择合适的成员，具体做法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">property1</span><span class="params">(property: <span class="type">KProperty1</span>&lt;<span class="type">R</span>, T&gt;)</span></span> = property</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">mutableProperty1</span><span class="params">(property: <span class="type">KMutableProperty1</span>&lt;<span class="type">R</span>, T&gt;)</span></span> = property</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ApiException.throwableMessage: String?</span><br><span class="line">        <span class="keyword">get</span>() = property1(Throwable::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ApiException.apiMessage</span><br><span class="line">    <span class="keyword">get</span>() = mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">set</span>(<span class="keyword">this</span>, value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样我们可以通过这两个成员是否可变来让编译器自动选择对应到相应的 property 当中。</p><p>当然我们也可以通过是否可空来区分，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ApiException.apiMessage2: String</span><br><span class="line">    <span class="keyword">get</span>() = property1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>我们如果给 property1 的第二个泛型参数传入 <code>String</code> 而不是 <code>String?</code> 那么结果就是调用 ApiException 当中定义的 message，否则调用 Throwable 当中的 message。</p><p>这个访问的过程实际上也没有什么额外的开销，尽管看上去似乎用了反射，但根本不需要引入反射包，实际上也不会通过反射进行访问。以 apiMessage 为例，反编译的结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloKt</span>$<span class="title">apiMessage</span>$2 <span class="keyword">extends</span> <span class="title">MutablePropertyReference1</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KMutableProperty1 INSTANCE = <span class="keyword">new</span> HelloKt$apiMessage$<span class="number">2</span>();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"message"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getSignature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"getMessage()Ljava/lang/String;"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> KDeclarationContainer <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Reflection.getOrCreateKotlinClass(ApiException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(@Nullable Object receiver)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ((ApiException)receiver).message;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(@Nullable Object receiver, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">      ((ApiException)receiver).message = (String)value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到它的 get 和 set 都是直接对相应的字段做处理，因此不会有任何开销。</p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>这种情况，ApiException 不是 Kotlin 友好的类型，对于这样的类型，或者说类似的 Java 质量并不怎么好的代码，以及典型的 raw 类型的代码，建议用 Java 去访问，或者进行适当包装再交给 Kotlin 去调用。</p><p>当然，我最建议的是，如果有同事写了这样愚蠢的代码让你调用，离他远点儿，免得被带坏 ：）逃。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0-新年立个-Flag&quot;&gt;&lt;a href=&quot;#0-新年立个-Flag&quot; class=&quot;headerlink&quot; title=&quot;0. 新年立个 Flag&quot;&gt;&lt;/a&gt;0. 新年立个 Flag&lt;/h3&gt;&lt;p&gt;首先祝各位小伙伴在新的中国年里找到属于自己的奋斗方向，凝聚自己的奋斗方法，实现自己的奋斗目标。&lt;/p&gt;&lt;p&gt;每年春节 0 点之后都喜欢随便做点儿自己喜欢的事情。曾经有一年就是在这个时间憋出了一篇晦涩难懂的协程的文章，所以今年需要在 Kotlin 协程上多写点儿文章，也许也可以写点儿 lib，总之公众号在这一年的发力点，协程算一个，应该也不会局限于 Java 虚拟机。&lt;/p&gt;&lt;p&gt;我前一阵子写过几次用 Kotlin Native 作为 JNI 的底层实现的文章。Kotlin Native 尽管可能还不是很完美，但就像它的负责人说的，后面的版本就需要来偿还技术债了，毕竟它从诞生开始就面临了类似于我们国内任何一款互联网产品一样的境遇，它如果不够快，也许就赶不上这波节奏了。可能各方面体验还没有那么好，但它的全貌已经完全呈现在我们面前，所以我们要做的就是帮助它，把生态建立起来。所以今年公众号也会把 Kotlin Native 作为一个重点，也许年底我能鼓捣出一个让 KN 写 JNI 变得很方便的 wrapper 呢，希望我时间会比较充裕吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin 协程版的 AutoDispose</title>
    <link href="https://www.bennyhuo.com/2019/12/01/2019-01-07/"/>
    <id>https://www.bennyhuo.com/2019/12/01/2019-01-07/</id>
    <published>2019-12-01T09:39:57.860Z</published>
    <updated>2019-12-01T09:39:57.860Z</updated>
    
    <content type="html"><![CDATA[<p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p><p>因此大家一定会用到 Uber 的开源框架 <a href="https://github.com/uber/AutoDispose" target="_blank" rel="noopener">AutoDispose</a>。</p><a id="more"></a><p>什么？你说你没用？好吧，那就没用吧。。我是不会介绍它的。⊙﹏⊙|||。怎么可能。(～￣▽￣)～。。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">extends</span> <span class="title">MainThreadDisposable</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnAttachStateChangeListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View view;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CompletableObserver observer;</span><br><span class="line"></span><br><span class="line">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.view = view;</span><br><span class="line">    <span class="keyword">this</span>.observer = observer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">    <span class="comment">//看到没看到没看到没？</span></span><br><span class="line">      observer.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    view.removeOnAttachStateChangeListener(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，我最近在想我们用协程其实也会有这样的问题呀：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.onClick &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>await</code> 返回结果之前我们就退出了当前的 <code>Activity</code> 那么，后面 <code>updateUI</code> 就要凉凉。这就尴尬了。不过问题不大，照猫画虎谁不会，我们也可以搞一个 <code>onClickAutoDisposable</code> 嘛。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClickAutoDisposable</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">android</span>.<span class="type">view</span>.<span class="type">View</span>?) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;.asAutoDisposable(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，不要脸的先抄 Anko 的 <code>onClick</code>，不同之处在于我们改了个名 XD。啊，还有我们加了个 <code>.asAutoDisposable(v)</code>，大家就假装有这个方法吧。。。</p><blockquote><p>(╬￣皿￣)=○ 假装个头啊，假装就完成功能的话还要程序员干什么。。让产品假装一下不就行了。。</p></blockquote><p>OK OK，咱们下面来实现它。。想想，<code>GlobalScope.launch</code> 其实返回的是一个 <code>Job</code>，所以嘛，我们给 <code>Job</code> 搞一个扩展方法不就得了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Job.<span class="title">asAutoDisposable</span><span class="params">(view: <span class="type">View</span>)</span></span> = AutoDisposableJob(view, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>第二步，我们再偷偷的创建一个类，叫 <code>AutoDisposableJob</code>，抄一下前面的 <code>Listener</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoDisposableJob</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View, <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Job)</span><br><span class="line">    <span class="comment">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class="line">     : Job <span class="keyword">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> = <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//当 View 被移除的时候，取消协程</span></span><br><span class="line">        cancel()</span><br><span class="line">        view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isViewAttached</span><span class="params">()</span></span> =</span><br><span class="line">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isViewAttached()) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class="line">        invokeOnCompletion() &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就可以使用这个扩展了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.onClickAutoDisposable&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。&lt;/p&gt;&lt;p&gt;因此大家一定会用到 Uber 的开源框架 &lt;a href=&quot;https://github.com/uber/AutoDispose&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AutoDispose&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018 JetBrains 开发者大会见闻</title>
    <link href="https://www.bennyhuo.com/2019/12/01/2018-JetBrains-Day/"/>
    <id>https://www.bennyhuo.com/2019/12/01/2018-JetBrains-Day/</id>
    <published>2019-12-01T09:39:57.859Z</published>
    <updated>2019-12-01T09:39:57.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。</p></blockquote><p>话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg" alt></p><a id="more"></a><p>大会从 7点半开始调试设备，我 8点半左右到达，进去接了一下设备看着没啥大毛病，就跟中文站的贾哥去休息室摆龙门阵去了。当时也遇到了 Hadi ， 他因为当天要分享好几场，在紧张的调试 PPT 效果当中，JetBrains 布道师一哥那可不是玩的，整个一天下来，基本上最让人期待的就是他的分享了。</p><p>开始之前 Lenyo 过来跟我和贾哥说你们对 Kotlin 新特性有什么想问的吗？我说有啊，萌雀雀一直都比较关心 Kotlin 接口的 SAM 的事儿。结果在 Hadi 介绍完 Kotlin 新特性的时候提问，我真的问了，折腾了半天他终于明白了我的意思ヽ(；´Д｀)ﾉ，一句“介个不在我们的规划当中”，瞬间把萌雀雀击伤，并当即表示要卸载 Kotlin（假惺惺，有本事你卸载 IntelliJ 啊(╬￣皿￣)=○）</p><p>JetBrains 公司是一家有趣的公司，开场来自 JetBrains 的大佬们先后从不同的角度分享了这家公司的发展历程，管理文化。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363333557.jpg" alt></p><p>印象比较深的是 Hadi 提到的，”如果你睁开眼，感觉脑子不在线，那就不要来工作了“，”如果定了 KPI，那么所有的努力都只是为了 KPI“，这确实是一件很难把握的事儿，毕竟如果不加任何限制，可能确实会让人放任自流，不过换个角度来看看，如果招来的程序员还需要管，那么说明这些程序员之所以成为程序员，估计就是看到码农赚钱多吧；他还提到他们是没有上班时间的概念的，这个嘛，我们也没有的，国内互联网公司的弹性工作时间也许出发点是好的，但结果却往往成了加班演给老板看。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363496793.jpg" alt></p><p>还有就是关于 Leadership，其中提到一点就是 Delegate，带人其实没有那么轻松吧，团队做出成果自然有你的一份努力，而这一份努力需要花在对团队成员的了解，任务的合理安排，提供必要的帮助和指导上面，这里面 Hadi 有一句话让我特别受益，你安排了任务给其他人，在产出摆在面前的时候千万不要想着你自己完成了之后会比他完成的好 —— 这不公平，你应该考虑提供必要的指导和支持，一方面让事情开展的更加顺利，另一方面也让大家得到成长。</p><p>干程序员这一行，还是需要点儿热爱的。最近大家都说移动客户端没落了，其实不然，大家对待这个领域的态度只是趋于理性和客观了，仍然有公司在招人，比如我们团队 Android 客户端校招就没有招够= =、（有兴趣可以发简历到 <a href="mailto:bennyhuo@kotliner.cn" target="_blank" rel="noopener">bennyhuo@kotliner.cn</a>）。</p><p>Hadi 在上午接着介绍了 Kotlin 1.3 的新特性，这当中涉及了包括我们公众号前不久提到的 NewInference 和 SAMForKotlinFuction，以及注解支持内部成员，协程转正，无符号类型等等这些大家已经熟知的内容，我就不细说啦。</p><p>中午吃饭，伙食还不错，想了想（那个我买不起Σ（ﾟдﾟlll）的）票价，其实也很划算了，65块钱这顿饭就吃回来了(๑•̀ㅂ•́)و✧。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363200631.jpg" alt></p><p>因为下午第一场就要分享，中午吃饭的时候时间比较紧张，怕影响效果没敢多吃，我就吃了一个餐包，三块这个，两块那个，火腿若干，羊肉数块。。。好吧，吃得一点儿也不少，以至于我上台开始讲的时候满脑子都是肉。。⊙﹏⊙|||</p><p>讲之前 PPT 提前10分钟就开始播放了，我刚讲了个开头低头一看时间赫然写着 24:31，心中暗道：尼玛，时间都去哪儿了，我这还没进入状态呢。。。于是加快语速开始狂喷。。。小伙伴们一定在下面不明就里，当我眼看着时间逼近 40 分钟的时候，我果断开大，我靠早知道不做这么多页ppt 了（o´ﾟ□ﾟ`o），终于 43 分钟的时候ppt就剩最后几页，长舒 一口气，结果下来被告知当时其实才 34 分钟。。no！你们没看出来我讲完马上抱着电脑就要跑吗，我还以为超时了。。T^T</p><p>整个活动的时间是非常紧凑的，演讲中间没有时间间隔，节奏不能乱，所以后来贾哥分享完 Ktor 倒是真的超时了，Lenyo 一看时间不够，果断上去提示大家有问题可以线下讨论。</p><p>Hadi 下午的演讲主要是讲 Kotlin 可以在多平台上运行，其实我个人对 Hadi 的几个插件都是非常感兴趣，一个是快捷键提示，这个不同于 Key Promoter，后者在你没有使用快捷键的时候提示你快捷键是什么，前者则是在你用了快捷键的时候告诉观众这是什么快捷键，以及其他平台上对应的是什么：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363067963.jpg" alt></p><p>还有一个是 Nyan 进度条的插件，很有趣：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362917548.jpg" alt></p><p>来自 Google 的钟辉老师也给我们介绍了协程在 Android 当中的使用，Retrofit 即将支持 suspend 函数，这一点我感觉还是很让人开心的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"https://api.github.com/users/jetbrains"</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getJetBrains</span><span class="params">()</span></span>: GitUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，现在我们也可以用 <code>Deferred</code> 来接入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"https://api.github.com/users/jetbrains"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getJetBrains</span><span class="params">()</span></span>: Deferred&lt;GitUser&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后来自蚂蚁的木磊老师分享的内容与 Kotlin 没有太大关系，我就不说啦。</p><p>听完这个分享之后因为我晚上还有其他事情就提前撤了，但听说 Hadi 的第四个分享刷新了很多人对 IntelliJ 的认识：我难道从来没有真正会用过 IntelliJ ！天呐，我错过了几个亿！(ಥ_ಥ)</p><p>不过不要担心啦，已经跟 JetBrains 的工作人员确认过啦，大会的 PPT 以及视频资料都会在后面统一放出来，届时咱们的公众号也会第一时间跟进，所以错过的小伙伴也不用担心！</p><p>下午茶歇的时候，也与群里的小伙伴们一起合影，后来才知道还有其他小伙伴也在现场，所以下回咱们大群应该走一波节奏搞搞气氛~</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362577824.jpg" alt></p><p>这次活动也还遇到了去年在 DroidConf 遇到的小伙伴，凑巧的是那一天正好是 17年的 11月 17日，时隔恰好一年，想来也是有趣，很幸运能结识这么多朋友~</p><p>PS：茶歇的小饼干也很好吃啊！</p><hr><p>下午第一场 “如何优雅地使用数据类” 的 PPT 可以先分享给大家，有问题欢迎到论坛讨论~</p><p>链接：<a href="https://share.weiyun.com/5YMPoL4" target="_blank" rel="noopener">https://share.weiyun.com/5YMPoL4</a> 密码：sz4vyw</p><hr><p>Kotlin 中文站：<a href="https://www.kotlincn.net" target="_blank" rel="noopener">https://www.kotlincn.net</a><br>Kotlin 中文博客：<a href="https://www.kotliner.cn" target="_blank" rel="noopener">https://www.kotliner.cn</a><br>Kotlin 中文论坛：<a href="https://discuss.kotliner.cn" target="_blank" rel="noopener">https://discuss.kotliner.cn</a><br>Ktor 中文站：<a href="https://ktor.kotlincn.net" target="_blank" rel="noopener">https://ktor.kotlincn.net</a></p><hr><p>欢迎关注：微信公众号 Kotlin</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程 番外篇(2) - 协程的几类常见的实现</title>
    <link href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/"/>
    <id>https://www.bennyhuo.com/2019/12/01/coroutine-implementations/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2019-12-01T14:58:41.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。</p></blockquote><a id="more"></a><p>前面一篇文章我们大概讨论了协程是怎么一回事，也举了一些例子，不过整体上覆盖的细节比较少。这篇文章我们按照协程的经典论文 “Revisiting Coroutines” 的思路展开，详细的讨论下协程究竟是怎样的存在。当然由于涉及语言较多，个人水平有限，如有不恰当之处，欢迎大家指正。</p><h2 id="1-协程的分类"><a href="#1-协程的分类" class="headerlink" title="1. 协程的分类"></a>1. 协程的分类</h2><p>协程的主流实现虽然细节上差异较大，但总体来讲仍然有章可循。</p><h3 id="1-1-按调用栈分类"><a href="#1-1-按调用栈分类" class="headerlink" title="1.1 按调用栈分类"></a>1.1 按调用栈分类</h3><p>由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似地，线程会因为 CPU 调度权的切换而被中断，它的中断状态会保存在调用栈当中，因而协程的实现也按照是否开辟相应的调用栈存在以下两种类型：</p><ul><li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li><li>无栈协程 Stackless Coroutine：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法来实现。</li></ul><p>有栈协程的优点就是可以在任意函数调用层级的任意位置进行挂起，并转移调度权，例如 Lua 的协程，这方面多数无栈协程就显得力不从心了，例如 Python 的 Generator；通常来讲，有栈协程因为总是会给协程开辟一块儿栈内存，因此内存开销也相对可观，而无栈协程在内存方面就比较有优势了。</p><p>当然也有反例。</p><p>Go 语言的 go routine 可以认为是有栈协程的一个实现，不过 Go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB，相比之下线程的栈空间通常是 MB 级别，因而它在内存方面的表现也相对轻量。</p><p>Kotlin 的协程是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现的，不过 Kotlin 的协程可以在任意调用层次挂起，换句话说我们启动一个 Kotlin 协程，可以在其中任意嵌套 <code>suspend</code> 函数，而这又恰恰是有栈协程最重要的特性之一：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">level_0</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"I'm in level 0!"</span>)</span><br><span class="line">    level_1() <span class="comment">// ............ ①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">level_1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"I'm in level 1!"</span>)</span><br><span class="line">    suspendNow() <span class="comment">// ............ ②</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendNow</span><span class="params">()</span></span> </span><br><span class="line">        = suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中 ① 处并没有真正直接挂起，② 处的调用才会真正挂起，Kotlin 通过 <code>suspend</code> 函数嵌套调用的方式可以实现任意函数调用层次的挂起。</p><p>当然，想要在任意位置挂起，那就需要调用栈了，与开发者通过调用 API 显式地挂起协程相比，任意位置的挂起主要用于运行时对协程执行的干预，这种挂起方式对于开发者不可见，因而是一种隐式的挂起操作。Go 语言的 go routine 可以通过对 channel 的读写来实现挂起和恢复，除了这种显式地切换调度权之外，Go 运行时还会对长期占用调度权的 go routine 进行隐式挂起，并将调度权转移给其他 go routine，这实际上就是我们熟悉的线程的抢占式调度了。</p><h3 id="1-2-按调度方式分类"><a href="#1-2-按调度方式分类" class="headerlink" title="1.2 按调度方式分类"></a>1.2 按调度方式分类</h3><p>调度过程中，根据协程转移调度权的目标又将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>：</p><ul><li>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。</li><li>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li></ul><p>对称协程实际上已经非常接近线程的样子了，例如 Go 语言中的 go routine 可以通过读写不同的 channel 来实现控制权的自由转移。而非对称协程的调用关系实际上也更符合我们的思维方式，常见的语言对协程的实现大多是非对称实现，例如 Lua 的协程中当前协程调用 <code>yield</code> 总是会将调度权转移给 <code>resume</code> 它的协程；还有就是我们在前面提到的 <code>async</code>/<code>await</code>，<code>await</code> 时将调度权转移到异步调用中，异步调用返回结果或抛出异常时总是将调度权转移回 <code>await</code> 的位置。</p><p>从实现的角度来讲，非对称协程的实现更自然，也相对容易；不过，我们只要对非对称协程稍作修改，即可实现对称协程的能力。在非对称协程的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有的协程在挂起时都将控制权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，例如 Lua 的第三方库 <a href="https://luapower.com/coro" target="_blank" rel="noopener">coro</a>，以及 Kotlin 协程框架中基于 <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html" target="_blank" rel="noopener">Channel</a> 的通信等。</p><h2 id="2-协程的实现举例"><a href="#2-协程的实现举例" class="headerlink" title="2. 协程的实现举例"></a>2. 协程的实现举例</h2><p>我们已经介绍了非常多的协程相关的理论知识，简单来说协程需要关注的就是程序自己处理挂起和恢复，只不过在分类的时候又根据解决挂起和恢复时具体实现细节的不同又区分了按照<strong>栈</strong>的有无和<strong>调度权</strong>转移的对称性的分类。不管怎样，协程的关注点就是程序自己处理挂起和恢复，以下我们给出一些实现，请大家留意它们是如何做到这一点的。</p><h3 id="2-1-Python-的-Generator"><a href="#2-1-Python-的-Generator" class="headerlink" title="2.1 Python 的 Generator"></a>2.1 Python 的 Generator</h3><p>Python 的 Generator 也是协程，是一个典型的无栈协程的实现，我们可以在任意 Python 函数中调用 <code>yield</code> 来实现当前函数调用的挂起，<code>yield</code> 的参数作为对下一次 <code>next(num_generator)</code>调用的返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span>(i) <span class="comment"># ..................... ①</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">num_generator = numbers()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"[0] <span class="subst">&#123;next(num_generator)&#125;</span>"</span>) <span class="comment"># ... ②</span></span><br><span class="line">print(<span class="string">f"[1] <span class="subst">&#123;next(num_generator)&#125;</span>"</span>) <span class="comment"># ... ③</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_generator: <span class="comment"># ............... ④</span></span><br><span class="line">    print(<span class="string">f"[Loop] <span class="subst">&#123;i&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p>所以运行这段程序时，首先会在 ① 处 <code>yield</code>，并将 <code>0</code> 传出，在 ② 处输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0] 0</span><br></pre></td></tr></table></figure><p>接着自 ③ 处调用 <code>next</code>，将调度权从主流程转移到 <code>numbers</code> 函数当中，从上一次挂起的位置 ① 处继续执行，<code>i</code> 的值修改为 <code>1</code>，1s 后，再次通过 <code>yield(1)</code> 挂起，③ 处输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br></pre></td></tr></table></figure><p>后续就以同样的逻辑在 <code>for</code> 循环中一直输出 <code>[Loop] n</code>，直到程序被终止。</p><p>我们看到，之所以称 Python 的 Generator 为协程，就是因为它具备了通过 <code>yield</code> 来挂起当前 Generator 函数的执行，通过 <code>next</code> 来恢复参数对应的 Generator 执行来实现挂起、恢复的协程调度权控制转移的。</p><p>当然，如果在 <code>numbers</code> 函数中嵌套调用 <code>yield</code>，就无法对 <code>numbers</code> 的调用进行中断了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        yield_here(i) <span class="comment"># ................. ①</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yield_here</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span>(i)</span><br></pre></td></tr></table></figure><p>这时候我们再调用 <code>numbers</code> 函数，就会陷入死循环而无法返回，因为这次 <code>yield_here</code> 的返回值才是 Generator。</p><blockquote><p><strong>说明</strong> Python 的 Generator 属于<strong>非对称无栈协程</strong>的一种实现。从 Python 3.5 开始也支持 <code>async</code>/<code>await</code>，原理与 JavaScript 的实现类似，与 Generator 的不同之处在于我们可以通过这一组关键字实现在函数嵌套调用挂起。</p></blockquote><h3 id="2-2-Lua-标准库的协程实现"><a href="#2-2-Lua-标准库的协程实现" class="headerlink" title="2.2 Lua 标准库的协程实现"></a>2.2 Lua 标准库的协程实现</h3><p>Lua 的协程实现可以认为是一个教科书式的案例了，它提供了几个 API 允许开发者灵活控制协程的执行：</p><ul><li><code>coroutine.create</code>：创建协程，参数为函数，作为协程的执行体，返回协程实例。</li><li><code>coroutine.yield</code>：挂起协程，第一个参数为被挂起的协程实例，后面的参数则作为外部调用 <code>resume</code> 来继续当前协程时的返回值，而它的返回值则又是外部下一次 <code>resume</code> 调用时传入的参数。</li><li><code>coroutine.resume</code>：继续协程，第一个参数为被继续的协程实例，后面的参数则作为协程内部 <code>yield</code> 时的返回值，返回值则为协程内部下一次 <code>yield</code> 时传出的参数；如果是第一次对该协程实例执行 <code>resume</code>，参数会作为协程函数的参数传入。</li></ul><p>Lua 的协程也有几个状态，挂起（suspended）、运行（running）、结束（dead）。其中，调用 <code>yield</code> 之后的协程处于挂起态，获得执行权而正在运行的协程则是处于运行态，协程对应的函数运行结束后，则处于结束态。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span> </span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>, <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"send "</span>..i)</span><br><span class="line">        coroutine.<span class="built_in">yield</span>(i) <span class="comment">-- ④</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"End Producer"</span>)</span><br><span class="line"><span class="keyword">end</span>            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(value)</span></span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"receive "</span>..value)</span><br><span class="line">        value = coroutine.<span class="built_in">yield</span>() <span class="comment">-- ⑤</span></span><br><span class="line">    <span class="keyword">until</span>(<span class="keyword">not</span> value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"End Consumer"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">producerCoroutine = coroutine.<span class="built_in">create</span>(producer) <span class="comment">-- ①</span></span><br><span class="line">consumerCoroutine = coroutine.<span class="built_in">create</span>(consumer) <span class="comment">-- ②</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">status</span>, product = coroutine.<span class="built_in">resume</span>(producerCoroutine) <span class="comment">-- ③</span></span><br><span class="line">    coroutine.<span class="built_in">resume</span>(consumerCoroutine, product) <span class="comment">-- ⑥</span></span><br><span class="line"><span class="keyword">until</span>(<span class="keyword">not</span> <span class="built_in">status</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"End Main"</span>)</span><br></pre></td></tr></table></figure><p>这段代码在 ①、②两处创建协程，③处开始执行，<code>producer</code> 在 ④ 处 <code>yield(0)</code>，意味着 ③ 的返回值 <code>product</code> 就是 <code>0</code>，我们把 <code>0</code> 作为参数又传给 <code>consumer</code>，第一次 <code>resume</code> 参数 <code>0</code> 会作为 <code>consumer</code> 的参数 <code>value</code> 传入，因此会打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">send 0</span><br><span class="line">receive 0</span><br></pre></td></tr></table></figure><p>接下来 <code>consumer</code> 通过 ⑤ 处的 <code>yield</code> 挂起，它的参数会作为 ⑥ 处的返回值，不过我们没有传任何参数。这时控制权又回到主流程，<code>status</code> 的值在对应的协程结束后会返回 <code>false</code>，这时候 <code>producer</code> 尚未结束，因此是 <code>true</code>，于是循环继续执行，后续流程类似，输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">send 1</span><br><span class="line">receive 1</span><br><span class="line">send 2</span><br><span class="line">receive 2</span><br><span class="line">send 3</span><br><span class="line">receive 3</span><br><span class="line">End Producer</span><br><span class="line">End Consumer</span><br><span class="line">End Main</span><br></pre></td></tr></table></figure><p>通过这个例子，希望大家能够对协程有一个更加具体的认识，我们看到对于协程来讲，它包括：</p><ul><li>协程的执行体，主要是指启动协程时对应的函数</li><li>协程的控制实例，我们可以通过协程创建时返回的实例控制协程的调用流转</li><li>协程的状态，在调用流程转移前后，协程的状态会发生相应的变化</li></ul><blockquote><p><strong>说明</strong> Lua 标准库的协程属于<strong>非对称有栈协程</strong>，不过第三方提供了基于标准库的<strong>对称协程</strong>的实现，有兴趣的话可以参考： <a href="https://luapower.com/coro" target="_blank" rel="noopener">coro</a>。有趣的是，这也恰恰是<strong>对称协程</strong>的实现可以基于<strong>非对称协程</strong>来实现的很好的例证。</p></blockquote><h3 id="2-3-Go-语言中的-go-routine"><a href="#2-3-Go-语言中的-go-routine" class="headerlink" title="2.3 Go 语言中的 go routine"></a>2.3 Go 语言中的 go routine</h3><p>go routine 的调度没有 Lua 那么明显，没有类似 <code>yield</code> 和 <code>resume</code> 的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// .......... ①</span></span><br><span class="line"><span class="keyword">var</span> readChannel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = channel</span><br><span class="line"><span class="keyword">var</span> writeChannel <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = channel</span><br><span class="line"></span><br><span class="line"><span class="comment">// reader</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// ........................ ②</span></span><br><span class="line">    fmt.Println(<span class="string">"wait for read"</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> readChannel &#123; <span class="comment">// ... ③</span></span><br><span class="line">        fmt.Println(<span class="string">"read"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"read end"</span>)</span><br><span class="line">&#125;()  <span class="comment">// ............................... ④</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// writer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">        fmt.Println(<span class="string">"write"</span>, i)</span><br><span class="line">        writeChannel &lt;- i <span class="comment">// .......... ⑤</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>我们先来简单介绍下 go routine 的启动方式。在任意函数调用前面加关键字 <code>go</code> 即可启动一个 go routine，并在该 go routine 中调用这个函数，例如 ② 处实际上是创建了一个匿名函数，并在后面 ④ 处立即调用了该函数。我们把这两个 go routine 依次称为 “reader” 和 “writer”。</p><p>① 处创建了一个双向的 <code>channel</code>，可读可写，接着创建的 <code>readChannel</code> 声明为只读类型，<code>writeChannel</code> 声明为只写类型，这二者实际上是同一个 <code>channel</code>，并且由于这个 <code>channel</code> 没有缓冲区，因此写操作会一直挂起直到读操作执行，反过来也是如此。</p><p>在 reader 中，③ 处的 <code>for</code> 循环会对 <code>readChannel</code> 进行读操作，如果此时还没有对饮的写操作，就会挂起，直到有数据写入；在 writer 中，⑤ 处表示向 <code>writeChannel</code> 中写入 <code>i</code>，同样，如果写入时尚未有对应的读操作，就会挂起，直到有数据读取。整段程序的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait for read</span><br><span class="line">write 0</span><br><span class="line">read 0</span><br><span class="line">write 1</span><br><span class="line">read 1</span><br><span class="line">write 2</span><br><span class="line">read 2</span><br><span class="line">read end</span><br></pre></td></tr></table></figure><p>如果我们有多个 go routine 对 <code>channel</code> 进行读写，或者有多个 <code>channel</code> 供多个 go routine 读写，那么这时的读写操作实际上就是在 go routine 之间平等的转移调度权，因此可以认为 go routine 是<strong>对称</strong>的协程实现。</p><p>这个示例看上去对于 <code>channel</code> 的读写操作有点儿类似两个线程中的阻塞式 IO 操作，不过 go routine 相对操作系统的内核线程来说要轻量得都，切换的成本也很低，因此在读写过程中挂起的成本也远比我们熟悉的线程阻塞的调用切换成本。实际上这两个 go routine 在切换时，很大概率不会有线程的切换，为了让示例更加能说明问题，我们为输出添加了当前的线程 id，同时将每次向 <code>writeChannel</code> 写入数据之后的 <code>Sleep</code> 操作去掉：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(windows.GetCurrentThreadId(), <span class="string">"wait for read"</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> readChannel &#123;</span><br><span class="line">        fmt.Println(windows.GetCurrentThreadId(), <span class="string">"read"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(windows.GetCurrentThreadId(), <span class="string">"read end"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">        fmt.Println(windows.GetCurrentThreadId(), <span class="string">"write"</span>, i)</span><br><span class="line">        writeChannel &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>修改后的运行结果可以看到程序在输出时所在的线程 id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">181808 write 0</span><br><span class="line">183984 wait for read</span><br><span class="line">181808 read 0</span><br><span class="line">181808 write 1</span><br><span class="line">181808 write 2</span><br><span class="line">181808 read 1</span><br><span class="line">181808 read 2</span><br><span class="line">181808 read end</span><br></pre></td></tr></table></figure><p>两个 go routine 除了开始运行时占用了两个线程，后续都在一个线程中转移调度权（不同场景的实际运行结果可能有细微差异，这取决于 Go 运行时的调度器）。</p><blockquote><p><strong>获取线程 id</strong> 本例在 windows 上调试，通过 <a href="https://github.com/golang/sys" target="_blank" rel="noopener">sys</a> 库的 windows 包下提供的 <code>GetCurrentThreadId</code> 函数来获取线程 id。Linux 系统可以通过 <code>syscall.Gettid</code> 来获取。</p></blockquote><blockquote><p><strong>说明</strong> 我们虽然一直在用 go routine 做例子，并把它称作为<strong>对称有栈协程</strong>的一种实现，但考虑到 Go 运行时本身做了足够多超出其他语言的能力，例如栈优化，调度优化等，特别是的调度器还支持特定场景下的抢占式调度，某种意义上已经超越了协程概念的讨论范围，因此也有很多人认为 go routine 不能简单的认为就是协程。</p></blockquote><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>本文整体上对协程的分类做了较为详细的探讨。不管怎么分类，协程的本质就是程序自己处理挂起和恢复。协程描述了多个程序之间如何通过相互出让运行调度权来完成执行，基于这一对基本的控制转移操作进而衍生出各种异步模型，并发模型例如 <code>async</code>/<code>await</code>，Channel 等。</p><p>相比之下，有朋友抱怨 Kotlin 的协程没有其他语言的 <code>async</code>/<code>await</code> 那么容易上手，也没有 go routine 那么容易使用，原因也很简单，Kotlin 的协程用一个最基本的 <code>suspend</code> 关键字来支持了最基本的挂起恢复逻辑，进而在上层封装，衍生出了以上提到的几乎所有的模型，让我们在 Kotlin 当中可以有机会使用 <code>async</code>/<code>await</code>、Channel，以及最新出的 Flow API，将来还会有更多（也许包括在 issue 中被提到想要重做的 Actor），它想做的事儿太多了，也确实在一步一步地做到。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的朋友，慕课网会在12月收到课程原价等值的定向代金券，可用于补差价升级到新课，由于现在新课限时优惠，因此只需要 77 元即可升级到新课。新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有600+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin 中文论坛的使用技巧</title>
    <link href="https://www.bennyhuo.com/2019/10/22/kotlin-forum-mobile/"/>
    <id>https://www.bennyhuo.com/2019/10/22/kotlin-forum-mobile/</id>
    <published>2019-10-21T16:00:00.000Z</published>
    <updated>2019-12-01T14:58:41.200Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！</p></blockquote><a id="more"></a><p>欢迎访问 <a href="https://discuss.kotliner.cn/" target="_blank" rel="noopener">Kotlin 中文论坛</a> 讨论 Kotlin！为了能够有时间刷论坛，我卸载了知乎卸载了脉脉，来吧，抛出你的问题~~</p><p>大家知道，额，估计不知道吧。。。我们的 Kotlin 中文论坛实际上是采用了与官方论坛相同的框架 <a href="https://www.discourse.org/" target="_blank" rel="noopener">Discourse</a>，很厉害的项目呢。这个框架界面风格都非常的清爽，Github 的论坛、Gradle 论坛好多论坛都采用了这个项目搭建：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716995316308.jpg" alt></p><p>我其实一直以为它的优点就只有这么点儿，直到我发现用手机端的 Chrome 可以直接创建一个快捷方式：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716998152892.jpg" alt></p><p>之后呢？我们就可以在桌面上看到：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999181369.jpg" alt></p><p>点击这个 icon 进入之后，就好像原生 App 一样：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999799086.jpg" alt></p><p>浏览器的地址不见了有没有，使用体验也很不错，小伙伴们就可以随时随地刷论坛啦！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！</p><hr><p>经过小伙伴们之处，桌面也可以：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720452651204.jpg" alt></p><p>然后就得到了一个桌面 APP 有木有！</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720453054368.jpg" alt></p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的朋友，慕课网会在12月收到课程原价等值的定向代金券，可用于补差价升级到新课，由于现在新课限时优惠，因此只需要 77 元即可升级到新课。新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有600+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程 番外篇(1) - 协程为什么被称为『轻量级线程』？</title>
    <link href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/"/>
    <id>https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/</id>
    <published>2019-10-18T16:00:00.000Z</published>
    <updated>2019-12-01T14:58:41.194Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接触新概念，最好的办法就是先整体看个大概，再回过头来细细品味。</p></blockquote><a id="more"></a><p>文中如果没有特别说明，协程指编程语言级别的协程，线程则特指操作系统内核线程。</p><h2 id="1-协程到底是啥？"><a href="#1-协程到底是啥？" class="headerlink" title="1. 协程到底是啥？"></a>1. 协程到底是啥？</h2><p>Kotlin 的协程从 v1.1 开始公测(Experimental) 到现在，已经算是非常成熟了，但大家对它的看法却一直存在各种疑问，为什么呢？因为即便我们把 Kotlin 丢掉，单纯协程这个东西本身就已经长时间让大家感到疑惑了，不信的话可以单独搜一下协程或者 Coroutine，甚至连 Lua 之父在提到为什么协程鲜见于早期语言实现，就是因为这概念没有一个清晰的界定。</p><p>更有意思的是，在查阅资料的过程中，你会经常会陷入一种一会儿『啊，我懂了』，一会儿『啊，我懂个屁』的循环当中，不瞒各位说，我从七八年前刚开始学 Lua 的时候面对 Lua 的协程也是这个破感觉，后来接触 goroutine 又来了一遍，接触 Kotlin 的协程又来了一遍，习惯就好。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712859864288.jpg" alt></p><p>那么问题的关键在于，协程的概念是不是真的混乱呢？其实不是的，协程的概念最核心的点其实就是函数或者一段程序能够被挂起（说暂停其实也没啥问题），待会儿再恢复，挂起和恢复是开发者的程序逻辑自己控制的，协程是通过主动挂起出让运行权来实现协作的，就没了，一句话就能说明白的事儿是不是特简单？它跟线程最大的区别在于线程一旦开始执行，从任务的角度来看，就不会被暂停，直到任务结束这个过程都是连续的，线程之间是抢占式的调度，因此也不存在协作问题。</p><p>那么我们再来理一理协程的概念：</p><ul><li>挂起恢复</li><li>程序自己处理挂起恢复</li><li>程序自己处理挂起恢复来实现协程的协作运行</li></ul><p>关键核心就是协程是一个能挂起并且待会儿恢复执行的东西。任何时候自己产生疑惑的时候都回过来再想想这几句话，就算协程最终呈现给我们的样子可能『花里胡哨』，但万变不离其宗。</p><blockquote><p>有的朋友不理解什么叫挂起，挂起这个词其实还真是源于操作系统的叫法，直观的理解上，你就当做暂停理解吧。</p></blockquote><h2 id="2-为什么协程的概念会有混乱的感觉？"><a href="#2-为什么协程的概念会有混乱的感觉？" class="headerlink" title="2. 为什么协程的概念会有混乱的感觉？"></a>2. 为什么协程的概念会有混乱的感觉？</h2><p>我们前面提到，协程的概念其实并不混乱，那么混乱的是什么？是各家对它的实现。这就好像牛顿第二定律一样，看似很简单，F = ma，用起来就五花八门了，衍生的各种公式更是层出不穷。</p><p>协程不就是要挂起、恢复么，请问挂起恢复具体要怎么做？没有定义呀。既然没有定义是不是就可以随便？是的，抓住老鼠就是好猫~</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712868953541.jpg" alt></p><p>协程这一点儿跟线程真的是没法比啊，主流操作系统都有成熟的线程模型，应用层经常提到的线程的概念大多就是映射方式的差异，所以不同的编程语言一旦引入了线程，那么基本上就是照搬了系统线程的概念，线程本身也不是他们实现的——这很好理解，因为线程调度是操作系统做的嘛。</p><blockquote><p>Java 对线程做了很好的支持，这也是 Java 在高并发场景风生水起的一个关键支柱，不过如果你有兴趣去看下虚拟机底层对线程的支持，例如 Android 虚拟机，其实就是 pthread。Java 的 Object 还有一个 wait 方法，这个方法几乎支撑了各种锁的实现，它底层是 condition。</p></blockquote><p>绝大多数协程都是语言层面自己的实现，不同的编程语言有不同的使用场景，自然在实现上也看似有很大的差异，甚至还有的语言自己没有实现协程，但开发者通过第三方框架的方式提供了协程的能力，例如 Java 的框架 <a href="http://docs.paralleluniverse.co/quasar/" target="_blank" rel="noopener">Quasar</a>，加上协程实现本身在操作系统层面就有过一系列演进，因此出现了虽然理论上看起来很简单，但实现上却多样化的局面。</p><h2 id="3-协程有哪些主流的实现？"><a href="#3-协程有哪些主流的实现？" class="headerlink" title="3. 协程有哪些主流的实现？"></a>3. 协程有哪些主流的实现？</h2><p>我们在前面讲各个语言的实现有差异，说的是看似有很大的差异，主要是各自的关键字、类型命名不一样，但总结下来大家对于协程的分类更倾向于按照有没有栈来分，即：</p><ul><li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li><li>无栈协程 Stackless Coroutine：协程没有自己的调用栈。</li></ul><p>栈这个东西大家应该都很熟悉了，我们递归调用函数的层次太多就会导致 <code>StackOverflowException</code>，因为栈内存是有限的；我们的程序出现了异常我们总是希望看到异常点的调用关系，这样方便定位问题，这也需要栈。</p><p>有栈协程有什么好处呢？因为有栈，所以在任何一个调用的地方运行时都可以选择把栈保存起来，暂停这个协程，听起来就跟线程一样了，只不过挂起和恢复执行的权限在程序自己，而不是操作系统。缺点也是非常明显的，每创建一个协程不管有没有在运行都要为它开辟一个栈，这也是目前无栈协程流行的原因。</p><blockquote><p>goroutine 看上去似乎不像协程，因为开发者自己无法决定一个协程的挂起和恢复，这个工作是 go 运行时自己处理的。为了支持 goroutine 在任意位置能挂起，goroutine 其实是一个有栈协程，go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB。</p></blockquote><p>JavaScript、C# 还有 Python 的协程，或者干脆就说 async/await，相比之下就轻量多了，它们看起来更像是针对回调加了个语法糖的支持——它们其实就是无栈协程的实现了。无栈，顾名思义，每一个协程都不会单独开辟调用栈，那么问题来了，它的上下文是如何保存的？</p><p>这就要提到传说中的 CPS 了，即 continuation-passing-style。我们来想象一下，程序被挂起，或者说中断，最关键的是什么？是保存挂起点，或者中断点，对于线程被操作系统中断，中断点就是被保存在调用栈当中的，而我们的无栈协程要保存到哪儿呢？保存到 Continuation 对象当中，这个东西可能在不同的语言当中叫法不一样，但本质上都是一个 Continuation，它就是一个普通的对象，占用内存非常小，还是很抽象是吧，想想你常见的 Callback，它其实就是一个 Continuation 的实现。</p><blockquote><p>Kotlin 的协程的根基就是一个叫做 Continuation 的类。我在前面的文章不止一次提到，这家伙长得横看竖看就是一个回调，resume 就是 onSuccess，resumeWithException 就是 onFailure。</p></blockquote><p>Continuation 携带了协程继续执行所需要的上下文，同时它自己又是挂起点，因为待会儿恢复执行的时候只需要执行它回调的函数体就可以了。对于 Kotlin 来讲，每一个 <code>suspend</code> 函数都是一个挂起点，意味着对于当前协程来说，每遇到一个 <code>suspend</code> 函数的调用，它都有可能会被挂起。每一个 <code>suspend</code> 函数都被编译器插入了一个 Continuation 类型的参数用来保存当前的调用点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = suspendCoroutine&lt;<span class="built_in">Int</span>&gt;&#123; continuation -&gt;</span><br><span class="line">    println(<span class="string">"Hello"</span>)</span><br><span class="line">    continuation.resumeWith(Result.success(<span class="number">10086</span>))</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">我们定义了一个 `<span class="keyword">suspend</span>` 函数 `hello`，它看起来没有接收任何参数，如果真是这样，请问我们在后面调用 `resumeWith` 的 `continuation` 是哪里来的？</span><br><span class="line"></span><br><span class="line">都说挂起函数必须在协程内部调用，其实也不是，我们在前面讲挂起原理的时候就用 Java 代码直接去调用 `<span class="keyword">suspend</span>` 函数，大家也会发现这些 `<span class="keyword">suspend</span>` 函数都需要传入一个额外的 `Continuation`，就是这个意思。</span><br><span class="line"></span><br><span class="line">当然，Java 也不是必须的，我们只需要用点儿 Kotlin 反射，一样可以直接让 `<span class="keyword">suspend</span>` 函数现出原形：</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line"><span class="keyword">val</span> helloRef = ::hello</span><br><span class="line"><span class="keyword">val</span> result = helloRef.call(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"resumeWith: <span class="subst">$&#123;result.getOrNull()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这与我们在协程挂起原理那篇的做法如出一辙，我们虽然没有办法直接调用 <code>hello()</code>，但我们可以拿到它的函数引用，用发射调用它（这个做法后续可能也会被禁掉，但 1.3.50 目前仍然是可用的），调用的时候如果你什么参数都不传，编译器就会提示你它需要一个参数，呃，你看，它这么快就投降了——需要的这个参数正是 <code>Continuation</code>。</p><p>再强调一下，这段代码不需要运行在协程体内，或者其他的 <code>suspend</code> 函数中。现在请大家仔细想想，为什么官方要求 <code>suspend</code> 函数一定要运行在协程体内或者其他 <code>suspend</code> 函数中呢？</p><p>答案自然就是任何一个协程体或者 <code>suspend</code> 函数中都有一个隐含的 <code>Continuation</code> 实例，编译器能够对这个实例进行正确传递，并将这个细节隐藏在协程的背后，让我们的异步代码看起来像同步代码一样。</p><p>说到这里，我们已经接近 Kotlin 协程的本质了，它是一种无栈协程实现，它的本质就是一段代码 + Continuation 实例。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712876557532.jpg" alt></p><h2 id="4-Kotlin-协程真的只是一个线程框架吗？"><a href="#4-Kotlin-协程真的只是一个线程框架吗？" class="headerlink" title="4. Kotlin 协程真的只是一个线程框架吗？"></a>4. Kotlin 协程真的只是一个线程框架吗？</h2><p>这个说法其实是很奇怪的。我如果问你线程其实是一个 CPU 框架吗，你肯定会觉得这俩，啥啊？？？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712877286523.jpg" alt></p><p>Kotlin 协程确实在实现的过程中提供了切线程的能力，这是它的能力，不是它的身份，就好比拿着学位证非说这是身份证一样，学位证描述的是这人能干啥，不能描述这人是谁。</p><blockquote><p>杠精们可能会说学位证有照片有名字啊。你拿着学位证去买飞机票你看人家认不认呗。</p></blockquote><p>协程的世界可以没有线程，如果操作系统的 CPU 调度模型是协程的话；反过来也成立——这个应该不会有人反对吧。Kotlin 协程是不是可以没有线程呢？至少从 Java 虚拟机的实现上来看，好像。。。。不太行啊。没错，是不太行，不过这不是 Kotlin 协程的问题，是 Java 虚拟机的问题，谁让 Java 虚拟机的线程用起来没有那么难用呢，在它刚出来的时候简直吊打了当时其他语言对并发的支持（就像 goroutine 出来的时候吊打它一样）。</p><p>我们知道 Kotlin 除了支持 Java 虚拟机之外，还支持 JavaScript，还支持 Native。JavaScript 无论是跑在 Web 还是 Node.js 当中，都是单线程玩耍的；Kotlin Native 虽然可以调用 pthread，但官方表示我们有自己的并发模型（Worker），不建议直接使用线程。在这两个平台上跑，Kotlin 的协程其实都是单线程的，又怎么讲是个线程框架呢？</p><p>说到这儿可能又有人有疑问了，单线程要协程能做什么呢？这个前端同学可能会比较有感触，谁跟你们说的异步一定要多线程。。Android 开发的同学其实可以想想你在 <code>Activity</code> 刚创建的时候想要拿到一个 <code>View</code> 的大小一般返回都是 0，因为 <code>Activity</code> 的布局是在 <code>onResume</code> 方法调用之后完成的，所以 <code>handler.post</code> 一下就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    handler.post &#123;</span><br><span class="line">        <span class="keyword">val</span> width = myView.width</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是异步代码嘛，但这代码其实都运行在主线程的，我们当然可以用协程改写一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        <span class="keyword">val</span> width = handler.postSuspend &#123;</span><br><span class="line">            myView.width</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(<span class="string">"MyView"</span>, width.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Handler.<span class="title">postSuspend</span><span class="params">(block: () -&gt; <span class="type">T</span>)</span></span> = suspendCoroutine&lt;T&gt; &#123;</span><br><span class="line">    post &#123;</span><br><span class="line">        it.resume(block())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我个人觉得如果 Kotlin 协程的默认的调度器是 <code>Main</code>，并且这个 <code>Main</code> 会根据各自平台选择一个合适的事件循环，这样更能体现 Kotlin 协程在不同平台的一致性，例如对于 Android 来说 <code>Main</code> 就是 UI 线程上的事件循环，对于 Swing 同样是 Swing 的 UI 事件循环，只要是有事件循环的平台就默认基于这个循环来一个调度器，没有默认事件循环的也好办，Kotlin 协程本身就有 <code>runBlocking</code> 嘛，对于普通 Java 程序来说没有事件循环就给它构造一个就行了。</p><p>Kotlin 协程的设计者没有这样做，他们当然也有他们的道理，毕竟他们不愿意强迫开发者一定要用协程，甚至立刻马上就得对原有的代码进行改造，他们希望 Kotlin 只是一门编程语言，一门提供足够安全保障和灵活语法的编程语言，剩下的交给开发者去选择。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712879342461.jpg" alt></p><h2 id="5-协程真的比线程有优势吗？"><a href="#5-协程真的比线程有优势吗？" class="headerlink" title="5. 协程真的比线程有优势吗？"></a>5. 协程真的比线程有优势吗？</h2><p>这可不是一个很容易回答的问题。</p><p>Kotlin 协程刚出来的时候，有人就做过性能对比，觉得协程没有任何性能优势。我们完全可以认为他的测试方法是专业的，在一些场景确实用协程不会有任何性能上的优势，这就好比我们需要在一个单核 CPU 上跑一个计算密集型的程序还要开多个线程跑一样，任何特性都有适合它的场景和不适合它的领域。</p><p>想必大家看各类讲解协程的文章都会提到协程比线程轻量，这个其实我们前面也解释过了，编程语言级别实现的协程就是程序内部的逻辑，不会涉及操作系统的资源之间的切换，操作系统的内核线程自然会重一些，且不说每创建一个线程就会开辟的栈带来的内存开销，线程在上下文切换的时候需要 CPU 把高速缓存清掉并从内存中替换下一个线程的内存数据，并且处理上一个内存的中断点保存就是一个开销很大的事儿。如果没有直观的感受的话，就尽情想象一下你正要拿五杀的时候公司领导在微信群里发消息问你今天的活跃怎么跌了的场景。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712882561417.jpg" alt></p><p>线程除了包含内核线程本身执行代码能力的含义以外，通常也被赋予了逻辑任务的概念，所以协程是一种轻量级的『线程』的说法，更多描述的是它的使用场景，这句话也许这样说更贴切一些：</p><p><strong>协程更像一种轻量级的『线程』。</strong></p><p>线程自然可以享受到并行计算的优待，协程则只能依赖程序内部的线程来实现并行计算。协程的优势其实更多是体现在 IO 密集型程序上，这对于 Java 开发者来说可能又是一个很迷惑的事情，因为大家写 Java 这么多年，很少有人用上 NIO，绝大多数都是用 BIO 来读写 IO，因此不管开线程还是开协程，读写 IO 的时候总是要有一个线程在等待 IO，所以看上去似乎也没有什么区别。但用 NIO 就不一样了，IO 不阻塞，通过开一个或很少的几个线程来 select IO 的事件，有 IO 事件到达时再分配相应的线程去读写 IO，比起传统的 IO 就已经有了很大的提升。</p><p>欸？没有写错吗？你写的可是线程啊？</p><p>对啊，用了 NIO 以后，本身就可以减少线程的使用，没错的。可是协程呢？协程可以基于这个思路进一步简化代码的组织，虽然线程就能解决问题，但写起来其实是很累的，协程可以让你更轻松，特别是遇到多个任务需要访问公共资源时，如果每个任务都分配一个线程去处理，那么少不了就有线程会花费大量的时间在等待获取锁上，但如果我们用协程来承载任务，用极少量的线程来承载协程，那么锁优化就变得简单了：协程如果无法获取到锁，那么协程挂起，对应的线程就可以让出去运行其他协程了。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712887435643.jpg" alt></p><p>我更愿意把协程作为更贴近业务逻辑甚至人类思考层面的一种抽象，这个抽象层次其实已经比线程更高了。线程可以让我们的程序并发的跑，协程可以让并发程序跑得看起来更美好。</p><blockquote><p>线程本身就可以，为什么要用协程呢？这就像我们经常被人问起 Java 就可以解决问题，我为什么要用 Kotlin 呢？为什么你说呢？</p></blockquote><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712891180933.jpg" alt></p><p>总的来说，不管是异步代码同步化，还是并发代码简洁化，协程的出现其实是为代码从计算机向人类思维的贴近提供了可能。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的朋友，慕课网会在12月收到课程原价等值的定向代金券，可用于补差价升级到新课，由于现在新课限时优惠，因此只需要 77 元即可升级到新课。新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有600+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;接触新概念，最好的办法就是先整体看个大概，再回过头来细细品味。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(9) - Channel 篇</title>
    <link href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/"/>
    <id>https://www.bennyhuo.com/2019/09/16/coroutine-channel/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2019-12-01T14:58:41.207Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Channel</code> 实际上就是协程在生产消费者模型上的应用，把过去你用 <code>BlockingQueue</code> 实现的功能替换成 <code>Channel</code>，也许会有新的发现~</p></blockquote><a id="more"></a><h2 id="1-认识-Channel"><a href="#1-认识-Channel" class="headerlink" title="1. 认识 Channel"></a>1. 认识 Channel</h2><p>Channel 实际上就是一个队列，而且是并发安全的，它可以用来连接协程，实现不同协程的通信。废话不多说，直接看例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            channel.send(i++)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> element = channel.receive()</span><br><span class="line">            Logger.debug(element)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    producer.join()</span><br><span class="line">    consumer.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们构造了两个协程，分别叫他们 producer 和 consumer，我们没有明确的指定调度器，所以他们的调度器都是默认的，在 Java 虚拟机上就是那个大家都很熟悉的线程池：他们可以运行在不同的线程上，当然也可以运行在同一个线程上。</p><p>例子的运行机制是，producer 当中每隔 1s 向 <code>Channel</code> 中发送一个数字，而 consumer 那边则是一直在读取 Channel 来获取这个数字并打印，我们能够发现这里发端是比收端慢的，在没有值可以读到的时候，receive 是挂起的，直到有新元素 send 过来——所以你知道了 receive 是一个挂起函数，那么 send 呢？</p><h2 id="2-Channel-的容量"><a href="#2-Channel-的容量" class="headerlink" title="2. Channel 的容量"></a>2. Channel 的容量</h2><p>如果你自己去 IDE 写了这段代码，你会发现 send 也是挂起函数。额，发端为什么会挂起？想想我们以前熟知的 <code>BlockingQueue</code>，我们往里面添加元素的时候，元素在队列里实际上是占用了空间的，如果这个队列空间不足，那么再往里面添加的时候就是两种情况：1. 阻塞，等待队列腾出空间；2. 抛异常，拒绝添加元素。send 也会面临同样的问题，我们说 Channel 实际上就是一个队列嘛，队列不应该有缓冲区吗，那么这个缓冲区一旦满了，并且也一直没有人调用 receive 取走元素的话，send 不就挂起了嘛。那么接下来我们看下 <code>Channel</code> 的缓冲区的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> <span class="title">Channel</span><span class="params">(capacity: <span class="type">Int</span> = RENDEZVOUS)</span></span>: Channel&lt;E&gt; =</span><br><span class="line">    <span class="keyword">when</span> (capacity) &#123;</span><br><span class="line">        RENDEZVOUS -&gt; RendezvousChannel()</span><br><span class="line">        UNLIMITED -&gt; LinkedListChannel()</span><br><span class="line">        CONFLATED -&gt; ConflatedChannel()</span><br><span class="line">        <span class="keyword">else</span> -&gt; ArrayChannel(capacity)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们构造 <code>Channel</code> 的时候调用了一个叫 <code>Channel</code> 的函数，hmm，这玩意儿确实不是它的构造器，在 Kotlin 当中我们可以随便定义一个顶级函数跟某些类名一样来伪装成构造器，这本质上就是个工厂方法。</p><blockquote><p>类似的还有 String，不信你去试试</p></blockquote><p>它有一个参数叫 capacity，指定缓冲区的容量，默认值 <code>RENDEZVOUS</code> 就是 0，这个词本意就是描述“不见不散”的场景，所以你不来 receive，我这 send 就一直搁这儿挂起等着。换句话说，我们开头的例子里面，如果 consumer 不 receive，producer 里面的第一个 send 就给挂起了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        i++ <span class="comment">//为了方便输出日志，我们将自增放到前面</span></span><br><span class="line">        Logger.debug(<span class="string">"before send <span class="variable">$i</span>"</span>)</span><br><span class="line">        channel.send(i)</span><br><span class="line">        Logger.debug(<span class="string">"before after <span class="variable">$i</span>"</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        delay(<span class="number">2000</span>) <span class="comment">//receive 之前延迟 2s</span></span><br><span class="line">        <span class="keyword">val</span> element = channel.receive()</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们故意让收端的节奏放慢，你就会发现，send 总是会挂起，直到 receive 之后才会继续往下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">07:11:23:119 [DefaultDispatcher-worker-2 @coroutine#1]  before send 1</span><br><span class="line">07:11:24:845 [DefaultDispatcher-worker-2 @coroutine#2]  1</span><br><span class="line">07:11:24:846 [DefaultDispatcher-worker-2 @coroutine#1]  before after 1</span><br><span class="line">07:11:25:849 [DefaultDispatcher-worker-4 @coroutine#1]  before send 2</span><br><span class="line">07:11:26:850 [DefaultDispatcher-worker-2 @coroutine#2]  2</span><br><span class="line">07:11:26:850 [DefaultDispatcher-worker-3 @coroutine#1]  before after 2</span><br></pre></td></tr></table></figure><p><code>UNLIMITED</code> 比较好理解，来者不拒，从它给出的实现 <code>LinkedListChannel</code> 来看，这一点也与我们的 <code>LinkedBlockingQueue</code> 有异曲同工之妙。</p><p><code>CONFLATED</code>，这个词是合并的意思，跟 inflate 是同一个词根，con- 前缀表示反着来，那是不是说我发了个 1、2、3、4、5 那边收的时候就会收到一个 [1,2,3,4,5] 的集合呢？毕竟字面意思是合并嘛。但实际上这个的效果是只保留最后一个元素，不是合并，应该是置换，换句话说，这个类型的 Channel 有一个元素大小的缓冲区，但每次有新元素过来，都会用新的替换旧的，也就是说我发了个 1、2、3、4、5 之后收端才接收的话，就只能收到 5 了。</p><p>剩下的就是 <code>ArrayChannel</code> 了，它接收一个值作为缓冲区容量的大小，这也比较类似于 <code>ArrayBlockingQueue</code>。</p><h2 id="3-迭代-Channel"><a href="#3-迭代-Channel" class="headerlink" title="3. 迭代 Channel"></a>3. 迭代 Channel</h2><p>前面我们在发送和读取 <code>Channel</code> 的时候用了 <code>while(true)</code>，因为我们想要去不断的进行读写操作，<code>Channel</code> 本身实际上也有点儿像序列，可以一个一个读，所以我们在读取的时候也可以直接获取一个 <code>Channel</code> 的 iterator：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> iterator = channel.iterator()</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123; <span class="comment">// 挂起点</span></span><br><span class="line">        <span class="keyword">val</span> element = iterator.next()</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个时候，iterator.hasNext() 是挂起函数，在判断是否有下一个元素的时候实际上就需要去 <code>Channel</code> 当中读取元素了。</p><p>这个写法自然可以简化成 for each：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> channel) &#123;</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-produce-和-actor"><a href="#4-produce-和-actor" class="headerlink" title="4. produce 和 actor"></a>4. produce 和 actor</h2><p>前面我们在协程外部定义 <code>Channel</code>，并在协程当中访问它，实现了一个简单的生产-消费者的示例，那么有没有便捷的办法构造生产者<br>和消费者呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> receiveChannel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = GlobalScope.produce &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        send(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>produce</code> 这个方法启动一个生产者协程，并返回一个 <code>ReceiveChannel</code>，其他协程就可以拿着这个 <code>Channel</code> 来接收数据了。反过来，我们可以用 <code>actor</code> 启动一个消费者协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sendChannel: SendChannel&lt;<span class="built_in">Int</span>&gt; = GlobalScope.actor&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> element = receive()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ReceiveChannel 和 SendChannel 都是 Channel 的父接口，前者定义了 receive，后者定义了 send，Channel 也因此既可以 receive 又可以 send。</p></blockquote><p><code>produce</code> 和 <code>actor</code> 与 <code>launch</code> 一样都被称作“协程启动器”。通过这两个协程的启动器启动的协程也自然的与返回的 <code>Channel</code> 绑定到了一起，因此 <code>Channel</code> 的关闭也会在协程结束时自动完成，以 <code>produce</code> 为例，它构造出了一个 <code>ProducerCoroutine</code> 的对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerCoroutine</span>&lt;<span class="type">E</span>&gt;</span>(</span><br><span class="line">    parentContext: CoroutineContext, channel: Channel&lt;E&gt;</span><br><span class="line">) : ChannelCoroutine&lt;E&gt;(parentContext, channel, active = <span class="literal">true</span>), ProducerScope&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCompleted</span><span class="params">(value: <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        _channel.close() <span class="comment">// 协程完成时</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancelled</span><span class="params">(cause: <span class="type">Throwable</span>, handled: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> processed = _channel.close(cause) <span class="comment">// 协程取消时</span></span><br><span class="line">        <span class="keyword">if</span> (!processed &amp;&amp; !handled) handleCoroutineException(context, cause)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在协程完成和取消的方法调用中，对应的 <code>_channel</code> 都会被关闭。</p><p>这样看上去还是挺有用的。不过截止这俩 API <code>produce</code> 和 <code>actor</code> 目前都没有稳定，前者仍被标记为 <code>ExperimentalCoroutinesApi</code>，后者则标记为 <code>ObsoleteCoroutinesApi</code>，这就比较尴尬了，明摆着不让用嘛。<code>actor</code> 的文档中提到的 issue 的讨论也说明相比基于 Actor 模型的并发框架，Kotlin 协程提供的这个 <code>actor</code> API 也不过就是提供了一个 <code>SendChannel</code> 的返回值而已。当然，协程的负责人也有实现一套更复杂的 Actor 的想法，只是这一段时间的高优明显是 <code>Flow</code>——这货从协程框架的 v1.2 开始公测，到协程 v1.3 就稳定，真是神速，我们后面的文章会介绍它。</p><p>虽然 <code>produce</code> 没有被标记为 <code>ObsoleteCoroutinesApi</code>，显然它作为 <code>actor</code> 的另一半，不可能单独转正的，这俩 API 我的建议是看看就好了。</p><h2 id="5-Channel-的关闭"><a href="#5-Channel-的关闭" class="headerlink" title="5. Channel 的关闭"></a>5. Channel 的关闭</h2><p>前我们提到了 <code>produce</code> 和 <code>actor</code> 返回的 <code>Channel</code> 都会伴随着对应的协程执行完毕而关闭。哦，原来 <code>Channel</code> 还有一个关闭的概念。</p><p><code>Channel</code> 和我们后面的文章即将要探讨的 <code>Flow</code> 不同，它是在线的，是一个热数据源，换句话说就是有想要收数据，就要有人在对面给他发，就像发微信一样。既然这样，就难免曲终人散，对于一个 <code>Channel</code>，如果我们调用了它的 <code>close</code>，它会立即停止接受新元素，也就是说这时候它的 <code>isClosedForSend</code> 会立即返回 <code>true</code>，而由于 <code>Channel</code> 缓冲区的存在，这时候可能还有一些元素没有被处理完，所以要等所有的元素都被读取之后 <code>isClosedForReceive</code> 才会返回 <code>true</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    List(<span class="number">5</span>)&#123;</span><br><span class="line">        channel.send(it)</span><br><span class="line">        Logger.debug(<span class="string">"send <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">    Logger.debug(<span class="string">"close channel. ClosedForSend = <span class="subst">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class="subst">$&#123;channel.isClosedForReceive&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> channel) &#123;</span><br><span class="line">        Logger.debug(<span class="string">"receive: <span class="variable">$element</span>"</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Logger.debug(<span class="string">"After Consuming. ClosedForSend = <span class="subst">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class="subst">$&#123;channel.isClosedForReceive&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把例子稍作修改，开了一个缓冲区大小为 3 的 <code>Channel</code>，在 producer 协程里面快速的发送元素出去，发送5个之后关闭 <code>Channel</code>，而在 consumer 协程当中每秒读取一个， 结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 0</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-3]  receive: 0</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 1</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 2</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 3</span><br><span class="line">11:05:21:688 [DefaultDispatcher-worker-3]  receive: 1</span><br><span class="line">11:05:21:688 [DefaultDispatcher-worker-3]  send 4</span><br><span class="line">11:05:21:689 [DefaultDispatcher-worker-3]  close channel. ClosedForSend =true ClosedForReceive = false</span><br><span class="line">11:05:22:693 [DefaultDispatcher-worker-3]  receive: 2</span><br><span class="line">11:05:23:694 [DefaultDispatcher-worker-4]  receive: 3</span><br><span class="line">11:05:24:698 [DefaultDispatcher-worker-4]  receive: 4</span><br><span class="line">11:05:25:700 [DefaultDispatcher-worker-4]  After Consuming. ClosedForSend =true ClosedForReceive = true</span><br></pre></td></tr></table></figure><p>下面我们来探讨下 <code>Channel</code> 关闭的意义。</p><p>一说起关闭，我们就容易想到 IO，如果不关闭可能造成资源泄露，那么 <code>Channel</code> 的关闭是个什么概念呢？我们前面提到过，<code>Channel</code> 其实内部的资源就是个缓冲区，这个东西本质上就是个线性表，就是一块儿内存，所以如果我们开了一个 <code>Channel</code> 而不去关闭它，其实也不会造成什么资源泄露，发端如果自己已经发完，它就可以不理会这个 <code>Channel</code> 了。嗯，看上去好像没什么问题是吧？</p><p>But，这时候在接收端就比较尴尬了，它不知道会不会有数据发过来，如果 <code>Channel</code> 是微信，那么接收端打开微信的窗口可能一直看到的是『对方正在输入』，然后它就一直这样了，孤独终老。所以这里的关闭更多像是一种约定：</p><blockquote><p>女：咱俩没戏，你别傻等了。<br>男：哦。（您的消息未发送成功）</p></blockquote><p>那么 <code>Channel</code> 的关闭究竟应该有谁来处理呢？正常的通信，如果是单向的，就好比领导讲话，讲完都会说『我讲完了』，你不能在领导还没讲完的时候就说『我听完了』，所以单向通信的情况比较推荐由发端处理关闭；而对于双向通信的情况，就要考虑协商了，双向通信从技术上两端是对等的，但业务场景下通常来说不是，建议由主导的一方处理关闭。</p><p>还有一些复杂的情况，前面我们看到的例子都是一对一的收发，其实还有一对多，多对多的情况，这种也仍然存在主导一方，<code>Channel</code> 的生命周期最好由主导方来维护。官方文档给出的扇入(fan-in)和扇出(fan-out)，其实就是这种情况。</p><blockquote><p>扇入和扇出的概念可能大家不是很熟悉，网上的说法不是很通俗，大家就想象它是一把折扇，折扇的边射向圆心就是扇入，这种情况圆心如果是通信的一端，那它就是接收方，如果是一个函数，那它就是被调用方。扇入越大，说明模块的复用程度越高，以函数为例，如果一个函数被调用的次数越多，那说明复用的程度越高。扇出就是反过来的情况，描述的是复杂度高的情形，例如一个 Model，负责调用网络模块、数据库、文件等很多模块。</p></blockquote><h2 id="6-BroadcastChannel"><a href="#6-BroadcastChannel" class="headerlink" title="6. BroadcastChannel"></a>6. BroadcastChannel</h2><p>前面提到了一对多的情形，从数据处理的本身来讲，虽然有多个接收端，同一个元素只会被一个接收端读到。广播则不然，多个接收端不存在互斥行为。</p><p>直接创建 <code>broadcastChannel</code> 的方法跟普通的 <code>Channel</code> 似乎也没什么太多的不一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> broadcastChannel = broadcastChannel&lt;<span class="built_in">Int</span>&gt;(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>如果要订阅，那么只需要调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> receiveChannel = broadcastChannel.openSubscription()</span><br></pre></td></tr></table></figure><p>这样我们就得到了一个 <code>ReceiveChannel</code>，获取订阅的消息，只需要调用它的 <code>receive</code>。</p><p>我们看一个完整一点儿的例子，例子中我们在发端发送 1 - 5，并启动 3 个协程同时接收广播：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    List(<span class="number">5</span>) &#123;</span><br><span class="line">        broadcastChannel.send(it)</span><br><span class="line">        Logger.debug(<span class="string">"send <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">List(<span class="number">3</span>) &#123; index -&gt;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> receiveChannel = broadcast.openSubscription()</span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> receiveChannel) &#123;</span><br><span class="line">            Logger.debug(<span class="string">"[<span class="variable">$index</span>] receive: <span class="variable">$element</span>"</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.forEach &#123; it.join() &#125;</span><br><span class="line">    </span><br><span class="line">producer.join()</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">12:34:59:656 [DefaultDispatcher-worker-6]  [2] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-3]  [1] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-5]  [0] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-7]  send 0</span><br><span class="line">12:34:59:657 [DefaultDispatcher-worker-7]  send 1</span><br><span class="line">12:34:59:658 [DefaultDispatcher-worker-7]  send 2</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-3]  [0] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-5]  [1] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-6]  [2] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-8]  send 3</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-8]  [0] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-3]  [1] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-6]  [2] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-8]  send 4</span><br><span class="line">12:35:02:674 [DefaultDispatcher-worker-8]  [0] receive: 3</span><br><span class="line">12:35:02:674 [DefaultDispatcher-worker-7]  [1] receive: 3</span><br><span class="line">12:35:02:675 [DefaultDispatcher-worker-3]  [2] receive: 3</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-8]  [1] receive: 4</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-3]  [0] receive: 4</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-1]  [2] receive: 4</span><br></pre></td></tr></table></figure><p>这里请大家重点关注每一个收端协程都可以读取到每一个元素。</p><blockquote><p>日志顺序不能非常直观的反映数据的读写顺序，如果大家自己再次运行，顺序上可能也有出入。</p></blockquote><p>除了直接创建以外，我们也可以直接用前面定义的普通的 <code>Channel</code> 来做个转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> broadcast = channel.broadcast(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>其中，参数表示缓冲区的大小。</p><p>实际上这里得到的这个 <code>broadcastChannel</code> 可以认为与原 <code>Channel</code> 是级联关系，这个扩展方法的源码其实很清晰的为我们展示了这一点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> ReceiveChannel<span class="type">&lt;E&gt;</span>.<span class="title">broadcast</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    capacity: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.LAZY</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: broadcastChannel&lt;E&gt; =</span><br><span class="line">    GlobalScope.broadcast(Dispatchers.Unconfined, capacity = capacity, start = start, onCompletion = consumes()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (e <span class="keyword">in</span> <span class="keyword">this</span><span class="symbol">@broadcast</span>) &#123;  <span class="comment">//这实际上就是在读取原 Channel</span></span><br><span class="line">            send(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>哦~原来对于 <code>BroadcastChannel</code>，官方也提供类似于 <code>produce</code> 和 <code>actor</code> 的方式，我们可以通过 <code>CoroutineScope.broadcast</code> 来直接启动一个协程，并返回一个 <code>BroadcastChannel</code>。</p><p>需要注意的是，从原始的 <code>Channel</code> 转换到 <code>BroadcastChannel</code> 其实就是对原 <code>Channel</code> 的一个读取操作，如果还有其他协程也在读这个原始的 <code>Channel</code>，那么会与 <code>BroadcastChannel</code> 产生互斥关系。</p><p>另外，<code>BroadcastChannel</code> 相关的 API 大部分被标记为 <code>ExperimentalCoroutinesApi</code>，后续也许还会有调整。</p><h2 id="7-Channel-版本的序列生成器"><a href="#7-Channel-版本的序列生成器" class="headerlink" title="7. Channel 版本的序列生成器"></a>7. Channel 版本的序列生成器</h2><p>前面的文章我们讲到过 <code>Sequence</code>，它的生成器是基于标准库的协程的 API 实现的，实际上 <code>Channel</code> 本身也可以用来生成序列，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class="line">    Logger.debug(<span class="string">"A"</span>)</span><br><span class="line">    send(<span class="number">1</span>)</span><br><span class="line">    Logger.debug(<span class="string">"B"</span>)</span><br><span class="line">    send(<span class="number">2</span>)</span><br><span class="line">    Logger.debug(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> channel) &#123;</span><br><span class="line">    Logger.debug(<span class="string">"Got <span class="variable">$item</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了前面的基础这个就很容易看懂了，<code>produce</code> 创建的协程返回了一个缓冲区大小为 0 的 <code>Channel</code>，为了问题描述起来比较容易，我们传入了一个 <code>Dispatchers.Unconfined</code> 调度器，意味着协程会立即在当前协程执行到第一个挂起点，所以会立即输出 <code>A</code> 并在 <code>send(1)</code> 处挂起，直到后面的 for 循环读到第一个值时，实际上就是 <code>channel</code> 的 <code>iterator</code> 的 <code>hasNext</code> 方法的调用，这个 <code>hasNext</code> 方法会检查是否有下一个元素，是一个挂起函数，在检查的过程中就会让前面启动的协程从 <code>send(1)</code> 挂起的位置继续执行，因此会看到日志 <code>B</code> 输出，然后再挂起到 <code>send(2)</code> 这里，这时候 <code>hasNext</code> 结束挂起，for 循环终于输出第一个元素，依次类推。输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">22:33:56:073 [main @coroutine#1]  A</span><br><span class="line">22:33:56:172 [main @coroutine#1]  B</span><br><span class="line">22:33:56:173 [main]  Got 1</span><br><span class="line">22:33:56:173 [main @coroutine#1]  Done</span><br><span class="line">22:33:56:176 [main]  Got 2</span><br></pre></td></tr></table></figure><p>我们看到 <code>B</code> 居然比 <code>Got 1</code> 先输出，同样，<code>Done</code> 也比 <code>Got 2</code> 先输出，这个看上去比较不符合直觉，不过挂起恢复的执行顺序确实如此，关键点就是我们前面提到的 <code>hasNext</code> 方法会挂起并触发了协程内部从挂起点继续执行的操作。如果你选择了其他调度器，当然也会有其他合理的结果输出。不管怎么样，我们体验了一把用 <code>Channel</code> 模拟 <code>sequence</code>。如果类似的代码换作 <code>sequence</code>，是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sequence = sequence &#123;</span><br><span class="line">    Logger.debug(<span class="string">"A"</span>)</span><br><span class="line">    yield(<span class="number">1</span>)</span><br><span class="line">    Logger.debug(<span class="string">"B"</span>)</span><br><span class="line">    yield(<span class="number">2</span>)</span><br><span class="line">    Logger.debug(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger.debug(<span class="string">"before sequence"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> sequence) &#123;</span><br><span class="line">    Logger.debug(<span class="string">"Got <span class="variable">$item</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sequence</code> 的执行顺序要直观的多，它没有调度器的概念，而且 <code>sequence</code> 的 <code>iterator</code> 的 <code>hasNext</code> 和 <code>next</code> 都不是挂起函数，在 <code>hasNext</code> 的时候同样会触发元素的查找，这时候就会触发 <code>sequence</code> 内部逻辑的执行，因此这次实际上是先触发了 <code>hasNext</code> 才会输出 A，<code>yield</code> 把 1 传出来作为 <code>sequence</code> 的第一个元素，这样就会有 Got 1 这样的输出，完整输出如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">600</span> [main]  A</span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">603</span> [main]  Got <span class="number">1</span></span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  B</span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  Got <span class="number">2</span></span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  Done</span><br></pre></td></tr></table></figure><p><code>sequence</code> 本质上就是基于标准库的协程 API 实现的，没有上层协程框架的作用域以及 Job 这样的概念。</p><p>所以我们可以在 <code>Channel</code> 的例子里面切换不同的调度器来生成元素，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class="line">    Logger.debug(<span class="number">1</span>)</span><br><span class="line">    send(<span class="number">1</span>)</span><br><span class="line">    withContext(Dispatchers.IO)&#123;</span><br><span class="line">        Logger.debug(<span class="number">2</span>)</span><br><span class="line">        send(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Logger.debug(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sequence 就不行了。</p><p>当然，单纯的用 <code>Channel</code> 当做序列生成器来使用有点儿小题大做，这里更多的是告诉大家存在这样的可能性，大家在将来遇到合适的场景时，就可以灵活运用了。</p><h2 id="8-Channel-的内部结构"><a href="#8-Channel-的内部结构" class="headerlink" title="8. Channel 的内部结构"></a>8. Channel 的内部结构</h2><p>前面我们提到 <code>sequence</code> 无法享受更上层的协程框架概念下的各种能力，还有一点 <code>sequence</code> 显然不是线程安全的，而 <code>Channel</code> 可以在并发场景下使用。</p><p><code>Channel</code> 内部结构我们主要说下缓冲区分别是链表和数组的版本。链表版本的定义主要是在 <code>AbstractSendChannel</code> 当中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSendChannel</span>&lt;<span class="type">E</span>&gt; : <span class="type">SendChannel</span>&lt;<span class="type">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> queue = LockFreeLinkedListHead()</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LockFreeLinkedListHead</code> 本身其实就是一个双向链表的节点，实际上 <code>Channel</code> 把它首尾相连成为了循环链表，而这个 <code>queque</code> 就是哨兵(sentinel)节点。有新的元素添加时，就在 <code>queue</code> 的前面插入，实际上就相当于在整个队列的最后插入元素了。</p><p>它所谓的 <code>LockFree</code> 在 Java 虚拟机上其实是通过原子读写来实现的， 对于链表来说，需要修改的无非就是前后节点的引用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeLinkedListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _next = atomic&lt;Any&gt;(<span class="keyword">this</span>) <span class="comment">// Node | Removed | OpDescriptor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _prev = atomic&lt;Any&gt;(<span class="keyword">this</span>) <span class="comment">// Node | Removed</span></span><br><span class="line">    ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现基于一篇论文中提到的无锁链表的实现，由于 CAS 原子操作通常只能修改一个引用，对于需要原子同时修改前后节点引用的情形是不适用的，例如单链表插入节点时需要修改两个引用，分别是操作节点的前一个节点的 next 和自己的 next，即 Head -&gt; A -&gt; B -&gt; C 在 A 、B 之间插件 X 时会需要先修改 X -&gt; B 再修改 A -&gt; X，如果这个过程中 A 被删除，那么可能的结果是 X 一并被删除，得到的链表是 Head -&gt; B -&gt; C。</p><p>这个无锁链表的实现通过引入 prev 来辅助解决这个问题，即在 A 被删除的问题发生的同时，其实我们是可以做到 X.next = B，X.prev = A 的，这时候判断如果 A 已经被移除了，那么 B.prev 本来是 A，结果就变成了 Head，这时候就可以将 X.prev 再次赋值为 B.prev 来修复，当然这个过程稍稍有些复杂，有兴趣的同学也可以参考 <code>LockFreeLinkedListNode</code> 在 Jvm 上的实现。</p><p>而对于数组版本，<code>ArrayChannel</code> 就相对粗暴了，内部就是一个数组：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓冲区大小大于 8，会先分配大小为 8 的数组，在后续进行扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> buffer: Array&lt;Any?&gt; = arrayOfNulls&lt;Any?&gt;(min(capacity, <span class="number">8</span>))</span><br></pre></td></tr></table></figure><p>对这个数组读写时则直接用了一个 <code>ReentrantLock</code> 进行加锁。</p><p>这里是不是有优化的空间呢？其实对于数组的元素，我们同样可以进行 CAS 读写，如果大家有兴趣，可以参考下 <code>ConcurrentHashMap</code> 的实现，JDK 7 的实现中对于段数组的读写采用了 <code>UnSafe</code> 的 CAS 读写，JDK 1.8 直接干掉了分段，对于桶的读写也采用了 <code>UnSafe</code> 的 CAS。</p><blockquote><p>协程在 Js 和 Native 上的实现就要简单得多，因为它们的协程都只是在单线程上运行，基本不需要处理并发问题。</p></blockquote><h2 id="9-小结"><a href="#9-小结" class="headerlink" title="9. 小结"></a>9. 小结</h2><p><code>Channel</code> 的出现，应该说为协程注入了灵魂。每一个独立的协程不再是孤独的个体，<code>Channel</code> 可以让他们更加方便的协作起来。实际上 <code>Channel</code> 的概念并不是 Kotlin 原创的，且不说 Golang 里面的 <code>channel</code>，就说 Java NIO 当中也存在 <code>Channel</code> 这样的概念，其实这时候大家很容易就应该想到多路复用，多路复用的时候我们还能像前面那样简单的挂起吗？或者不挂起我们该怎么办呢？且看下回分解。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的朋友，慕课网会在12月收到课程原价等值的定向代金券，可用于补差价升级到新课，由于现在新课限时优惠，因此只需要 77 元即可升级到新课。新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有600+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;code&gt;Channel&lt;/code&gt; 实际上就是协程在生产消费者模型上的应用，把过去你用 &lt;code&gt;BlockingQueue&lt;/code&gt; 实现的功能替换成 &lt;code&gt;Channel&lt;/code&gt;，也许会有新的发现~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(8) - Android 篇</title>
    <link href="https://www.bennyhuo.com/2019/05/27/coroutine-android/"/>
    <id>https://www.bennyhuo.com/2019/05/27/coroutine-android/</id>
    <published>2019-05-26T16:00:00.000Z</published>
    <updated>2019-12-01T14:58:41.208Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~</p></blockquote><a id="more"></a><p>本文涉及的 MainScope 以及 AutoDispose 源码：<a href="https://github.com/enbandari/kotlin-coroutines-android" target="_blank" rel="noopener">kotlin-coroutines-android</a></p><h2 id="1-配置依赖"><a href="#1-配置依赖" class="headerlink" title="1. 配置依赖"></a>1. 配置依赖</h2><p>我们曾经提到过，如果在 Android 上做开发，那么我们需要引入</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutine_version'</span></span><br><span class="line">```  </span><br><span class="line">这个框架里面包含了 Android 专属的 `Dispatcher`，我们可以通过 `Dispatchers.Main` 来拿到这个实例；也包含了 `MainScope`，用于与 Android 作用域相结合。</span><br><span class="line"></span><br><span class="line">Anko 也提供了一些比较方便的方法，例如 `onClick` 等等，如果需要，也可以引入它的依赖：</span><br><span class="line"></span><br><span class="line">```gradle</span><br><span class="line"><span class="comment">//提供 onClick 类似的便捷的 listener，接收 suspend Lambda 表达式</span></span><br><span class="line">implementation <span class="string">"org.jetbrains.anko:anko-sdk27-coroutines:$anko_version"</span></span><br><span class="line"><span class="comment">//提供 bg 、asReference，尚未没有跟进 kotlin 1.3 的正式版协程，不过代码比较简单，如果需要可以自己改造</span></span><br><span class="line">implementation <span class="string">"org.jetbrains.anko:anko-coroutines:$anko_version"</span></span><br></pre></td></tr></table></figure><p>简单来说：</p><ul><li>kotlinx-coroutines-android 这个框架是必选项，主要提供了专属调度器</li><li>anko-sdk27-coroutines 是可选项，提供了一些 UI 组件更为简洁的扩展，例如 onClick，但它也有自己的问题，我们后面详细探讨</li><li>anko-coroutines 仅供参考，现阶段（2019.4）由于尚未跟进 1.3 正式版协程，因此在 1.3 之后的版本中尽量不要使用，提供的两个方法都比较简单，如果需要，可自行改造使用。</li></ul><p>协程的原理和用法我们已经探讨了很多了，关于 Android 上面的协程使用，我们就只给出几点实践的建议。</p><h2 id="2-UI-生命周期作用域"><a href="#2-UI-生命周期作用域" class="headerlink" title="2. UI 生命周期作用域"></a>2. UI 生命周期作用域</h2><p>Android 开发经常想到的一点就是让发出去的请求能够在当前 UI 或者 Activity 退出或者销毁的时候能够自动取消，我们在用 RxJava 的时候也有过各种各样的方案来解决这个问题。</p><h3 id="2-1-使用-MainScope"><a href="#2-1-使用-MainScope" class="headerlink" title="2.1 使用 MainScope"></a>2.1 使用 MainScope</h3><p>协程有一个很天然的特性能刚够支持这一点，那就是作用域。官方也提供了 <code>MainScope</code> 这个函数，我们具体看下它的使用方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line">launchButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        textView.text = async(Dispatchers.IO) &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">3</span>)</span><br><span class="line">            <span class="string">"Hello1111"</span></span><br><span class="line">        &#125;.await()</span><br><span class="line">        log(<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现它其实与其他的 <code>CoroutineScope</code> 用起来没什么不一样的地方，通过同一个叫 <code>mainScope</code> 的实例启动的协程，都会遵循它的作用域定义，那么 <code>MainScope</code> 的定义时怎样的呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">MainScope</span><span class="params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)</span><br></pre></td></tr></table></figure><p>原来就是 <code>SupervisorJob</code> 整合了 <code>Dispatchers.Main</code> 而已，它的异常传播是自上而下的，这一点与 <code>supervisorScope</code> 的行为一致，此外，作用域内的调度是基于 Android 主线程的调度器的，因此作用域内除非明确声明调度器，协程体都调度在主线程执行。因此上述示例的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-04-29 06:51:00.657 D: [main] 1</span><br><span class="line">2019-04-29 06:51:00.659 D: [DefaultDispatcher-worker-1] 2</span><br><span class="line">2019-04-29 06:51:01.662 D: [DefaultDispatcher-worker-2] 3</span><br><span class="line">2019-04-29 06:51:01.664 D: [main] 4</span><br></pre></td></tr></table></figure><p>如果我们在触发前面的操作之后立即在其他位置触发作用域的取消，那么该作用域内的协程将不再继续执行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line"></span><br><span class="line">launchButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cancelButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.cancel()</span><br><span class="line">    log(<span class="string">"MainScope is cancelled."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们快速依次点击上面的两个按钮，结果就显而易见了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-04-29 07:12:20.625 D: [main] 1</span><br><span class="line">2019-04-29 07:12:20.629 D: [DefaultDispatcher-worker-2] 2</span><br><span class="line">2019-04-29 07:12:21.046 D: [main] MainScope is cancelled.</span><br></pre></td></tr></table></figure><h3 id="2-2-构造带有作用域的抽象-Activity"><a href="#2-2-构造带有作用域的抽象-Activity" class="headerlink" title="2.2 构造带有作用域的抽象 Activity"></a>2.2 构造带有作用域的抽象 Activity</h3><p>尽管我们前面体验了 <code>MainScope</code> 发现它可以很方便的控制所有它范围内的协程的取消，以及能够无缝将异步任务切回主线程，这都是我们想要的特性，不过写法上还是不够美观。</p><p>官方推荐我们定义一个抽象的 <code>Activity</code>，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopedActivity</span>: <span class="type">Activity</span></span>(), CoroutineScope <span class="keyword">by</span> MainScope()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在 <code>Activity</code> 退出的时候，对应的作用域就会被取消，所有在该 <code>Activity</code> 中发起的请求都会被取消掉。使用时，只需要继承这个抽象类即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineActivity</span> : <span class="type">ScopedActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_coroutine)</span><br><span class="line">        launchButton.setOnClickListener &#123;</span><br><span class="line">            launch &#123; <span class="comment">// 直接调用 ScopedActivity 也就是 MainScope 的方法</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">anotherOps</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了在当前 <code>Activity</code> 内部获得 <code>MainScope</code> 的能力外，还可以将这个 Scope 实例传递给其他需要的模块，例如 <code>Presenter</code> 通常也需要与 <code>Activity</code> 保持同样的生命周期，因此必要时也可以将该作用域传递过去：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutinePresenter</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> scope: CoroutineScope): CoroutineScope <span class="keyword">by</span> scope&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        launch &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多数情况下，<code>Presenter</code> 的方法也会被 <code>Activity</code> 直接调用，因此也可以将 <code>Presenter</code> 的方法生命成 <code>suspend</code> 方法，然后用 <code>coroutineScope</code> 嵌套作用域，这样 <code>MainScope</code> 被取消后，嵌套的子作用域一样也会被取消，进而达到取消全部子协程的目的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutinePresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">        launch &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-更友好地为-Activity-提供作用域"><a href="#2-3-更友好地为-Activity-提供作用域" class="headerlink" title="2.3 更友好地为 Activity 提供作用域"></a>2.3 更友好地为 Activity 提供作用域</h3><p>抽象类很多时候会打破我们的继承体系，这对于开发体验的伤害还是很大的，因此我们是不是可以考虑构造一个接口，只要 <code>Activity</code> 实现这个接口就可以拥有作用域以及自动取消的能力呢？</p><p>首先我们定义一个接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ScopedActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> scope: CoroutineScope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个朴实的愿望就是希望实现这个接口就可以自动获得作用域，不过问题来了，这个 <code>scope</code> 成员要怎么实现呢？留给接口实现方的话显然不是很理想，自己实现吧，又碍于自己是个接口，因此我们只能这样处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> scopeMap = IdentityHashMap&lt;MainScoped, MainScope&gt;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> mainScope: CoroutineScope</span><br><span class="line">        <span class="keyword">get</span>() = scopeMap[<span class="keyword">this</span> <span class="keyword">as</span> Activity]!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的事情就是在合适的实际去创建和取消对应的作用域了，我们接着定义两个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createScope</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//或者改为 lazy 实现，即用到时再创建</span></span><br><span class="line">        <span class="keyword">val</span> activity = <span class="keyword">this</span> <span class="keyword">as</span> Activity</span><br><span class="line">        scopeMap[activity] ?: MainScope().also &#123; scopeMap[activity] = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroyScope</span><span class="params">()</span></span>&#123;</span><br><span class="line">        scopeMap.remove(<span class="keyword">this</span> <span class="keyword">as</span> Activity)?.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们需要 <code>Activity</code> 去实现这个接口，因此直接强转即可，当然如果考虑健壮性，可以做一些异常处理，这里作为示例仅提供核心实现。</p><p>接下来就是考虑在哪儿完成创建和取消呢？显然这件事儿用 <code>Application.ActivityLifecycleCallbacks</code> 最合适不过了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityLifecycleCallbackImpl</span>: <span class="type">Application.ActivityLifecycleCallbacks &#123;</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(activity: <span class="type">Activity</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        (activity <span class="keyword">as</span>? MainScoped)?.createScope()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        (activity <span class="keyword">as</span>? MainScoped)?.destroyScope()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是在 <code>Application</code> 里面注册一下这个监听了，这个大家都会，我就不给出代码了。</p><p>我们看下如何使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineActivity</span> : <span class="type">Activity</span></span>(), MainScoped &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        launchButton.setOnClickListener &#123;            </span><br><span class="line">            scope.launch &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以增加一些有用的方法来简化这个操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">withScope</span><span class="params">(block: <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>)</span></span> = with(scope, block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在 <code>Activity</code> 当中还可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">withScope &#123;</span><br><span class="line">    launch &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，示例当中用到了 <code>IdentityHashMap</code>，这表明对于 scope 的读写是非线程安全的，因此不要在其他线程试图去获取它的值，除非你引入第三方或者自己实现一个 <code>IdentityConcurrentHashMap</code>，即便如此，从设计上 <code>scope</code> 也不太应该在其他线程访问。</p></blockquote><p>按照这个思路，我提供了一套更加完善的方案，不仅支持 <code>Activity</code> 还支持 support-fragment 版本在 25.1.0 以上的版本的 <code>Fragment</code>，并且类似于 Anko 提供了一些有用的基于 <code>MainScope</code> 的 listener 扩展，引入这个框架即可使用：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api <span class="string">'com.bennyhuo.kotlin:coroutines-android-mainscope:1.0'</span></span><br></pre></td></tr></table></figure><h2 id="3-谨慎使用-GlobalScope"><a href="#3-谨慎使用-GlobalScope" class="headerlink" title="3. 谨慎使用 GlobalScope"></a>3. 谨慎使用 GlobalScope</h2><h3 id="3-1-GlobalScope-存在什么问题"><a href="#3-1-GlobalScope-存在什么问题" class="headerlink" title="3.1 GlobalScope 存在什么问题"></a>3.1 GlobalScope 存在什么问题</h3><p>我们之前做例子经常使用 <code>GlobalScope</code>，但 <code>GlobalScope</code> 不会继承外部作用域，因此大家使用时一定要注意，如果在使用了绑定生命周期的 <code>MainScope</code> 之后，内部再使用 <code>GlobalScope</code> 启动协程，意味着 <code>MainScope</code> 就不会起到应有的作用。</p><p>这里需要小心的是如果使用了一些没有依赖作用域的构造器，那么一定要小心。例如 Anko 当中的 <code>onClick</code> 扩展：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClick</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许我们也就是图个方便，毕竟 <code>onClick</code> 写起来可比 <code>setOnClickListener</code> 要少很多字符，同时名称上看也更加有事件机制的味道，但隐藏的风险就是通过 <code>onClick</code> 启动的协程并不会随着 <code>Activity</code> 的销毁而被取消，其中的风险需要自己思考清楚。</p><p>当然，Anko 会这么做的根本原因在于 <code>OnClickListener</code> 根本拿不到有生命周期加持的作用域。不用 <code>GlobalScope</code> 就无法启动协程，怎么办？结合我们前面给出的例子，其实这个事儿完全有别的解法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> View.<span class="title">onClickSuspend</span><span class="params">(handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        setOnClickListener &#123; v -&gt;</span><br><span class="line">            scope.launch &#123;   handler(v)   &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在前面定义的 <code>MainScoped</code> 接口中，可以通过 <code>scope</code> 拿到有生命周期加持的 <code>MainScope</code> 实例，那么直接用它启动协程来运行 <code>OnClickListener</code> 问题不就解决了嘛。所以这里的关键点在于如何拿到作用域。</p><p>这样的 listener 我已经为大家在框架中定义好啦，请参见 2.3。</p><h3 id="3-2-协程版-AutoDisposable"><a href="#3-2-协程版-AutoDisposable" class="headerlink" title="3.2 协程版 AutoDisposable"></a>3.2 协程版 AutoDisposable</h3><p>当然除了直接使用一个合适的作用域来启动协程之外，我们还有别的办法来确保协程及时被取消。</p><p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p><p>因此大家一定会用到 Uber 的开源框架 <a href="https://github.com/uber/AutoDispose" target="_blank" rel="noopener">AutoDispose</a>。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">extends</span> <span class="title">MainThreadDisposable</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnAttachStateChangeListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View view;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CompletableObserver observer;</span><br><span class="line"></span><br><span class="line">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.view = view;</span><br><span class="line">    <span class="keyword">this</span>.observer = observer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">    <span class="comment">//看到没看到没看到没？</span></span><br><span class="line">      observer.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    view.removeOnAttachStateChangeListener(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到前面提到的 Anko 扩展 <code>onClick</code> 无法取消协程的问题，我们也可以搞一个 <code>onClickAutoDisposable</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClickAutoDisposable</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;.asAutoDisposable(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 <code>launch</code> 会启动一个 <code>Job</code>，因此我们可以通过 <code>asAutoDisposable</code> 来将其转换成支持自动取消的类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Job.<span class="title">asAutoDisposable</span><span class="params">(view: <span class="type">View</span>)</span></span> = AutoDisposableJob(view, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>那么 <code>AutoDisposableJob</code> 的实现只要参考 AutoDisposable 的实现依样画葫芦就好了 ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoDisposableJob</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View, <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Job)</span><br><span class="line">    <span class="comment">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class="line">     : Job <span class="keyword">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> = <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//当 View 被移除的时候，取消协程</span></span><br><span class="line">        cancel()</span><br><span class="line">        view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isViewAttached</span><span class="params">()</span></span> =</span><br><span class="line">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isViewAttached()) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class="line">        invokeOnCompletion() &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就可以使用这个扩展了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.onClickAutoDisposable&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令，尽管这种情况下协程的执行不会跟随 <code>Activity</code> 的 <code>onDestroy</code> 而取消，但它与 <code>View</code> 的点击事件紧密结合，即便 <code>Activity</code> 没有被销毁，<code>View</code> 本身被移除时也会直接将监听中的协程取消掉。</p><p>如果大家想要用这个扩展，我已经帮大家放到 jcenter 啦，直接使用：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api <span class="string">"com.bennyhuo.kotlin:coroutines-android-autodisposable:1.0"</span></span><br></pre></td></tr></table></figure><p>添加到依赖当中即可使用。</p><h2 id="4-合理使用调度器"><a href="#4-合理使用调度器" class="headerlink" title="4. 合理使用调度器"></a>4. 合理使用调度器</h2><p>在 Android 上使用协程，更多的就是简化异步逻辑的写法，使用场景更多与 RxJava 类似。在使用 RxJava 的时候，我就发现有不少开发者仅仅用到了它的切线程的功能，而且由于本身 RxJava 切线程 API 简单易用，还会造成很多无脑线程切换的操作，这样实际上是不好的。那么使用协程就更要注意这个问题了，因为协程切换线程的方式被 RxJava 更简洁，更透明，本来这是好事情，就怕被滥用。</p><p>比较推荐的写法是，绝大多数 UI 逻辑在 UI 线程中处理，即使在 UI 中用 <code>Dispatchers.Main</code> 来启动协程，如果涉及到一些 io 操作，使用 <code>async</code> 将其调度到 <code>Dispatchers.IO</code> 上，结果返回时协程会帮我们切回到主线程——这非常类似 Nodejs 这样的单线程的工作模式。</p><p>对于一些 UI 不相关的逻辑，例如批量离线数据下载任务，通常默认的调度器就足够使用了。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>这一篇文章，主要是基于我们前面讲了的理论知识，进一步往 Android 的具体实战角度迁移，相比其他类型的应用，Android 作为 UI 程序最大的特点就是异步要协调好 UI 的生命周期，协程也不例外。一旦我们把协程的作用域规则以及协程与 UI 生命周期的关系熟稔于心，那么相信大家使用协程时一定会得心应手的。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的朋友，慕课网会在12月收到课程原价等值的定向代金券，可用于补差价升级到新课，由于现在新课限时优惠，因此只需要 77 元即可升级到新课。新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有600+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(7) - 序列生成器篇</title>
    <link href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/"/>
    <id>https://www.bennyhuo.com/2019/05/26/coroutine-sequence/</id>
    <published>2019-05-25T16:00:00.000Z</published>
    <updated>2019-12-01T14:58:41.191Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说出来你可能不信，Kotlin 1.1 协程还在吃奶的时候，Sequence 就已经正式推出了，然而，Sequence 生成器的实现居然有协程的功劳。</p></blockquote><a id="more"></a><h2 id="1-认识-Sequence"><a href="#1-认识-Sequence" class="headerlink" title="1. 认识 Sequence"></a>1. 认识 Sequence</h2><p>在 Kotlin 当中，Sequence 这个概念确切的说是“懒序列”，产生懒序列的方式可以有多种，下面我们介绍一种由基于协程实现的序列生成器。需要注意的是，这个功能内置于 Kotlin 标准库当中，不需要额外添加依赖。</p><p>下面我们给出一个斐波那契数列生成的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">val</span> fibonacci = sequence &#123;</span><br><span class="line">    yield(<span class="number">1L</span>) <span class="comment">// first Fibonacci number</span></span><br><span class="line">    <span class="keyword">var</span> cur = <span class="number">1L</span></span><br><span class="line">    <span class="keyword">var</span> next = <span class="number">1L</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        yield(next) <span class="comment">// next Fibonacci number</span></span><br><span class="line">        <span class="keyword">val</span> tmp = cur + next</span><br><span class="line">        cur = next</span><br><span class="line">        next = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fibonacci.take(<span class="number">5</span>).forEach(::log)</span><br></pre></td></tr></table></figure><p>这个 <code>sequence</code> 实际上也是启动了一个协程，<code>yield</code> 则是一个挂起点，每次调用时先将参数保存起来作为生成的序列迭代器的下一个值，之后返回 <code>COROUTINE_SUSPENDED</code>，这样协程就不再继续执行，而是等待下一次 <code>resume</code> 或者 <code>resumeWithException</code> 的调用，而实际上，这下一次的调用就在生成的序列的迭代器的 <code>next()</code> 调用时执行。如此一来，外部在遍历序列时，每次需要读取新值时，协程内部就会执行到下一次 <code>yield</code> 调用。</p><p>程序运行输出的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10:44:34:071 [main] 1</span><br><span class="line">10:44:34:071 [main] 1</span><br><span class="line">10:44:34:071 [main] 2</span><br><span class="line">10:44:34:071 [main] 3</span><br><span class="line">10:44:34:071 [main] 5</span><br></pre></td></tr></table></figure><p>除了使用 <code>yield(T)</code> 生成序列的下一个元素以外，我们还可以用 <code>yieldAll()</code> 来生成多个元素：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> seq = sequence &#123;</span><br><span class="line">    log(<span class="string">"yield 1,2,3"</span>)</span><br><span class="line">    yieldAll(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    log(<span class="string">"yield 4,5,6"</span>)</span><br><span class="line">    yieldAll(listOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">    log(<span class="string">"yield 7,8,9"</span>)</span><br><span class="line">    yieldAll(listOf(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">seq.take(<span class="number">5</span>).forEach(::log)</span><br></pre></td></tr></table></figure><p>从运行结果我们可以看到，在读取 4 的时候才会去执行到 <code>yieldAll(listOf(4, 5, 6))</code>，而由于 7 以后都没有被访问到，<code>yieldAll(listOf(7, 8, 9))</code> 并不会被执行，这就是所谓的“懒”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10:44:34:029 [main] yield 1,2,3</span><br><span class="line">10:44:34:060 [main] 1</span><br><span class="line">10:44:34:060 [main] 2</span><br><span class="line">10:44:34:060 [main] 3</span><br><span class="line">10:44:34:061 [main] yield 4,5,6</span><br><span class="line">10:44:34:061 [main] 4</span><br><span class="line">10:44:34:066 [main] 5</span><br></pre></td></tr></table></figure><h2 id="2-深入序列生成器"><a href="#2-深入序列生成器" class="headerlink" title="2. 深入序列生成器"></a>2. 深入序列生成器</h2><p>前面我们已经不止一次提到 <code>COROUTINE_SUSPENDED</code> 了，我们也很容易就知道 <code>yield</code> 和 <code>yieldAll</code> 都是 suspend 函数，既然能做到”懒“，那么必然在 <code>yield</code> 和 <code>yieldAll</code> 处是挂起的，因此它们的返回值一定是 <code>COROUTINE_SUSPENDED</code>，这一点我们在本文的开头就已经提到，下面我们来见识一下庐山真面目：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    nextValue = value</span><br><span class="line">    state = State_Ready</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c -&gt;</span><br><span class="line">        nextStep = c</span><br><span class="line">        COROUTINE_SUSPENDED</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>yield</code> 的实现，我们看到了老朋友 <code>suspendCoroutineUninterceptedOrReturn</code>，还看到了 <code>COROUTINE_SUSPENDED</code>，那么挂起的问题就很好理解了。而 <code>yieldAll</code> 是如出一辙：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yieldAll</span><span class="params">(iterator: <span class="type">Iterator</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!iterator.hasNext()) <span class="keyword">return</span></span><br><span class="line">    nextIterator = iterator</span><br><span class="line">    state = State_ManyReady</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c -&gt;</span><br><span class="line">        nextStep = c</span><br><span class="line">        COROUTINE_SUSPENDED</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的不同在于 <code>state</code> 的值，一个流转到了 <code>State_Ready</code>，一个是 <code>State_ManyReady</code>，也倒是很好理解嘛。</p><p>那么现在就剩下一个问题了，既然有了挂起，那么什么时候执行 <code>resume</code> ？这个很容易想到，我们在迭代序列的时候呗，也就是序列迭代器的 <code>next()</code> 的时候，那么这事儿就好办了，找下序列的迭代器实现即可，这个类型我们也很容易找到，显然 <code>yield</code> 就是它的方法，我们来看看 <code>next</code> 方法的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">when</span> (state) &#123;</span><br><span class="line">        State_NotReady, State_ManyNotReady -&gt; <span class="keyword">return</span> nextNotReady() <span class="comment">// ①</span></span><br><span class="line">        State_ManyReady -&gt; &#123; <span class="comment">// ②</span></span><br><span class="line">            state = State_ManyNotReady</span><br><span class="line">            <span class="keyword">return</span> nextIterator!!.next()</span><br><span class="line">        &#125;</span><br><span class="line">        State_Ready -&gt; &#123; <span class="comment">// ③</span></span><br><span class="line">            state = State_NotReady</span><br><span class="line">            <span class="keyword">val</span> result = nextValue <span class="keyword">as</span> T</span><br><span class="line">            nextValue = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> exceptionalState()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来依次看下这三个条件：</p><ul><li>① 是下一个元素还没有准备好的情况，调用 <code>nextNotReady</code> 会首先调用 <code>hasNext</code> 检查是否有下一个元素，检查的过程其实就是调用 <code>Continuation.resume</code>，如果有元素，就会再次调用 <code>next</code>，否则就抛异常</li><li>② 表示我们调用了 <code>yieldAll</code>，一下子传入了很多元素，目前还没有读取完，因此需要继续从传入的这个元素集合当中去迭代</li><li>③ 表示我们调用了一次 <code>yield</code>，而这个元素的值就存在 <code>nextValue</code> 当中</li></ul><p><code>hasNext</code> 的实现也不是很复杂：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            State_NotReady -&gt; &#123;&#125; <span class="comment">// ①</span></span><br><span class="line">            State_ManyNotReady -&gt; <span class="comment">// ②</span></span><br><span class="line">                <span class="keyword">if</span> (nextIterator!!.hasNext()) &#123;</span><br><span class="line">                    state = State_ManyReady</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextIterator = <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            State_Done -&gt; <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// ③</span></span><br><span class="line">            State_Ready, State_ManyReady -&gt; <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// ④</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> exceptionalState()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        state = State_Failed</span><br><span class="line">        <span class="keyword">val</span> step = nextStep!!</span><br><span class="line">        nextStep = <span class="literal">null</span></span><br><span class="line">        step.resume(<span class="built_in">Unit</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在通过 <code>next</code> 读取完一个元素之后，如果已经传入的元素已经没有剩余，状态会转为 <code>State_NotReady</code>，下一次取元素的时候就会在 <code>next</code> 中触发到 <code>hasNext</code> 的调用，① 处什么都没有干，因此会直接落到后面的 <code>step.resume()</code>，这样就会继续执行我们序列生成器的代码，直到遇到 <code>yield</code> 或者 <code>yieldAll</code>。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>序列生成器很好的利用了协程的状态机特性，将序列生成的过程从形式上整合到了一起，让程序更加紧凑，表现力更强。本节讨论的序列，某种意义上更像是生产 - 消费者模型中的生产者，而迭代序列的一方则像是消费者，其实在 kotlinx.coroutines 库中提供了更为强大的能力来实现生产 - 消费者模式，我们将在后面的文章当中展示给大家看。</p><p>协程的回调特性可以让我们在实践当中很好的替代传统回调的写法，同时它的状态机特性也可以让曾经的状态机实现获得新的写法，除了序列之外，也许还会有更多有趣的适用场景等待我们去发掘~</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的朋友，慕课网会在12月收到课程原价等值的定向代金券，可用于补差价升级到新课，由于现在新课限时优惠，因此只需要 77 元即可升级到新课。新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有600+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;说出来你可能不信，Kotlin 1.1 协程还在吃奶的时候，Sequence 就已经正式推出了，然而，Sequence 生成器的实现居然有协程的功劳。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何看待 Google 将 Kotlin 作为 Android 开发首选语言？</title>
    <link href="https://www.bennyhuo.com/2019/05/10/google-preferred-kotlin/"/>
    <id>https://www.bennyhuo.com/2019/05/10/google-preferred-kotlin/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-12-01T14:58:41.201Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你觉得天气热不舒服，那一定是享受过凉爽之后才会有的感觉。你没有意识到 Java 的问题，那正说明你应该试试 Kotlin。</p></blockquote><a id="more"></a><p>相比两年前第一次大范围的出现在公众面前，Kotlin 这一次其实有点儿顺其自然了，成为首选是情理之中的事儿，没什么大惊小怪的。</p><p>Kotlin 从 2016.2.19 发了 1.0 以来，基本上一年一个大版本的速度在发展，短短数年时间在行业内立足，并且向全平台推进，雄心可见一斑。不过观察来观察去，以前 Java 服务端的同学也许也开始慢慢尝试，但它的使用者仍然是 Android 开发者为主，这与 Google 的大力推荐有很大的关系，用群里一个小伙伴的说法就是：都是你们这些人闹得，整这么多技术学都学不过来——虽然这话有点儿小牢骚，但至少说明大家最开始都是被逼上梁山的。</p><p>我从16年就在公司项目的线上代码中各种尝试 Kotlin 的特性了，目前我自己基本上除非必须很少写 Java 代码，但这么长时间下来同组其他同学大多并没有表现出对 Kotlin 的热情，为什么？因为 Java 够用啊，能实现我的需求就可以了啊。我本也是想推动一下大家去使用的，但我偏偏又不爱干强人所难的事儿，因为如果我刻意去推大家转 Kotlin，会让 Kotlin 的切入变成是对现状的屈从、充满了来自行业的压迫感，这样会往往让大家忽略掉来自体验语言本身优秀特性的幸福感。所以我觉得没必要让语言的切换变成某种“政治”意义上的东西，它不应该是一种自上而下的做法，而应该是一种自下而上的革命。</p><p>我已经从事了好几年的 Kotlin 布道，Kotlin 对于我而言已经超出了工具的范畴，我会像追星一样关注它的发展，关注 Slack 上面的聊天，关注 GitHub 仓库的提交，这一切都来自曾经的不情愿和后来的“真香”。Kotlin 第一次进入我的视野源自一次 IntelliJ Community 源码的构建，当时看到后缀为 kt 的文件，我就崩溃了，Groovy 和 Scala 我还没学明白，怎么又来一门新语言——相信大家最初的想法都跟我一样，我当年不知道是有多么喜欢 Java——然而逼着自己学了几天 Kotlin 之后，就收到了“真香”警告，网上流传很久的一篇来自 Bugly 公众号的文章 <a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=404087761&amp;idx=1&amp;sn=d80625ee52f860a7a2ed4c238d2151b6" target="_blank" rel="noopener">Android开发必备知识：为什么说Kotlin值得一试</a> 就是之后没过多久我在公司内部发表的一篇文章，后面又被 Bugly 公众号转载了出来。</p><p>Kotlin 究竟有多香呢？</p><p>讲个故事：我大学四年在重庆读书宿舍没有空调，而重庆的夏天有多热呢？据说在石头上打一颗鸡蛋都可以熟，上午下暴雨下午太阳出来半个小时就看不出任何暴雨痕迹，每年夏天总有那么几天不用上课是因为高温。。。十年前校内还是很流行的，一张全城热死的海报被疯狂转载。。。</p><p><strong>解放碑 50° 么，我的天！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15574446261266.jpg" alt></p><p>后来毕业后，终于可以自己装空调了，发现原来夏天还可以这么爽。现在倒好，出门热一会儿我都觉得难受。</p><p>那这跟 Kotlin 有什么关系呢？这就是用 Java 与用 Kotlin 的对比，也许你觉得用 Java 写代码感觉良好，那都是错觉，就好比你从小生活在炎热的天气从来不开空调，就根本不知道开空调有多舒服。</p><p>大家往往在推动别人使用 Kotlin 的时候，只会提到它的开发效率，安全性之类的，其实还要一个更重要的就是，它的很多语法特性与最新的编程思维接轨，你可以只学一门语言就可以领略众多编程方法、思路，所谓窥一斑而知全豹，一门语言让你既可以面向对象，也可以面向函数，既可以线程，也可以协程，既可以 Android 又可以 iOS。开阔眼界，提升思维能力是从码农到可以秀的码农的重要一环。</p><p>说到这里再引用别人的一个观点：当你掌握两门以上外语的时候才能够真正领略到外语的对你思考方式的影响。大意如此吧，说这话的人我估计是要算上英语之外要大家再掌握一门语言的，我不想过分纠结外语的问题，只是想告诉大家，编程语言也是如此。如果你只掌握了一门语言比如 Java，实际上你甚至相当于连一门语言都没有掌握，我在学习 Kotlin 的过程中与 Java 做了大量的对比，这个过程不仅没有让我的 Java 水平受任何负面影响，还实实在在的促进了对 Java 语言体系的认识和理解。</p><p>所谓身在其中自然不得其全貌，多学几门语言，你才能够解锁上帝视角。如果你想要在技术这条路上走得更远，那么请多多接触，作为 Java 开发者，不只是 Kotlin，我也还建议大家认真了解下 Python、JavaScript 还有 Go（如果。。算了，要学 Haskell 的人应该不需要看这篇文章） ，他们背后的生态差异会让你打开一扇又一扇新世界的大门。</p><p>共勉吧。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的朋友，慕课网会在12月收到课程原价等值的定向代金券，可用于补差价升级到新课，由于现在新课限时优惠，因此只需要 77 元即可升级到新课。新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有600+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;如果你觉得天气热不舒服，那一定是享受过凉爽之后才会有的感觉。你没有意识到 Java 的问题，那正说明你应该试试 Kotlin。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(6) - 协程挂起篇</title>
    <link href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/"/>
    <id>https://www.bennyhuo.com/2019/05/07/coroutine-suspend/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-12-01T14:58:41.192Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程的挂起最初是一个很神秘的东西，因为我们总是用线程的概念去思考，所以我们只能想到阻塞。不阻塞的挂起到底是怎么回事呢？说出来你也许会笑~~（哭？。。抱歉这篇文章我实在是没办法写的更通俗易懂了，大家一定要亲手实践！）</p></blockquote><a id="more"></a><h2 id="1-先看看-delay"><a href="#1-先看看-delay" class="headerlink" title="1. 先看看 delay"></a>1. 先看看 delay</h2><p>我们刚刚学线程的时候，最常见的模拟各种延时用的就是 <code>Thread.sleep</code> 了，而在协程里面，对应的就是 <code>delay</code>。<code>sleep</code> 让线程进入休眠状态，直到指定时间之后某种信号或者条件到达，线程就尝试恢复执行，而 <code>delay</code> 会让协程挂起，这个过程并不会阻塞 CPU，甚至可以说从硬件使用效率上来讲是“什么都不耽误”，从这个意义上讲 <code>delay</code> 也可以是让协程休眠的一种很好的手段。</p><p><code>delay</code> 的源码其实很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(timeMillis: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeMillis &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="comment">// don't delay</span></span><br><span class="line">    <span class="keyword">return</span> suspendCancellableCoroutine <span class="symbol">sc@</span> &#123; cont: CancellableContinuation&lt;<span class="built_in">Unit</span>&gt; -&gt;</span><br><span class="line">        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cont.context.delay.scheduleResumeAfterDelay</code> 这个操作，你可以类比 JavaScript 的 <code>setTimeout</code>，Android 的 <code>handler.postDelay</code>，本质上就是设置了一个延时回调，时间一到就调用 <code>cont</code> 的 resume 系列方法让协程继续执行。</p><p>剩下的最关键的就是 <code>suspendCancellableCoroutine</code> 了，这可是我们的老朋友了，前面我们用它实现了回调到协程的各种转换 —— 原来 <code>delay</code> 也是基于它实现的，如果我们再多看一些源码，你就会发现类似的还有 <code>join</code>、<code>await</code> 等等。</p><h2 id="2-再来说说-suspendCancellableCoroutine"><a href="#2-再来说说-suspendCancellableCoroutine" class="headerlink" title="2. 再来说说 suspendCancellableCoroutine"></a>2. 再来说说 suspendCancellableCoroutine</h2><p>既然大家对于 <code>suspendCancellableCoroutine</code> 已经很熟悉了，那么我们干脆直接召唤一个老朋友给大家：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">joinSuspend</span><span class="params">()</span></span> = suspendCancellableCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; cont -&gt;</span><br><span class="line">    cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(<span class="keyword">this</span>, cont).asHandler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Job.join()</code> 这个方法会首先检查调用者 <code>Job</code> 的状态是否已经完成，如果是，就直接返回并继续执行后面的代码而不再挂起，否则就会走到这个 <code>joinSuspend</code> 的分支当中。我们看到这里只是注册了一个完成时的回调，那么传说中的 <code>suspendCancellableCoroutine</code> 内部究竟做了什么呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCancellableCoroutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">crossinline</span> block: (<span class="type">CancellableContinuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: T =</span><br><span class="line">    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class="line">        <span class="keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)</span><br><span class="line">        block(cancellable)</span><br><span class="line">        cancellable.getResult() <span class="comment">// 这里的类型是 Any?</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>suspendCoroutineUninterceptedOrReturn</code> 这个方法调用的源码是看不到的，因为它根本没有源码：P 它的逻辑就是帮大家拿到 <code>Continuation</code> 实例，真的就只有这样。不过这样说起来还是很抽象，因为有一处非常的可疑：<code>suspendCoroutineUninterceptedOrReturn</code> 的返回值类型是 <code>T</code>，而传入的 lambda 的返回值类型是 <code>Any?</code>， 也就是我们看到的 <code>cancellable.getResult()</code> 的类型是 <code>Any?</code>，这是为什么？</p><p>我记得在协程系列文章的开篇，我就提到过 <code>suspend</code> 函数的签名，当时是以 <code>await</code> 为例的，这个方法大致相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">User</span>&gt;)</span></span>: Any &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>suspend</code> 一方面为这个方法添加了一个 <code>Continuation</code> 的参数，另一方面，原先的返回值类型 <code>User</code> 成了 <code>Continuation</code> 的泛型实参，而真正的返回值类型竟然是 <code>Any</code>。当然，这里因为定义的逻辑返回值类型 <code>User</code> 是不可空的，因此真实的返回值类型也用了 <code>Any</code> 来示意，如果泛型实参是个可空的类型，那么真实的返回值类型也就是 <code>Any?</code> 了，这正与前面提到的 <code>cancellable.getResult()</code> 返回的这个 <code>Any?</code> 相对应。</p><blockquote><p>如果大家去查 <code>await</code> 的源码，你同样会看到这个 <code>getResult()</code> 的调用。</p></blockquote><p>简单来说就是，对于 <code>suspend</code> 函数，不是一定要挂起的，可以在需要的时候挂起，也就是要等待的协程还没有执行完的时候，等待协程执行完再继续执行；而如果在开始 <code>join</code> 或者 <code>await</code> 或者其他 <code>suspend</code> 函数，如果目标协程已经完成，那么就没必要等了，直接拿着结果走人即可。那么这个神奇的逻辑就在于 <code>cancellable.getResult()</code> 究竟返回什么了，且看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult</span><span class="params">()</span></span>: Any? &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (trySuspend()) <span class="keyword">return</span> COROUTINE_SUSPENDED <span class="comment">// ① 触发挂起逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (state <span class="keyword">is</span> CompletedExceptionally)  <span class="comment">// ② 异常立即抛出</span></span><br><span class="line">        <span class="keyword">throw</span> recoverStackTrace(state.cause, <span class="keyword">this</span>) </span><br><span class="line">    <span class="keyword">return</span> getSuccessfulResult(state) <span class="comment">// ③ 正常结果立即返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码 ① 处就是挂起逻辑了，表示这时候目标协程还没有执行完，需要等待结果，②③是协程已经执行完可以直接拿到异常和正常结果的两种情况。②③好理解，关键是 ①，它要挂起，这返回的是个什么东西？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> COROUTINE_SUSPENDED: Any <span class="keyword">get</span>() = CoroutineSingletons.COROUTINE_SUSPENDED</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineSingletons</span> </span>&#123; COROUTINE_SUSPENDED, UNDECIDED, RESUMED &#125;</span><br></pre></td></tr></table></figure><p>这是 1.3 的实现，1.3 以前的实现更有趣，就是一个白板 <code>Any</code>。其实是什么不重要，关键是这个东西是一个单例，任何时候协程见到它就知道自己该挂起了。</p><h2 id="3-深入挂起操作"><a href="#3-深入挂起操作" class="headerlink" title="3. 深入挂起操作"></a>3. 深入挂起操作</h2><p>既然说到挂起，大家可能觉得还是一知半解，还是不知道挂起究竟怎么做到的，怎么办？说真的这个挂起是个什么操作其实一直没有拿出来给大家看，不是我们太小气了，只是太早拿出来会比较吓人。。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">        continuation.resume(<span class="number">1024</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    COROUTINE_SUSPENDED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我写了这么一个 <code>suspend</code> 函数，在 <code>suspendCoroutineUninterceptedOrReturn</code> 当中直接返回了这个传说中的白板 <code>COROUTINE_SUSPENDED</code>，正常来说我们应该在一个协程当中调用这个方法对吧，可是我偏不，我写一段 Java 代码去调用这个方法，结果会怎样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallCoroutine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        Object value = SuspendTestKt.hello(<span class="keyword">new</span> Continuation&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@NotNull</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> CoroutineContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeWith</span><span class="params">(@NotNull Object o)</span> </span>&#123; <span class="comment">// ①</span></span><br><span class="line">                <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">                    handleResult(o);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Throwable throwable = (Throwable) o;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(value == IntrinsicsKt.getCOROUTINE_SUSPENDED())&#123; <span class="comment">// ②</span></span><br><span class="line">            LogKt.log(<span class="string">"Suspended."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handleResult(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        LogKt.log(<span class="string">"The result is "</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看上去比较奇怪，可能会让人困惑的有两处：</p><p>① 处，我们在 Kotlin 当中看到的 <code>resumeWith</code> 的参数类型是 <code>Result</code>，怎么这儿成了 <code>Object</code> 了？因为 <code>Result</code> 是内联类，编译时会用它唯一的成员替换掉它，因此就替换成了 <code>Object</code> （在Kotlin 里面是 <code>Any?</code>）</p><p>② 处 <code>IntrinsicsKt.getCOROUTINE_SUSPENDED()</code> 就是 Kotlin 的 <code>COROUTINE_SUSPENDED</code></p><p>剩下的其实并不难理解，运行结果自然就是如下所示了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">07:52:55:288 [main] 1</span><br><span class="line">07:52:55:293 [main] 3</span><br><span class="line">07:52:55:296 [main] Suspended.</span><br><span class="line">07:52:56:298 [Thread-0] 2</span><br><span class="line">07:52:56:306 [Thread-0] The result is 1024</span><br></pre></td></tr></table></figure><p>其实这段 Java 代码的调用方式与 Kotlin 下面的调用已经很接近了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过我们在 Kotlin 当中还是不太容易拿到 <code>hello</code> 在挂起时的真正返回值，其他的返回结果完全相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12:44:08:290 [main] 1</span><br><span class="line">12:44:08:292 [main] 3</span><br><span class="line">12:44:09:296 [Thread-0] 2</span><br><span class="line">12:44:09:296 [Thread-0] 1024</span><br></pre></td></tr></table></figure><p>很有可能你看到这里都会觉得晕头转向，没有关系，我现在已经开始尝试揭示一些协程挂起的背后逻辑了，比起简单的使用，概念的理解和接受需要有个小小的过程。</p><h2 id="4-深入理解协程的状态转移"><a href="#4-深入理解协程的状态转移" class="headerlink" title="4. 深入理解协程的状态转移"></a>4. 深入理解协程的状态转移</h2><p>前面我们已经对协程的原理做了一些揭示，显然 Java 的代码让大家能够更容易理解，那么接下来我们再来看一个更复杂的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">returnSuspended</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt;&#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        continuation.resume(<span class="string">"Return suspended."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    COROUTINE_SUSPENDED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">returnImmediately</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt;&#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="string">"Return immediately."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先定义两个挂起函数，第一个会真正挂起，第二个则会直接返回结果，这类似于我们前面讨论 <code>join</code> 或者 <code>await</code> 的两条路径。我们再用 Kotlin 给出一个调用它们的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    log(returnSuspended())</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    log(returnImmediately())</span><br><span class="line">    log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">08:09:37:090 [main] 1</span><br><span class="line">08:09:38:096 [Thread-0] Return suspended.</span><br><span class="line">08:09:38:096 [Thread-0] 2</span><br><span class="line">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class="line">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] Return immediately.</span><br><span class="line">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 4</span><br></pre></td></tr></table></figure><p>好，现在我们要揭示这段协程代码的真实面貌，为了做到这一点，我们用 Java 来仿写一下这段逻辑：</p><blockquote><p>注意，下面的代码逻辑上并不能做到十分严谨，不应该出现在生产当中，仅供学习理解协程使用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContinuationImpl</span> <span class="keyword">implements</span> <span class="title">Continuation</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> label = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Continuation&lt;Unit&gt; completion;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContinuationImpl</span><span class="params">(Continuation&lt;Unit&gt; completion)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completion = completion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CoroutineContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeWith</span><span class="params">(@NotNull Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = o;</span><br><span class="line">            <span class="keyword">switch</span> (label) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                    LogKt.log(<span class="number">1</span>);</span><br><span class="line">                    result = SuspendFunctionsKt.returnSuspended( <span class="keyword">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                    LogKt.log(result);</span><br><span class="line">                    LogKt.log(<span class="number">2</span>);</span><br><span class="line">                    result = DelayKt.delay(<span class="number">1000</span>, <span class="keyword">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                    LogKt.log(<span class="number">3</span>);</span><br><span class="line">                    result = SuspendFunctionsKt.returnImmediately( <span class="keyword">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">                    LogKt.log(result);</span><br><span class="line">                    LogKt.log(<span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completion.resumeWith(Unit.INSTANCE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            completion.resumeWith(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSuspended</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result == IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个 Java 类 <code>ContinuationImpl</code>，它就是一个 <code>Continuation</code> 的实现。</p><blockquote><p>实际上如果你愿意，你还真得可以在 Kotlin 的标准库当中找到一个名叫 <code>ContinuationImpl</code> 的类，只不过，它的 <code>resumeWith</code> 最终调用到了 <code>invokeSuspend</code>，而这个 <code>invokeSuspend</code> 实际上就是我们的协程体，通常也就是一个 Lambda 表达式 —— 我们通过 <code>launch</code>启动协程，传入的那个 Lambda 表达式，实际上会被编译成一个 <code>SuspendLambda</code> 的子类，而它又是 <code>ContinuationImpl</code> 的子类。</p></blockquote><p>有了这个类我们还需要准备一个 completion 用来接收结果，这个类仿照标准库的 <code>RunSuspend</code> 类实现，如果你有阅读前面的文章，那么你应该知道 suspend main 的实现就是基于这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunSuspend</span> <span class="keyword">implements</span> <span class="title">Continuation</span>&lt;<span class="title">Unit</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CoroutineContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeWith</span><span class="params">(@NotNull Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">            notifyAll(); <span class="comment">// 协程已经结束，通知下面的 wait() 方法停止阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Object result = <span class="keyword">this</span>.result;</span><br><span class="line">                <span class="keyword">if</span>(result == <span class="keyword">null</span>) wait(); <span class="comment">// 调用了 Object.wait()，阻塞当前线程，在 notify 或者 notifyAll 调用时返回</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(result <span class="keyword">instanceof</span> Throwable)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Throwable) result;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的关键点在于 <code>await()</code> 方法，它在其中起了一个死循环，不过大家不要害怕，这个死循环是个纸老虎，如果 <code>result</code> 是 <code>null</code>，那么当前线程会被立即阻塞，直到结果出现。具体的使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RunSuspend runSuspend = <span class="keyword">new</span> RunSuspend();</span><br><span class="line">        ContinuationImpl table = <span class="keyword">new</span> ContinuationImpl(runSuspend);</span><br><span class="line">        table.resumeWith(Unit.INSTANCE);</span><br><span class="line">        runSuspend.await();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>这写法简直就是 suspend main 的真实面貌了。</p></blockquote><p>我们看到，作为 completion 传入的 <code>RunSuspend</code> 实例的 <code>resumeWith</code> 实际上是在 <code>ContinuationImpl</code> 的 <code>resumeWtih</code> 的最后才会被调用，因此它的 <code>await()</code> 一旦进入阻塞态，直到 <code>ContinuationImpl</code> 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕正常退出了。</p><p>于是这段代码的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">08:36:51:305 [main] 1</span><br><span class="line">08:36:52:315 [Thread-0] Return suspended.</span><br><span class="line">08:36:52:315 [Thread-0] 2</span><br><span class="line">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class="line">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] Return immediately.</span><br><span class="line">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 4</span><br></pre></td></tr></table></figure><p>我们看到，这段普通的 Java 代码与前面的 Kotlin 协程调用完全一样。那么我这段 Java 代码的编写根据是什么呢？就是 Kotlin 协程编译之后产生的字节码。当然，字节码是比较抽象的，我这样写出来就是为了让大家更容易的理解协程是如何执行的，看到这里，相信大家对于协程的本质有了进一步的认识：</p><ul><li>协程的挂起函数本质上就是一个回调，回调类型就是 <code>Continuation</code></li><li>协程体的执行就是一个状态机，每一次遇到挂起函数，都是一次状态转移，就像我们前面例子中的 <code>label</code> 不断的自增来实现状态流转一样</li></ul><p>如果能够把这两点认识清楚，那么相信你在学习协程其他概念的时候就都将不再是问题了。如果想要进行线程调度，就按照我们讲到的调度器的做法，在 <code>resumeWith</code> 处执行线程切换就好了，其实非常容易理解的。官方的协程框架本质上就是在做这么几件事儿，如果你去看源码，可能一时云里雾里，主要是因为框架除了实现核心逻辑外还需要考虑跨平台实现，还需要优化性能，但不管怎么样，这源码横竖看起来就是五个字：状态机回调。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>不同以往，我们从这一篇开始毫无保留的为大家尝试揭示协程背后的逻辑，也许一时间可能有些难懂，不过不要紧，你可以使用协程一段时间之后再来阅读这些内容，相信一定会豁然开朗的。</p><p>当然，这一篇内容的安排更多是为后面的序列篇开路，Kotlin 的 <code>Sequence</code> 就是基于协程实现的，它的用法很简单，几乎与普通的 <code>Iterable</code> 没什么区别，因此序列篇我们会重点关注它的内部实现原理，欢迎大家关注。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的朋友，慕课网会在12月收到课程原价等值的定向代金券，可用于补差价升级到新课，由于现在新课限时优惠，因此只需要 77 元即可升级到新课。新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有600+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;协程的挂起最初是一个很神秘的东西，因为我们总是用线程的概念去思考，所以我们只能想到阻塞。不阻塞的挂起到底是怎么回事呢？说出来你也许会笑~~（哭？。。抱歉这篇文章我实在是没办法写的更通俗易懂了，大家一定要亲手实践！）&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
