<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bennyhuo</title>
  
  <subtitle>编程、教学 &amp; Kotlin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.bennyhuo.com/"/>
  <updated>2020-11-07T02:28:44.210Z</updated>
  <id>https://www.bennyhuo.com/</id>
  
  <author>
    <name>Bennyhuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>要再见了吗，Kotlin Android Extension</title>
    <link href="https://www.bennyhuo.com/2020/11/07/deprecated-kotlin-android-extensions/"/>
    <id>https://www.bennyhuo.com/2020/11/07/deprecated-kotlin-android-extensions/</id>
    <published>2020-11-06T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.210Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>伴随了我们这么多年的 KAE，就这么要离开我们了？</p></blockquote><a id="more"></a><blockquote><p>本文假定大家了解 KAE（Kotlin Android Extensions）。</p></blockquote><p>前几天看到邮件说 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.4.20-M2" target="_blank" rel="noopener">Kotlin 1.4.20-M2</a> 发布了，于是打开看了看更新，发现有个新的用于 Parcelize 的插件。要知道这个功能一直都是集成在 KAE 当中的，那 KAE 呢？</p><p>紧接着我们就可以看到一行：<a href="https://youtrack.jetbrains.com/issue/KT-42121" target="_blank" rel="noopener">Deprecate Kotlin Android Extensions compiler plugin</a>。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-05-15-18-42.png" alt=""></p><p>说实话，直接废弃，我还是有些意外的。毕竟这个插件在早期为 Kotlin 攻城略地快速吸引 Android 开发者立下了汗马功劳，多年来虽然几乎没有功能更新，但直到现在仍然能够胜任绝大多数场景。</p><p>非要说废弃的理由，确实也能罗列几个出来。为了方便，我们把以 layout 当中 View 的 id 为名而合成的属性简称<strong>合成的属性</strong>。</p><h2 id="销毁之后的空指针"><a href="#销毁之后的空指针" class="headerlink" title="销毁之后的空指针"></a>销毁之后的空指针</h2><p>KAE 是通过在字节码层面添加合成属性来解决 findViewById 的问题的，对于 Activity 和 Fragment 而言，合成的属性背后其实就是一个缓存，这个缓存会在 Activity 的 onDestroy、Fragment 的 onDestroyView 的时候清空。所以每次访问合成的属性，其实只有第一次是调用 findViewById，之后就是一个查缓存的过程。</p><p>这个设计很合理，不过也不免有些危险存在。主要是在 Fragment 当中，如果不小心在 onDestroyView 调用之后访问了这些合成的属性，就会抛一个空指针异常，因为此时缓存已经被清空，而 Fragment 的 View 也被置为 null 了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line"></span><br><span class="line">        textView.text = <span class="string">"Crash!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须说明的一点是，这里抛空指针是合理的，毕竟 Fragment 的 View 的生命周期已经结束了，不过生产实践当中很多时候不是一句“合理”就能解决问题的，我们要的更多的是给老板减少损失。这里如果 textView 仍然可以访问，它不过是修改了一下文字而已，不会有其他副作用，但恰恰因为 KAE 这里严格的遵守了生命周期的变化清空了缓存，却又没有办法阻止开发者继续访问这个合成属性而导致空指针。对比而言，如果我们直接使用 findViewById，情况可能是下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> textView: TextView</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">    textView = view.findViewById(R.id.textView)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroyView()</span><br><span class="line"></span><br><span class="line">    textView.text = <span class="string">"Nothing happened."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码虽然看上去不怎么高明，但它至少不会 Crash。</p><p>Kotlin 一向追求代码的安全性，而且希望在编译时就把代码运行时可能产生的问题尽可能地暴露出来。在很多场景下 Kotlin 确实做得很好，然而 KAE 并没有做到这一点。</p><p>就这个具体的问题而言，倒也很容易解决，现在 Android 当中已经有了足够多的生命周期管理工具，我们能够很好的避免在 Fragment 或者 Activity 的生命周期结束之后还要执行一些相关的操作。例如使用 <code>lifecycleScope.launchWhenResumed{ ... }</code> 就能很好的解决这个问题。</p><p>这么看来，这一点似乎不算是 KAE 本身的缺陷。难道是我们要求太高了？不，降低标准的事儿我们是绝不会做的，Kotlin 官方这么多年都没有解决这个问题，快出来挨打 （╬￣皿￣）＝○＃（￣＃）３￣） 。</p><h2 id="张冠李戴"><a href="#张冠李戴" class="headerlink" title="张冠李戴"></a>张冠李戴</h2><p>由于合成的属性只能从 Receiver 的类型上做限制，无法确定对应的 View、Activity、Fragment 当中是否真实存在这个合成的属性对应 id 的 View，因此也存在访问安全性上的隐患。</p><p>例如我当前的 Activity 的 layout 是 activity_main.xml，其中并未定义 id 为 textView 的 View，然而下面的写法却不会在编译时报错：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.fragment_main.*</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">textView.text = <span class="string">"MainActivity"</span></span><br></pre></td></tr></table></figure><p>编译时高高兴兴，运行时就要垂头丧气了，因为 findViewById 一定会返回 null，而合成的属性又不是可空类型。</p><p>这个问题从现有的 KAE 的思路上来看，确实不太好解决，不过从多年的实践来看，这也许都算不上是一个问题，至少我用了快 5 年 KAE，只有偶尔几次写错 id 以外，多数情况下不会出现此类问题。这个问题确实算是一个缺陷，但它的影响实在是有限。</p><h2 id="冲突的-ID"><a href="#冲突的-ID" class="headerlink" title="冲突的 ID"></a>冲突的 ID</h2><p>还有一个问题就是命名空间的问题。合成的属性从导包的形式上来看，像是以 layout 的文件名加上固定的前缀合成的包下的顶级属性，一旦这个包被导入，当前的整个文件当中都可以使用 View、Activity、Fragment 来访问这些合成的属性，这就及其容易导致命名空间冲突的问题。</p><p>为了说明问题，我们创建两个完全相同的 layout，分别命名为 view_tips.xml 和 view_warning.xml，里面只是简单的包含一个 id 为 textView 的 TextView</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/textView"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 Activity 或者 Fragment 当中加载这两个 layout：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tipsView = View.inflate(view.context, R.layout.view_tips, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">val</span> warningView = View.inflate(view.context, R.layout.view_warning, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">tipsView.textView.text = <span class="string">"Tips"</span></span><br><span class="line">warningView.textView.text = <span class="string">"Warning"</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">// 添加到对应的父 View 当中</span></span><br></pre></td></tr></table></figure><p>那么这时候我们就要面临一个导包的问题，tipsView 和 warningView 访问的合成属性可能来自于以下两个包：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kotlinx.android.synthetic.main.view_tips.view.*</span><br><span class="line">kotlinx.android.synthetic.main.view_warning.view.*</span><br></pre></td></tr></table></figure><p>我们当然可以把二者一并导入，但问题在于二者即便如此，合成的属性在编译时静态绑定也只能绑定到一个包下面的合成属性下，这样的结果就是我们在 Android Studio 当中点击 warningView.textView 可能会跳转到 view_tips 这个 layout 当中。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20201107095613833.png" alt="image-20201107095613833"></p><p>运行时会不会有问题呢？那倒不至于，因为你始终记住合成属性在运行时会替换成 findViewById 就可以了，只要 findViewById 不出问题，那合成属性自然也不存在问题。从生成的字节码来看，<code>warningView.textView</code> 其实就等价于 <code>warningView.findViewById(R.id.textView)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALOAD 4</span><br><span class="line">DUP</span><br><span class="line">LDC &quot;warningView&quot;</span><br><span class="line">GETSTATIC com&#x2F;bennyhuo&#x2F;helloandroid&#x2F;R$id.textView : I</span><br><span class="line">INVOKEVIRTUAL android&#x2F;view&#x2F;View.findViewById (I)Landroid&#x2F;view&#x2F;View;</span><br><span class="line">CHECKCAST android&#x2F;widget&#x2F;TextView</span><br></pre></td></tr></table></figure><p>所以这个问题本质上影响的是开发体验。出现冲突，一方面可能是类文件太大，包含的 UI 逻辑过多，导致引入过多的 layout，从而产生冲突；另一方面也可能是布局上拆分得太小，一个视图的逻辑类当中不得不引入大量的 layout 导致冲突。通过合理的设计 UI 相关的类，这个问题本身也可以很好的规避。</p><p>另外，如果语言本身支持把包名作为命名空间，在代码访问时直接予以限定，一样可以达到目的。按照现有的语法特性，如果合成的属性是在一个 object 当中定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ViewTipsLayout &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> View.textView: TextView</span><br><span class="line">    <span class="keyword">get</span>() = findViewById(R.id.textView)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> ViewWarningLayout &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> View.textView: TextView</span><br><span class="line">    <span class="keyword">get</span>() = findViewById(R.id.textView)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用的时候如果产生 id 冲突，就可以这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with(ViewTipsLayout) &#123;</span><br><span class="line">  tipsView.textView.text = <span class="string">"Tips"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">with(ViewWarningLayout) &#123;</span><br><span class="line">  warningView.textView.text = <span class="string">"Warning"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这只是我们的设想了。毕竟都要废弃了。</p><h2 id="不支持-Compose"><a href="#不支持-Compose" class="headerlink" title="不支持 Compose"></a>不支持 Compose</h2><p>去年的时候 Anko 就被废弃了，这么想来，KAE 能苟活这么久大概是因为根本不怎么需要维护吧？在这里提 Anko 到不是为了嘲讽，Anko 虽然离开了我们，可 Anko 所倡导的 DSL 布局的精神却留了下来，也就是 Jetpack 当中仍然处于 Alpha 状态（怎么都是 Alpha，难道这么久了还不配有个 Beta 吗）的 Compose 了。</p><p>Anko Layout 不算成功，主要原因还是开发成本的问题。预览要等编译，编译又要很久，这简直了，谁用谁知道。隔壁家的 SwiftUI 就做得很好，说明鱼和熊掌还是可以兼得的，所以我看好 Compose，就看 Android 还能活几年，能不能等到那个时候了（哈哈哈，开玩笑）。</p><p>Kotlin 最近一直在推 KMM，大家都在猜 Kotlin 官方会不会搞一个 React Kotlin Native 或者 Klutter 出来，结果最近我们就看到 JetBrains 的 GitHub 下一个叫 <a href="https://github.com/JetBrains/skiko" target="_blank" rel="noopener">skiko</a> 的框架非常活跃，它是基于 Kotlin 多平台特性封装的 Skia 的 API（Flutter：喵喵喵？？）。还有一个就是 <a href="https://github.com/JetBrains/compose-jb" target="_blank" rel="noopener">compose-jb</a> 了，我粗略看了下，目前已经把 Compose 移植到了桌面上，支持了 Windows、Linux、macOS，也不知道 iOS 被安排了没有（真实司马昭之心啊）。所以 Compose 已经不再是 Android 的了，它是大家的。</p><p>对于 Compose 而言，KAE 一点儿用都没有，因为人家根本不需要做 View 绑定好不好。</p><blockquote><p>KAE：我这么优秀！</p><p>Compose：你给我让开！</p></blockquote><h2 id="使用-ViewBinding-作为替代方案"><a href="#使用-ViewBinding-作为替代方案" class="headerlink" title="使用 ViewBinding 作为替代方案"></a>使用 ViewBinding 作为替代方案</h2><p>那么问题来了，KAE 废弃之后会怎么样呢？按照链接当中的说明来看，废弃之后仍然可以使用，但会有一个警告；当然，出现问题官方也不会再修复了，更不会有新功能。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-01-08-16-09.png" alt=""></p><p>Kotlin 官方建议开发者使用 Android 的 <a href="https://developer.android.com/topic/libraries/view-binding" target="_blank" rel="noopener">View Binding</a> 来解决此类场景的问题。客观的讲 View Binding 确实能解决前面提到的几个 KAE 存在的问题，但 View Binding 的写法上也会略显啰嗦：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _binding: ResultProfileBinding? = <span class="literal">null</span></span><br><span class="line"><span class="comment">// This property is only valid between onCreateView and</span></span><br><span class="line"><span class="comment">// onDestroyView.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">    savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: View? &#123;</span><br><span class="line">    _binding = ResultProfileBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">val</span> view = binding.root</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">    _binding = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 View 时：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binding.name.text = viewModel.name</span><br><span class="line">binding.button.setOnClickListener &#123; viewModel.userClicked() &#125;</span><br></pre></td></tr></table></figure><p>相比之下，KAE 解决了 findViewById 的类型安全和访问繁琐的问题；而 View Binding 则在此基础上又解决了空安全的问题。</p><p>我看到在废弃 KAE 的讨论中，大家还是觉得废弃有些难以理解，毕竟之前你也没怎么管这个插件啊，这么多年了除了加了个 Parcelize 的功能以外，也没怎么着啊。不过历史的车轮总是在往前滚（(ノ｀Д)ノ）的嘛，也许 Kotlin 官方这么急着废弃 KAE，也许就是要为 View Binding 让路，JetBrains 现在和 Google 穿一条裤子，谁知道他们是不是有什么对未来的美（si）好（xia）规（jiao）划（yi）呢？哈哈，玩笑啦。</p><p>其实 View Binding 除了写起来多了几行代码以外，别的倒也没什么大毛病。而写法复杂这个嘛，其实说来也简单，我们稍微封装一下不就行了么？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBindingFragment</span>&lt;<span class="type">T: ViewBinding</span>&gt;: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _binding: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> binding: T</span><br><span class="line">        <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateBinding</span><span class="params">(inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 savedInstanceState: <span class="type">Bundle</span>?)</span></span>: T</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> T.<span class="title">onViewCreated</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">return</span> onCreateBinding(inflater, container, savedInstanceState).also &#123;</span><br><span class="line">            _binding = it</span><br><span class="line">        &#125;.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        binding.onViewCreated()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">        _binding = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样用的时候直接继承这个类就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainFragment</span> : <span class="type">ViewBindingFragment</span>&lt;<span class="type">FragmentMainBinding</span>&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateBinding</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: FragmentMainBinding &#123;</span><br><span class="line">        <span class="keyword">return</span> FragmentMainBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> FragmentMainBinding.<span class="title">onViewCreated</span><span class="params">()</span></span> &#123;</span><br><span class="line">        textView.text = <span class="string">"MainFragment"</span></span><br><span class="line">        textView.setOnClickListener &#123;</span><br><span class="line">            Toast.makeText(requireContext(), <span class="string">"Clicked."</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也就是我随手那么一写，肯定算不上完美，但至少说明 View Binding 的写法一样可以做到很简洁。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>KAE 本质上就是通过编译期生成字节码的方式为 Activity、Fragment、View 提供了以 xml 布局中的 id 为名的合成属性，从而简化使用 findViewById 来实现 View 绑定的一个插件。</p><p>相比之下，KAE 比 findViewById 本身提供了更简便的访问方式，也保证了 View 的类型安全，但却无法保证 View 的空安全 —— 而这些问题都在 ViewBinding 当中得到了解决。</p><p>不管怎样，KAE 被废弃是没什么悬念了，它曾经一度填补了 Android 开发体验上的空缺，也曾经一度受到追捧和质疑，更曾是 Kotlin 早期吸引 Android 开发者的一把利器，现在终于完成了它自己的历史任务。</p><p>再见，KAE。</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;伴随了我们这么多年的 KAE，就这么要离开我们了？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="android" scheme="https://www.bennyhuo.com/tags/android/"/>
    
      <category term="news" scheme="https://www.bennyhuo.com/tags/news/"/>
    
  </entry>
  
  <entry>
    <title>说说最近官方公布的 Kotlin 的动态</title>
    <link href="https://www.bennyhuo.com/2020/10/19/kotlin-news-202010/"/>
    <id>https://www.bennyhuo.com/2020/10/19/kotlin-news-202010/</id>
    <published>2020-10-18T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.204Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 的发展可以认为是正式进入了下一个阶段。</p></blockquote><a id="more"></a><p>有段时间没有写文章了。</p><p>今年年底还有些事情要做，所幸大多数都与 Kotlin 有关系，不算耽搁太多。加上现阶段大家有相对充足的资料学习 Kotlin，尽管协程之前的资料相对匮乏，我也在年中出版了一本书暂时补齐了这块儿缺漏，因此我就这么安慰自己不要压力太大，以免腰更加突出，哈哈。</p><p>不过，官方最近有些消息放出来让我有些坐不住了。</p><h2 id="1-Kotlin-的发版节奏"><a href="#1-Kotlin-的发版节奏" class="headerlink" title="1. Kotlin 的发版节奏"></a>1. Kotlin 的发版节奏</h2><p>过去 Kotlin 的版本节奏一直比较佛系，从 1.0 到 1.1 花了一年多，到 1.2 才半年，到 1.3 又近一年，1.4 却花了将近两年。为什么会这样呢？因为越往后，Kotlin 自身的体系越庞大，想要做点儿什么的复杂度可想而知的变高，自然版本节奏就没那么好把控了。</p><p>功能优先还是版本优先？</p><p>显然这个问题在不同的发展阶段是有不同的答案的。项目刚开始，自然需要稳扎稳打，做一个功能就是一个功能，因此可以说 1.4 及以前的所有版本的迭代计划都是按照这个思路展开的，功能啥时候做好啥时候上，做不好就 delay。</p><p>而现如今，</p><p>Kotlin 经过 1.0 正式发布</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-00-49.png" alt=""></p><p>1.1 正式支持 JavaScript 并开始试验协程</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-08.png" alt=""></p><p>1.2 开始试验多平台</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-29.png" alt=""></p><p>1.3 正式支持协程并开始了 Native 的 beta，多平台的生态随之也开始逐渐展开</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-48.png" alt=""></p><p>1.4 有做了一系列整体的性能优化和提升，编译器重构也基本完成</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-02-06.png" alt=""></p><p>可以说 Kotlin 现阶段的基本盘已经形成，当前版本足以长期支撑开发者完成开发工作了。</p><p>接下来的工作重点我们在之前的文章当中就曾经谈到，其实就是应用场景的挖掘，开发体验的优化和提升，以及多平台的完善和生态的建设。这些大都不算是巨大的语言特性，因此 Kotlin Team 宣布后面发版半年一次，这意味着 Kotlin 1.5 将在明年春天发布，规划的特性实行班车机制，赶得上版本就发布，赶不上就下一趟。</p><p>这样做好处也是很明显的，版本的节奏感会给开发者带来期待，我们不再需要猜下一个版本什么时候来，以及下一个版本会有什么，因为这些都会很早就公布；一些细节的改进我们也不需要苦等很久才能体验到，因为版本节奏快了，一些小的改进会更快的被呈现在开发者面前。</p><h2 id="2-Kotlin-的-Roadmap"><a href="#2-Kotlin-的-Roadmap" class="headerlink" title="2. Kotlin 的 Roadmap"></a>2. Kotlin 的 Roadmap</h2><p>我过去想要提前了解 Kotlin 下一步的动态，主要去 Kotlin 的 GitHub 的仓库和 YouTrack 当中去爬 issue，看大家的讨论，这个过程会比较有趣，因为大佬们经常吵架。如果只是想要消遣，这个方式跟刷知乎也没什么两样，不过如果是去获取信息，那就需要自己认认真真的瞎猜了。</p><p>再往前的时候，Kotlin Team 还会维护一下 Kotlin 在 GitHub 上开的 Keep 仓库，不过这个仓库现在已经是一副年久失修的感觉了。说来还真是要好好提一下，Kotlin 协程的设计文档就在 Keep 仓库当中，虽然感觉比较久远了，但还是很值得一读的。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-27-41.png" alt=""></p><p>现在好了，官方直接公布了 Roadmap，这一招配合 Kotlin 的发版节奏的改变，极大的方便了我们这些吃瓜群众。不是想知道 Kotlin 啥时候实现自举吗？Kotlin Team 已经在解决这个问题了，不信看这里：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-54-22.png" alt=""></p><p>顺便我们也看到了 Kotlin 编译器插件的 API 现在还没有排到最高优先级，所以等等吧。</p><p>这次 Roadmap 的公布，还是有一些比较有趣的点的，例如：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-57-40.png" alt=""></p><p>多个 receiver 的函数，可能有些朋友还没有用到过。其实这个特性现在也有办法来模拟，就是通过隐式 receiver 的方式来实现，但如果能够有专门的语法来支持的，应该还会有更会玩的用法出现。</p><p>Kotlin 近期公布的 Roadmap 见：<a href="https://kotlinlang.org/roadmap.html" target="_blank" rel="noopener">Kotlin Roadmap</a>，大家可以自己看看有没有自己感兴趣的内容。</p><h2 id="3-KMM-插件"><a href="#3-KMM-插件" class="headerlink" title="3. KMM 插件"></a>3. KMM 插件</h2><p>KMM 算是 Kotlin Team 为多平台这个重磅特性挖掘的一个重要的应用场景。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-28-19.png" alt=""></p><p>毕竟 Kotlin 的用户大多是 Android 开发，Android 开发者的老板们有迫切的希望他手底下的 Android 开发能拿一份工资干两人的活，对吧。不仅如此，Android 开发也希望自己在市场上更有竞争力，如果 Kotlin 适用场景变多了，那么自己岂不是就像买了股票一样跑赢大盘？所以 KMM 简直就是众望所归。</p><p>KMM 运行在 iOS 上的实际上就是 Kotlin Native 的代码，通过 Kotlin MPP 与运行在 Android 上的 Kotlin Jvm 代码来共享逻辑。最近随着 Kotlin 1.4 发布推出的 KMM 插件也支持了在 Android Studio 上直接运行 iOS 应用，启动 iOS 模拟器，甚至单步调试运行在 iOS 上的 Kotlin Native 代码的能力。</p><p>不过，如果想要将 KMM 直接应用于移动端跨平台上上，还是有些问题需要解决的，这主要就是 Kotlin Native 对于 iOS 的支持的问题，例如：</p><ol><li>Kotlin Native 的并发模型比较严格，也正是如此，Kotlin 协程的 Kotlin Native 版本迟迟没有正式推出多线程版本，在 iOS 上使用 Kotlin 协程目前还受制于所调用的 API 是否本身已经自己支持了异步以及回调的线程切换。</li><li>Kotlin 目前尚不能像在 Android 上那样全面替代 Java，从目前以导出 Framework 的方式引入 iOS 工程的做法来看，Swift 和 Objective-C 暂时还是无法完全干掉的。</li><li>Kotlin Native 可用的框架目前仍然比较少，如果想要编写 Kotlin 多平台的代码，也需要我们引入的框架支持 Kotlin 多平台，例如序列化框架可选的目前主要就是官方的 kotlinx-serialization，时间框架主要也是官方提供的 kotlinx-datetime 等等。</li></ol><p>不过这倒也不算什么大问题，毕竟才刚刚开始，Kotlin Native 的并发模型的问题以及 Kotlin Native 开发 iOS 的支持问题都在逐渐优化。</p><p>至于依赖框架的问题，这恰恰也是 Kotlin 的生存哲学之一，Kotlin 游走与各个平台上，一向是以充分利用所在平台的优势为基础的。我们且等它把这些平台的基础 API 进行统一封装，以方便我们实现逻辑层的一致性。</p><p>再稍微提一下，KMM 插件尽管支持了很多功能，但对于 iOS 工程却仍然不能有效支持，这主要体现在对于 Swift、Objective-C 的代码无法高亮、调试等问题上，如果需要编辑 SwiftUI 或者其他使用 Swift 编写的代码模块，还是需要在 Xcode 当中完成。至于将来会不会支持，这一点目前还没有确切的消息。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>Kotlin 1.4 发布了两个月，整体反应来看，大家还是比较平静的，因为这次确实出了 SAM 转换让人期待已久以外，别的都不是很以外。不过，从最近发生的这些变化来看，Kotlin 的将来还是值得期待一下的，至少，它已经找到了自己的路，并开始一步一步走下去了。</p><hr><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-34-14.png" alt=""></p><p>最后再提一句，国外疫情肆虐，KotlinConf 今年没法线下开展，这不，也改成线上了。大家可以在 <a href="https://kotlinlang.org/lp/event-14/" target="_blank" rel="noopener">Kotlin 1.4 Online Event</a> 这个地址找到所有的视频，内容还是值得了解一下的。</p><p>当然，视频直接收看可能需要一些操作，后面的话我看看能不能跟官方的小伙伴商量下尽快搬到国内的视频平台上。此外，我们目前也在准备后面结合这次 Kotlin 的 Event 在国内做一些分享，届时也会通过公众号发布具体的安排，请大家留意~</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Kotlin 的发展可以认为是正式进入了下一个阶段。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="news" scheme="https://www.bennyhuo.com/tags/news/"/>
    
  </entry>
  
  <entry>
    <title>闲聊 Kotlin-Native (0) - 我们为什么应该关注一下 Kotlin Native？</title>
    <link href="https://www.bennyhuo.com/2020/07/15/kotlin-native-introduction/"/>
    <id>https://www.bennyhuo.com/2020/07/15/kotlin-native-introduction/</id>
    <published>2020-07-14T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直想写点儿 Kotlin-Native 相关的话题，今天开始~</p></blockquote><a id="more"></a><h2 id="尴尬的-Kotlin-Native"><a href="#尴尬的-Kotlin-Native" class="headerlink" title="尴尬的 Kotlin-Native"></a>尴尬的 Kotlin-Native</h2><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-41-58.png" alt=""></p><p><strong><center>官方题图：Kotlin-Native 的世界</center></strong></p><p>Kotlin-Native 的定位略显尴尬，为什么这么说呢？ 因为现在的编程语言实在太多了，新语言出来必然要解决现有某个语言的痛点，这样才能快速切入该语言所覆盖的领域。Kotlin 也是这样在当年崭露头角的，要不是 Android 上没有很好的替代语言，估计 Kotlin 也不会这么快进入大家的视野。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-44-05.png" alt=""></p><p><strong><center>2017 年 Google IO 大会宣布 Kotlin 称为 Android 一级开发语言</center></strong></p><p>说到这里问题就来了， Kotlin-Native 的目标用户到底是谁呢？</p><p>编译成机器码可以直接在原生环境中运行，我首先能想到的自然是 C 语言。可真的是要去替代 C 吗？显然不可能，毕竟没有 Go 跑得快，用 Go 来替代 C 语言似乎更说得过去。</p><p>当然有专家尝试用 Go 写了个操作系统发现 Go 的 GC 时间的不确定性会给系统的运行带来一些问题。那没关系啊，对于实时性要求高的场景可以换 Rust 嘛，至少微软已经决定要这么做了，Rust 可以精准控制内存的管理，这一点到现在可能还真没有哪一门语言与之媲美，也难怪它最近几年这么火。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-17-42-11.png" alt=""></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-47-36.png" alt=""></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-48-03.png" alt=""></p><p><strong><center>2020.07 TIOBE 编程语言排名：C:1，Go:12，Rust:18，Kotlin:27</center></strong></p><p>就算将来 Kotlin-Native 在性能上也优化到 Go 和 Rust 的水平，考虑到它的 Java 背景， C 和 C++ 的程序员可能也不太愿意接受这样一个“外来户”。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-49-01.png" alt=""></p><p><strong><center>Java 跟 C++ 的火拼现场，PHP 或成最大受害者</center></strong></p><p>那 Kotlin-Native 就这么凉了？</p><p>据我观察它的目标用户群体至少应该不是 Java 开发者，因为 Java 开发者只有在写 JNI 的时候才会有 Native 代码开发的需要，而 Kotlin-Native 做了 C-interop 就去做 Objective-C 的 interop，很多人开 issue 问官方要不要搞一个简化 JNI 调用的功能，官方的答复竟然是“为啥不直接在 Java 虚拟机上写 Kotlin 呢？” 。</p><p>不过说到这儿似乎官方的意图很明显了，就是要去拉拢 iOS 的开发了，但高傲的 iOS 开发者们会这么轻易被收买吗？Hmmm，我突然想到了之前跟某位大哥聊天，他说搞 Flutter 的基本上都是 Android 转的，所以。。Kotlin-Native 的实际目标用户群体还是 Android 开发者，只不过是在他们的老板裁掉同组的 iOS 开发之后或者。。。（啊，我是不是说太多了！）</p><p>这么说来接下来我写的这系列 Kotlin-Native 的文章的目标用户还是 Android 开发者为主的 Kotlin 开发者。</p><p>当我跟几个小伙伴说了我的下一步的想法，《Kotlin 编程实践》的译者禹昂就打趣到：“你的协程书还没看完呢，跟不上了啊。” 没事儿没事儿，Kotlin 的版本更新已经算是很慢的了，我也会尽量让自己的文章更新的慢一点儿（似乎找到了一个很好的拖更的理由！）。</p><h2 id="为什么我们需要了解下-Kotlin-Native"><a href="#为什么我们需要了解下-Kotlin-Native" class="headerlink" title="为什么我们需要了解下 Kotlin-Native"></a>为什么我们需要了解下 Kotlin-Native</h2><h3 id="零成本多平台抽象"><a href="#零成本多平台抽象" class="headerlink" title="零成本多平台抽象"></a>零成本多平台抽象</h3><p>前面我们的分析大致可以得出结论：Kotlin-Native 似乎也就是在 iOS 上有些前途。然而现实可能更残酷，因为可能大多数 App 根本没有什么逻辑，用 Flutter 跨平台岂不是更好，为什么还要搞 Kotlin-Native 呢？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-15-10-16-22.png" alt=""></p><p>原因也很简单，与 Flutter 的定位不同，Kotlin-Native 给予了我们开发者更多的可能。Kotlin 的设计思路其实一直都是这样，给开发者或者社区留足发挥的空间，做好语言应该做的事儿。类似的还有协程的设计，语言层面打好基础你就可以在框架层面造出各种飞机大炮。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-53-40.png" alt=""></p><p><strong><center>Kotlin 在 Android &amp; iOS 上共享逻辑</center></strong></p><p>用 Kotlin 的多平台特性，其实我们完全可以抽象出一套 UI 框架，用相同的 API 在不同的平台上使用各自的 UI 控件。这似乎有点儿像 React Native？对，思路完全一样，不同之处在于 Kotlin 没有额外的开销，Android 上 Kotlin 代码就是原生的代码，iOS 上 Kotlin-Native 与 Swift 编译出来的机器码没有任何实质上的区别。实际上已经有牛人开发了这样一个框架了，有兴趣的同学可以了解下：<a href="https://github.com/icerockdev/moko-widgets" target="_blank" rel="noopener">moko-widgets</a>。</p><p>官方在这方面也是非常努力的，从 1.4 预览版就开始都支持 Swift 调用 suspend 函数了，我倒是很期待 Android Studio 直接开发 iOS 的事儿。这也真不是我瞎说，Kotlin 之父在 Kotlin Conf 上自己说的，1.4 官宣发布的时候又再次提到了这一点，而且 JetBrains 全家桶里面本来就有 AppCode 用来开发 Apple 体系下的应用，整合一下应该不是什么难事，工作量问题吧。</p><p>你可以在不同的平台上做抽象，而这根本没有什么成本，不仅仅在 Android 与 iOS 上。我注意到最近关于 Rust 写前端的文章尤其多，其实就是因为 Rust 支持编译成 WASM 跑在支持它的浏览器上，Kotlin-Native 又何尝不可呢。</p><p>不仅如此，Kotlin-Native 现在的开发体验已经比以前强太多了，标准库虽然还比较小，不过至少基本的集合框架类都是有的，字符串之类的支持也都是有的。没有的我们自己用 C 接口包装一下也不是什么事儿对吧，照着 JDK 的 API，用 MPP 的特性自己实现其他平台的，似乎也不是什么不可能的事儿。还真有人在尝试这么干，不信大家瞧瞧这里：<a href="https://github.com/caffeine-mgn/pw.binom.io" target="_blank" rel="noopener">pw.binom.io</a>，使用这个框架可以在它支持的所有平台上写出下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = <span class="string">"Simple Text"</span>.asUTF8ByteArray()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> file = File(<span class="string">"Simple File"</span>)</span><br><span class="line">    FileOutputStream(file, <span class="literal">false</span>).use &#123;</span><br><span class="line">        it.write(<span class="keyword">data</span>, <span class="number">0</span>, <span class="keyword">data</span>.size)</span><br><span class="line">        it.flush()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"Write data: \"<span class="subst">$&#123;data.asUTF8String()&#125;</span>\""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">out</span> = ByteArrayOutputStream()</span><br><span class="line">    FileInputStream(file).use &#123;</span><br><span class="line">        it.copyTo(<span class="keyword">out</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"Read data: \"<span class="subst">$&#123;out.toByteArray().asUTF8String()&#125;</span>\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子告诉我们 Kotlin 的这个特性为我们提供了把任意它支持的平台当做我们最熟悉的那个平台来开发的机会。</p><h3 id="多平台特性的持续优化"><a href="#多平台特性的持续优化" class="headerlink" title="多平台特性的持续优化"></a>多平台特性的持续优化</h3><p>1.4-M2 开始支持结构化多平台特性，也就是大佬们经常提到的 HMPP。</p><p>多平台代码之间之前只有 common 部分是可以共享的，但这显然不够，例如 Linux 的各种衍生版本之间还可以共享一部分代码，之前不能，现在终于可以了。</p><p>这个特性咱们普通开发者可能感受不是特别明显，不过你很难想想框架开发的大佬期待这个特性期待了多久，协程框架马上就用这个特性把多线程的能力做了抽象，等后面达到一个相对稳定的状态之后也许你就会发现 Jvm 和 Native 上的多线程抽象居然用的是同一套代码，不同的就是各自的线程的具体 API 的使用。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-07-51-38.png" alt=""></p><p><strong><center>结构化多平台特性示意图</center></strong></p><p>1.4 发布之后，多平台特性官宣进入 alpha 阶段，尽管还不是 release 的状态，但也是 release 倒计时了。客观的讲，多平台相关的绝大多数 API 经过几轮大规模迭代，已经进入较为稳定的状态，之所以还称为 alpha，估计是部分平台的周边支持例如 kotlin-js 的 dukat 还在快速迭代当中。</p><p>多平台的重大意义在于 Kotlin 生态的建立。一旦这个特性扶正了，那 Kotlin 跨平台的框架生态发展可以直接得到提速，框架的开发者可以花更低的成本开发全平台适用的 Kotlin 框架，生态好才是王道。</p><h3 id="“新基建”的时代背景"><a href="#“新基建”的时代背景" class="headerlink" title="“新基建”的时代背景"></a>“新基建”的时代背景</h3><p>前面我们已经看到 C 语言又力压 Java Python 夺得榜首，因为物联网？因为 5G？因为新基建？反正这几年公司项目的原因接触了不少智能硬件相关的团队和公司，虽然 Android 开始逐渐进入大家的视野，但厉害点儿的硬件还是用 Linux 直接开发。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-22-06-10.png" alt=""></p><p><strong><center>4G 时代为消费互联网的繁荣提供了土壤，而 5G 时代下的赢家又是谁？</center></strong></p><p>过去的十年迅猛发展的手机性能极大的改善了我们的生活，而现在手机的发展似乎除了大屏和高性能已经没有什么新意了，互联网的浪潮也早已没有了昔日的疯狂。</p><p>说到这儿，想起一个有趣的故事。我曾听曾经在 3W 咖啡馆工作的师兄讲那会儿有人在大冬天极冷的条件下坐在外面干活，想要以此证明他顽强的毅力来吸引投资人的注意。现在想想真是不可思议。那个年代只要会写 APP 就能进大公司，现在遍地都是会写 APP 的，你的竞争力体现在哪里呢？</p><p>现在很多时候我们要解决的需求大不再是简单的写个 APP 那么简单，搭配硬件已经是常规操作。IoT 在 5G 背景下可以实现高速率、低延时的远程控制和更多设备的接入，专业领域的小系统在这方面有着天然的优势。</p><p>而硬件厂商通常有着多年的 Linux 系统开发的经验积累，同时又对 Android 系统在此类场景下的稳定性表现出了极大的不信任。开发者在这个时代背景下想要脱颖而出，C 语言功底总要有吧？了解下 Kotlin-Native 还能顺带提高一下 C 的水平，与自己现有技术栈也能充分结合起来，甚至还可以把以前运行在其他平台的逻辑轻松地移植过来，何乐而不为呢。</p><h2 id="我们该怎么学习-Kotlin-Native-呢？"><a href="#我们该怎么学习-Kotlin-Native-呢？" class="headerlink" title="我们该怎么学习 Kotlin-Native 呢？"></a>我们该怎么学习 Kotlin-Native 呢？</h2><p>先了解下 Kotlin-Native 需要的背景知识。</p><ol><li>扎实的 Kotlin 语法基础。这一点只要是习惯了使用 Kotlin 开发 Android 应用的开发者，一般来讲问题不大。语法上 Kotlin 不管是在哪个平台，包括 Kotlin-js，差异几乎可以忽略。</li><li>C 语言背景。学习 Kotlin-Native 之前掌握 C 语言是必要的，这与我们开发 Kotlin-Jvm 程序需要先了解 Java 及其生态是一样的道理。</li></ol><p>有了这两点基础，在学习的过程中就基本上不会有太大的障碍了。</p><p>接下来就是搞清楚自己的需求。学习 Kotlin-Native 的目的是什么呢？如果是开发一款与 Android 共享部分代码的 iOS 应用来实践 Kotlin 跨平台的特性，那么你还需要对 Objective-C 或者 Swift 有一定的了解。</p><p>或者你想要了解一下 Kotlin-Native 的垃圾回收机制，对比下与 C++ 的智能指针、Rust 的内存管理甚至与 JVM 的内存垃圾回收机制的区别，那你就要去啃一下 Kotlin-Native 的源码了。</p><p>说了这么多，我后面的文章大概会写点儿什么内容呢？</p><ol><li>Kotlin-Native 编译逻辑以及工程的搭建。这个是必不可少的，而且这块儿还稍微有点儿复杂。幸运的是 Gradle 也支持 Kotlin 脚本，所以我们不必再忍受 Groovy 的动态特性的摧残。</li><li>Kotlin-Native 组件的发布逻辑。也许我们将来会考虑自己发一款跨平台的框架来取悦自己，所以这个也是很重要的。</li><li>Kotlin-Native 与其他语言的互调用，主要是 C 和 Objective-C（Swift）。当然，我们也可以尝试通过 C 接口调用一下 Python 或者 Lua，甚至是 JNI。</li><li>研究一下 Kotlin-Native 的运行机制，目前能想到的主要就是内存管理吧。</li><li>协程在 Kotlin-Native 上对于并发的支持。</li><li>Ktor 上 CIO 对 Kotlin-Native 的支持。目前这个特性还在开发中，CIO 已经对 JVM 做了支持，我也在《深入理解 Kotlin 协程》当中稍微做了介绍，不过跨平台版本应该很值得期待。</li></ol><p>其他。。。我还没有想到，先挖这么多坑吧，后面慢慢填。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章算是这一系列的先导篇吧，谢谢大家的关注，咱们下一篇再见。</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;一直想写点儿 Kotlin-Native 相关的话题，今天开始~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="native" scheme="https://www.bennyhuo.com/tags/native/"/>
    
  </entry>
  
  <entry>
    <title>我写了一本书，《深入理解 Kotlin 协程》</title>
    <link href="https://www.bennyhuo.com/2020/06/23/understanding-kotlin-coroutines/"/>
    <id>https://www.bennyhuo.com/2020/06/23/understanding-kotlin-coroutines/</id>
    <published>2020-06-22T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.219Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没想到 Kotlin 的协程居然会成为一个有争议的话题，谁让官方材料太少呢。</p></blockquote><a id="more"></a><p>Kotlin 从 1.1 开始推出协程特性，当时还是实验性质的特性。</p><p>我研究 Kotlin 协程的过程其实主要分了三个阶段。</p><p><strong>第一个阶段，深入理解 Kotlin 协程的三篇文章</strong>。翻了翻过去的文章记录，我在 2017 年 1 月当时 Kotlin 1.1-beta 刚刚发布之时就发布了第一篇介绍协程的文章<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483875&amp;idx=1&amp;sn=b1b565f651ee1221d4bda19ab12009ce&amp;chksm=e8a05ededfd7d7c878c1c483c577ec53bcf42ee4cb0fe5d13f29d12ff62a1e335c4afa616ffa&amp;token=10610078&amp;lang=zh_CN#rd" target="_blank" rel="noopener">深入理解 Kotlin Coroutine （一）</a>，主要介绍了协程的标准库的 API，以及简单的协程封装思路。随后在那年的春节发了第二篇<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483878&amp;idx=1&amp;sn=710189e6e22a13fc7d1ea67bc2dd9270&amp;chksm=e8a05edbdfd7d7cd163ee1a2d5769fc2bf003e2d5a6d3f9c6382531b7efc22a6ab75300bb906&amp;token=10610078&amp;lang=zh_CN#rd" target="_blank" rel="noopener">深入理解 Kotlin Coroutine (二）</a>，介绍协程的框架 kotlinx.coroutines 的一些功能，当时这个框架还非常的小，源码很容易就能够通读完，与现在简直不可同日而语了。期间也搞了一些线下的活动来分享协程的用法和作用，在 1.1 正式发布不久之后又写了一篇介绍协程的使用场景的文章<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247484000&amp;idx=1&amp;sn=12f6a010c6fb554b94f68fd5ab6f941e&amp;chksm=e8a05d5ddfd7d44b66c354041fd5f330a297c42b8d451f0b1f38676e83018263b2200c60be57&amp;token=10610078&amp;lang=zh_CN#rd" target="_blank" rel="noopener">深入理解 Kotlin Coroutine（三）</a>。</p><p><strong>第二个阶段，<a href="https://github.com/enbandari/CoroutineLite" target="_blank" rel="noopener">CoroutineLite</a></strong>。这是我仿照官方协程框架 kotlinx.coroutines 的 API 自己实现的一套协程框架，目的主要是为了教学和研究，因此代码编写时主要考虑的目标是可读性，与官方框架追求性能的实现有着本质的不同。当然，这个框架的实现只包括了最基本的内容，像 Channel、Flow 这样更上层的组件便没有提供了。这个框架最初是在我在制作<a href="https://coding.imooc.com/class/232.html" target="_blank" rel="noopener">基于GitHub App业务 深度讲解 Kotlin高级特性与框架设计</a> 这门视频课程时开发的，由于当时 Kotlin 的版本是 1.2，因此视频当中提及的 CoroutineLite 还是一个雏形，直到我去年重制<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">Kotlin从入门到精通</a>和编写<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>时，才为它添加了作用域、取消支持等功能，并进一步的完善很多细节上的设计。这个框架目前已经开源，希望它能够帮助各位读者更好的了解 Kotlin 协程的内部运行机制，这是必要的，也是必须的。</p><p><strong>第三个阶段，破解 Kotlin 协程系列文章</strong>。这几年在帮助大家学习 Kotlin 的过程中，我发现大家对于协程逐渐产生不解、害怕甚至是不屑等各种各样的情绪，一方面是因为 Kotlin 的大部分受众源自于 Android 开发者群体，Android 开发者群体如果从一开始就在这个小圈子内成长的话，确实没有什么机会接触到协程。我自己也是 Android 开发，能够深刻的体会到 Android 技术圈子的局限性，只不过我有幸有机会多接触了几门语言和应用领域。这一系列文章就是想直接基于 Kotlin 1.3 以来已经成熟的生态和框架来介绍 Kotlin 协程，一写就是十几篇，我制作了一个文章合集，有兴趣的朋友可以参阅：<a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTYzOTYzNA==&amp;hid=4&amp;sn=eb02d1dc6f5d92096f214688c6f87196" target="_blank" rel="noopener">Kotlin 协程文集</a>。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-50-26.png" alt=""></p><p><strong><center>视频课程“Kotlin从入门到精通”中对协程的剖析</center></strong></p><p>现在，我把前面的这些积累以及在于大家交流过程中发现的问题进行了分析和整理，参考了各家语言对于协程的实现，系统地剖析了 Kotlin 协程的方方面面，编撰成了这样一本《深入理解 Kotlin 协程》的书籍。</p><p>这本书主要回答了以下几个常见的问题：</p><ol><li>协程是什么？Kotlin 协程又是什么？</li><li>Kotlin 协程的工作机制是怎样的？</li><li>如何将 Kotlin 协程投入生产实践当中？</li></ol><p>不仅如此，本书还致力于让大家能够自己尝试动手实现自己的协程框架，成为深谙 Kotlin 协程之道的高手，这样才配得上“深入理解”这个标题。</p><p>还有一个小细节。本书印刷版中所有的代码都采用了 JetBrains Mono 这个字体，插图的文字也是如此。另外，本书代码缩进采用了 2 个空格的样式，目的也是为了减少折行，提高版面的空间利用率，进而提升阅读体验。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-06-10-23-25.png" alt=""></p><p><strong><center>使用 JetBrains Mono 排版的代码效果</center></strong></p><p>书的编写过程也比较有意思。我是用 VSCode + Pandoc + graphviz + mermaid.js + plantUML + rx-marbles 等工具来编写的。其中，使用 VSCode 处理文字内容；使用 Pandoc 将 md 文件编译成 docx 文件；使用后面的四个工具来绘制插图 —— 它们实际上是将源码编译成图片的处理工具。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-39-57.png" alt=""></p><p><strong><center>《深入理解 Kotlin 协程》的插图制作</center></strong></p><p>环境的配置，以及对这些工具的定制花去了我将近两个月的业余时间。除了使用 Haskell 编写的 Pandoc 的插件 cross-ref 我实在无法快速上手以外，我学习到了如何使用 Python 和 Lua 编写用来在编译过程中处理图片生成逻辑和文字预处理的 Pandoc 过滤器，以及如何通过修改源码解决 plantUML、mermaid.js、rx-marbles 的样式定制和字体的支持的问题，最后还借机学会了如何制作 docker 镜像。</p><p>当然，我在本书写作过半之时，突发奇想开始学习双拼输入法，刚开始的那一段时间曾一度因为不知道如何打字而憋得着急上火，不过那时的感觉像极了十几年前在大学里刚买电脑之后连 QQ 都聊不明白的光景，自己似乎又年轻了一回。</p><p>可以说，这一本书的编写过程，除了促使我对 Kotlin 协程有了一个更加宏观的概念把控之外，我还学到了非常多有意思的东西。</p><p>当然，除了有意思之外，在写作的过程中我也确实无数次感觉到了对文字细节的疲惫，但一次次的修改和校对之后又觉得非常值得。</p><p>感谢这样的一个机会，在这不平凡的 2020 年里，我写了一本书 ：）</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;没想到 Kotlin 的协程居然会成为一个有争议的话题，谁让官方材料太少呢。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>C 语言版的 println？</title>
    <link href="https://www.bennyhuo.com/2020/06/14/c-println/"/>
    <id>https://www.bennyhuo.com/2020/06/14/c-println/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 当中的 println 非常好用，可是 C 当中我们常用的 printf 却总是需要格式化字符，并且需要手动提供换行符。</p></blockquote><a id="more"></a><p>我们在 Kotlin 当中想要输出一个变量，直接调用 println 即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">"bennyhuo"</span></span><br><span class="line">println(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> age = <span class="number">30</span></span><br><span class="line">println(age)</span><br></pre></td></tr></table></figure><p>不管什么变量类型，println 一律照单全收，是不是很方便？</p><p>而我们的 C 语言呢，想要打印个变量可就没那么轻松了，不仅如此，换行符都得我们手动输入，如果能同时打印出对应的代码文件和行号查问题就更方便了。</p><p>有没有什么办法解决这些问题呢？</p><h2 id="问题一：自动换行"><a href="#问题一：自动换行" class="headerlink" title="问题一：自动换行"></a>问题一：自动换行</h2><p>printf 是不会自动换行的，因此每次我们都需要在格式化字符串当中加一个 <code>\n</code>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, age);</span><br></pre></td></tr></table></figure><p>解决换行的问题很简单，我们只需要定义一个函数 printlnf，在打印了需要打印的内容之后跟一个换行符的输出即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlnf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    <span class="built_in">vprintf</span>(format, args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里打印换行符比较容易理解，不过对于变长参数的处理就有点儿晦涩了，至少不像我们在 Kotlin 当中可以直接拿到一个数组来处理变长参数。</p><p>在 C 当中，我们无法知道有多少个变长参数，通常支持变长参数的函数需要通过前面的固定的参数来携带这个信息，例如 printf 可以通过格式化字符串 format 当中的格式符来判定后面有多少个参数。好在我们在这个场景下只要能把 println 的变长参数透传给 printf 就行了（当然我们实际上是透传给了 vprintf），多少个其实我们可以不关心。按照 C 标准的提供的方法，我们可以使用 <code>va_list</code> 来承载变长参数的值，使用 <code>va_start</code> 和 <code>va_end</code> 来获取和清除变长参数，vprintf 实际上就是 printf 的一个变种，它可以直接接受 <code>va_list</code> 类型的参数做为后面需要被格式化的参数。</p><p>用法起来嘛，还是可以的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printlnf(<span class="string">"%d"</span>, <span class="number">5</span>); <span class="comment">// 5\n</span></span><br></pre></td></tr></table></figure><p>不过实话这个函数定义并不是很美，看着太长了。</p><p>在 C 语言当中，还有一套强大的预处理机制，如果我们用宏来实现 printlnf，效果会怎样呢？（我似乎想到了 rust 的 println!）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printlnf(format, ...) printf(format<span class="meta-string">"\n"</span>, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><p>额，用宏实现就这么简单？</p><p>首先我们注意一下 <code>format&quot;\n&quot;</code>，这个语法特别有意思，在 C 当中我们可以直接拼接字符串字面量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *name = <span class="string">"benny"</span><span class="string">"huo"</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">"bennyhuo"</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>1 和 2 是等价的，字面量连接在一起可以直接实现拼接的效果。那么我们定义的宏当中 format 如果是一个字符串字面量的话，自然就能实现拼接效果了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printlnf(<span class="string">"Hello %s"</span>, <span class="string">"C"</span>);</span><br></pre></td></tr></table></figure><p>经过编译器预处理之后展开宏得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello %s"</span><span class="string">"\n"</span>, <span class="string">"C"</span>);</span><br></pre></td></tr></table></figure><p>所以换行的问题就解决了。当然，宏的这个实现方案有个缺点，format 必须是字符串字面量，下面的用法是错误的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *format = <span class="string">"Hello %s"</span>;</span><br><span class="line">printlnf(format, <span class="string">"C"</span>); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>因为宏展开以后得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *format = <span class="string">"Hello %s"</span>;</span><br><span class="line"><span class="built_in">printf</span>(format<span class="string">"\n"</span>, <span class="string">"C"</span>); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>不管怎样，我们总是可以在一定的场景下通过上面的实现来解决为 printf 自动追加一个换行符的问题。</p><h2 id="问题二：支持非字符串类型直接打印"><a href="#问题二：支持非字符串类型直接打印" class="headerlink" title="问题二：支持非字符串类型直接打印"></a>问题二：支持非字符串类型直接打印</h2><p>C 毕竟不是面向对象的语言，我们也很难说有一个统一的办法把所有的结构体转成字符串（字符数组），因此我们的要求也不高，对于基本类型，可以实现类似下面的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>这要是在 C++ 当中，我们直接重载一下这个函数即可，但 C 语言不支持啊（实际上 C++ 的重载会用参数类型去修饰函数名来生成最终的函数符号），不过 C11 新增了一个特性 <code>_Generic</code>，可以支持泛型！</p><p>妈呀，C 语言居然也有泛型，惊喜不惊喜！让我们来看看它的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = _Generic(x,</span><br><span class="line">        <span class="keyword">int</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="keyword">double</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="keyword">char</span> * : <span class="number">4</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们可以把它当做一个特殊的函数，第一个参数 x 是需要提取类型的变量，第二个参数则是一个类似于 switch case 的分支语句，如果 x 是 int 类型，那么返回值就是 2，如果是 double 类型，那么返回 3，等等。</p><p>不得不说，这语法中透露着年代感。但不管怎样，总算能用。</p><p>我们来试着考虑实现一个 println 的函数或者宏，不过很快我们就会发现函数是无法实现的，只能使用宏。为什么呢？因为这里的参数 x 的类型是需要在编译的时候确定的，如果我们试图实现 println 函数的话，那么参数的类型要怎么定义呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(??? format, ...)</span> </span>&#123;</span><br><span class="line">  _Generic(format, ...);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设将 format 定义为 <code>char*</code> 类型，那么泛型的判断豪无意义，因为 <code>_Generic</code> 永远会选择 <code>char*</code> 分支的返回值。</p><p>既然如此， format 就不能有类型咯。谁的参数可以没有（或者不能有）类型？宏呗。所以我们只好实现一个宏版本的 println 了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println(X) _Generic((X),  \</span></span><br><span class="line">    <span class="keyword">int</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, X), \</span><br><span class="line">    <span class="keyword">float</span>: <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, X), \</span><br><span class="line">    <span class="keyword">char</span> *: <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, X), \</span><br><span class="line">    <span class="keyword">double</span> : <span class="built_in">printf</span>(<span class="string">"%0.4f\n"</span>, X) \</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>这当中可以支持更多的类型，我们就举上面的几个为例。具体用法呢：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="built_in">println</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">println</span>(<span class="number">0.3</span>);</span><br><span class="line"><span class="built_in">println</span>(<span class="number">34.0f</span>);</span><br></pre></td></tr></table></figure><h2 id="问题三：打印文件名和行号"><a href="#问题三：打印文件名和行号" class="headerlink" title="问题三：打印文件名和行号"></a>问题三：打印文件名和行号</h2><p>C 当中提供了两个宏：</p><ul><li><code>__FILE__</code>：展开之后就是文件的全路径（具体结果当然也跟编译器实现和参数有关系）。</li><li><code>__LINE__</code>：展开之后就是所在的源代码文件行的行号，是个整型。</li></ul><p>有了这两个宏，那么实现这个功能也就不难做到了。</p><p>首先需要考虑的就是用函数实现还是用宏实现的问题。由于需要打印调用点的位置，而函数的实现会影响调用栈，因此这里使用只能宏来实现。宏调用会直接展开在调用处，因此行号和文件名都是正确的结果，实现方式也比较简单，我们给出 printlnf 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printlnf(format, ...) printf(<span class="meta-string">"(%s:%d) "</span>format<span class="meta-string">"\n"</span>, __FILE__, __LINE__, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><p>使用效果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printlnf(<span class="string">"%d"</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(C:\Users\bennyhuo\WorkSpace\Demos\HelloCInClion\main.c:48) 30</span><br></pre></td></tr></table></figure><p>如果大家使用 CLion 开发，可以直接点击输出的文件和行号跳转到对应的源码位置，方便吧。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们通过改造 printf，得到了两套实现，其中：</p><ol><li>在原有 printf 上增加换行，其他功能不变，得到 printlnf 函数和宏实现；</li><li>支持直接打印常见类型，得到 println 的宏实现。</li></ol><p>二者也都可以根据需要添加对文件名和行号的输出支持。</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Kotlin 当中的 println 非常好用，可是 C 当中我们常用的 printf 却总是需要格式化字符，并且需要手动提供换行符。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="c" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="macro" scheme="https://www.bennyhuo.com/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 为 Map 提供的那些默认值相关的扩展，你用过吗？</title>
    <link href="https://www.bennyhuo.com/2020/06/09/kotlin-map-default/"/>
    <id>https://www.bennyhuo.com/2020/06/09/kotlin-map-default/</id>
    <published>2020-06-08T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Map 的 Value 类型是一个可空类型，Kotlin 早就想好了怎么帮你优雅地面对它。</p></blockquote><a id="more"></a><p>Map 是我们经常用到的集合框架的一种，Java 标准库当中提供的 Map 的实现也是比较好用的。不过 Kotlin 为 Map 提供了几处默认值相关的扩展，让 Map 的使用变得更加轻松，不知道大家有没有注意到呢？</p><h3 id="1-getOrElse"><a href="#1-getOrElse" class="headerlink" title="1. getOrElse"></a>1. getOrElse</h3><p>这个比较简单，我们先来看下它的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;K, V&gt;</span>.<span class="title">getOrElse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="type">K</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">  defaultValue: () -&gt; <span class="type">V</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: V = <span class="keyword">get</span>(key) ?: defaultValue()</span><br></pre></td></tr></table></figure><p>如果没有元素 key，那么就返回默认值，默认值通过对参数中的 defaultValue 进行求值得到。当然，如果不需要默认值，那么这个求值过程也是不会发生的。</p><p>这种情况比较适合空值的语义与默认值相同的情况，例如我用 Map 中的值做为某种配置：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = HashMap&lt;String, <span class="built_in">Boolean</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> isEnabled = config.getOrElse(<span class="string">"isEnabled"</span>, &#123; <span class="literal">false</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="2-getOrPut"><a href="#2-getOrPut" class="headerlink" title="2. getOrPut"></a>2. getOrPut</h3><p>需要注意的是，getOrElse 的调用过程中 Map 没有被修改，即默认值并没有真正成为 Map 的元素。如果我们有下面的需求，那就要考虑使用 getOrPut 了：</p><p>我们有一个事件回调接口，不同事件用 eventId 来区分：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnEventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onEvent</span><span class="params">(eventId: <span class="type">String</span>, <span class="keyword">data</span>: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要提供对事件回调注册的能力：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> eventListeners = HashMap&lt;String, ArrayList&lt;OnEventListener&gt;&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addOnEventListener</span><span class="params">(eventId: <span class="type">String</span>, listener: <span class="type">OnEventListener</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 listener 的思路也很简单，先看看 eventListeners 当中有没有对应的 eventId 的事件回调 list，如果有，直接添加；如果没有，先构造一个 list 实例，然后再添加。所以最为朴素的实现就是下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addOnEventListener</span><span class="params">(eventId: <span class="type">String</span>, listener: <span class="type">OnEventListener</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> listenerList = eventListeners[eventId]</span><br><span class="line">    <span class="keyword">if</span> (listenerList == <span class="literal">null</span>) &#123;</span><br><span class="line">        listenerList = ArrayList()</span><br><span class="line">        eventListeners[eventId] = listenerList</span><br><span class="line">    &#125;</span><br><span class="line">    listenerList.add(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这个也太不 Kotlin 了。</p><p>好在我们有 getOrPut，它提供了在 Map 中不存在对应的 Key 时返回默认值并将默认值添加到 Map 中的能力，它的实现非常直接：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> MutableMap<span class="type">&lt;K, V&gt;</span>.<span class="title">getOrPut</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="type">K</span>, defaultValue: () -&gt; <span class="type">V</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: V &#123;</span><br><span class="line">    <span class="keyword">val</span> value = <span class="keyword">get</span>(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> answer = defaultValue()</span><br><span class="line">        put(key, answer)</span><br><span class="line">        answer</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然如此，我们就可以简化 addOnEventListener 的实现了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addOnEventListener</span><span class="params">(eventId: <span class="type">String</span>, listener: <span class="type">OnEventListener</span>)</span></span> &#123;</span><br><span class="line">    eventListeners.getOrPut(eventId, defaultCreator).add(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-隐式默认值"><a href="#3-隐式默认值" class="headerlink" title="3. 隐式默认值"></a>3. 隐式默认值</h3><p>除了在获取时才能确定的默认值以外，还有一个在 Map 定义的时候就可以指定的方式，即：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = HashMap&lt;String, <span class="built_in">Boolean</span>&gt;().withDefault &#123; <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure><p>这个也被称为隐式默认值，它的效果与 getOrElse 一致，在获取某一个不存在的 Key 时，直接返回默认值表达式的求值结果，在上面的例子当中就是 <code>{ false }</code> 的求值结果了。</p><p>不过如果大家用过这个功能的话，应该一开始都会感到比较疑惑，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEnabled = config[<span class="string">"isEnabled"</span>] <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>用于此时我们的 config 只是一个空 Map，因此不存在 <code>isEnabled</code> 这个 Key，按照我们的直觉，这时应该触发默认值的求值过程并返回 false 对吧？但实际上不是这样的，标准库 API 的设计者为了确保对应的实现复合 Map 的接口定义，在我们调用 Map 接口的方法时，行为与普通的 Map 保持一致，因此 <code>config[&quot;isEnabled&quot;]</code> 或者说等价的 <code>config.get(&quot;isEnabled&quot;)</code> 调用并不会触发默认值的求值。</p><p>那我想要获得默认值要怎么做呢？</p><p>调用另外的一个扩展方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEnabled = config.getValue(<span class="string">"isEnabled"</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="4-默认值的提供方式"><a href="#4-默认值的提供方式" class="headerlink" title="4. 默认值的提供方式"></a>4. 默认值的提供方式</h3><p>前面提到的三种方式中，默认值都是通过一个函数提供的，这样做有什么好处呢？</p><p>其实如果 Map 的 Value 类型是不可变的数据类型，那么直接使用一个默认值即可，例如 Boolean、String 这样的基本类型。但对于可变的类型，例如前面例子中的 ArrayList，提供统一的默认值显然是行不通的，对象被不同的 Key 共享必然会造成逻辑的混乱。</p><p>还有一个原因，函数可以共享，只需要创建一个统一的对象，每次使用的时候复用即可，默认值本身并不总是需要，自然也并不总是需要创建出来，因此这里采用延迟计算还可以减少对象创建的成本。</p><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><p>好啦，这一篇文章没有什么有难度的地方，源码大家一看就明白，使用时只要注意其中的细节即可。</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Map 的 Value 类型是一个可空类型，Kotlin 早就想好了怎么帮你优雅地面对它。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="map" scheme="https://www.bennyhuo.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin、Swift、Scala 的延迟求值</title>
    <link href="https://www.bennyhuo.com/2020/05/23/lazy-evaluation/"/>
    <id>https://www.bennyhuo.com/2020/05/23/lazy-evaluation/</id>
    <published>2020-05-22T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.222Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“懒”是程序员最优秀的品质之一，程序也是如此。</p></blockquote><a id="more"></a><p>Kotlin 当中的 Lazy 想必大家都已经非常熟悉了，它其实承载的功能就是变量的延迟求值。今天我们同样来对比一下其他语言对于类似功能的实现。</p><blockquote><p>最近在探索相同特性在不同语言中实现的对比的文章写作思路，如果大家觉得有收获，别忘了点个赞让我感受一下；如果觉得这思路有问题，欢迎评论留言提建议 ~~</p></blockquote><h2 id="Kotlin-的延迟求值"><a href="#Kotlin-的延迟求值" class="headerlink" title="Kotlin 的延迟求值"></a>Kotlin 的延迟求值</h2><p>Kotlin 最初亮相的时候，基于属性代理实现的 Lazy 就是最吸引人的特性之一。只有使用时才会初始化，这个看上去简单的逻辑，通常我们在 Java 当中会写出来非常啰嗦，延迟初始化也经常因为各种原因变成“忘了”初始化，导致程序出现错误。</p><p>这一切在 Kotlin 当中变得非常简单。Kotlin 的 Lazy 通过属性代理来实现，并没有引入额外的关键字，这一点似乎非常符合 Kotlin 的设计哲学（就像其他语言的协程都喜欢 async/await 关键字，而 Kotlin 只有一个 suspend 关键字就承载了及其复杂的逻辑一样）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lazyValue <span class="keyword">by</span> lazy &#123; </span><br><span class="line">    complicatedComputing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了可以用于变量声明，Lazy 也同样适用于函数传参，这一点非常重要，我们来看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">assertAllTrue</span><span class="params">(<span class="keyword">vararg</span> conditions: <span class="type">Lazy</span>&lt;<span class="type">Boolean</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> conditions.all &#123; it.value &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assertAllTrue 这个函数的目的是判断所有参数的条件都为真，因此如果其中有一个为假，那么后面的条件就不用计算了，这个逻辑类似于我们常见的 <code>&amp;&amp;</code> 运算中的逻辑短路。代码中，it.value 的 it 是 <code>Lazy&lt;Boolean&gt;</code> 类型，value 是 Lazy 的属性，我们可以通过这个属性来触发 Lazy 逻辑的运算，并且返回这个结果 —— Lazy 用作属性代理时逻辑也是如此。</p><p>接下来我们做下实验，首先定义两个函数用于提供条件值并通过打印输出来判断其是否被执行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">returnFalse</span><span class="params">()</span></span> = <span class="literal">false</span>.also &#123; println(<span class="string">"returnFalse called."</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">returnTrue</span><span class="params">()</span></span> = <span class="literal">true</span>.also &#123; println(<span class="string">"returnTrue called."</span>) &#125;</span><br></pre></td></tr></table></figure><p>接下来我们调用 assertAllTrue 来看看会发生什么：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertAllTrue(lazy &#123; returnFalse() &#125;, lazy &#123; returnTrue() &#125;)</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">returnFalse called.</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>不意外吧？我们还可以模拟 <code>||</code> 再实现一个类似的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">assertAnyTrue</span><span class="params">(<span class="keyword">vararg</span> conditions: <span class="type">Lazy</span>&lt;<span class="type">Boolean</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> conditions.any &#123; it.value &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要有一个为真就立即返回 true，后面的条件就不再计算了。大家可以自己试试给它传几个参数之后看看能得到什么结果。</p><p>简单来说，Kotlin 的 Lazy 是一个很普通的类，它可以承载 Kotlin 当中各种对于延迟计算的需求的实现，用在属性定义上时借用了属性代理的语法，用作函数参数时就使用高阶函数 lazy 来构造或者直接传入函数作为参数即可。</p><p>除了使用 Lazy 包装真实的值来实现延迟求值，我们当然也可以使用函数来做到这一点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">assertAllTrue</span><span class="params">(<span class="keyword">vararg</span> conditions: () -&gt; <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> conditions.all &#123; it.invoke() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，我们传入的参数就是一个函数，延迟计算的意图也更加明显：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertAllTrue(&#123; returnFalse() &#125;, ::returnTrue, ::returnFalse)</span><br></pre></td></tr></table></figure><p>对于符合参数类型要求的 returnTrue 和 returnFalse 这两个函数，我们既可以直接传入函数引用，也可以构造一个 Lambda 表达式来包装对它们的调用。传入函数作为参数来实现延迟计算是最基本的手段，其他语言的处理也无非就是在此基础上增加一些友好的语法，后面我们在 Scala 和 Swift 部分就可以看到。</p><h2 id="Scala-的延迟求值"><a href="#Scala-的延迟求值" class="headerlink" title="Scala 的延迟求值"></a>Scala 的延迟求值</h2><p>在 Scala 当中 lazy 是个关键字。而相比之下，在 Kotlin 当中我们提到 Lazy 是指类型，提到 lazy，则是指构造 Lazy 对象的高阶函数。</p><p>Kotlin 当中的 Lazy 用在定义属性时，只支持只读属性或变量上（也就是 val 修饰的属性或变量），这一点 Scala 的用法比较类似，下面是一个比较无聊的例子，不过倒是能说明问题：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeConsumingWork</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> stopTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"><span class="keyword">val</span> startTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">timeConsumingWork()</span><br><span class="line">println(stopTime - startTime)</span><br></pre></td></tr></table></figure><p>我们想要统计下 timeConsumingWork 这个函数的调用耗时，stopTime 虽然先调用，但因为有 lazy 修饰，实际上等号右面的表达式 <code>System.currentTimeMillis()</code> 并没有立即执行，反而是后定义的 startTime 因为没有被 lazy 修饰而立即计算出值。所以这个程序还真能基本正确地输出 timeConsumingWork 函数执行的耗时。</p><p>哇，这样看起来 Scala 使用 lazy 关键字定义属性的语法比起 Kotlin 要简单多了哎！不过换个角度，乍一看明明有一行代码放在前面却没有立即执行是不是会很怪呢？如果一时间没有注意到 lazy 关键字，代码阅读起来还真是有点儿令人迷惑呢。</p><p>我们接着看看函数参数延迟求值的情况。在 Scala 当中同样存在高阶函数，因此我们几乎可以依样画葫芦写出 assertAllTrue 的 Scala 实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertAllTrue</span></span>(conditions: (() =&gt; <span class="type">Boolean</span>)*): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    conditions.forall(_.apply())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>() =&gt; Boolean</code> 就是 Scala 中返回值为 Boolean 类型的函数类型，后面的 * 表示这是个变长参数；函数体当中我们对所有的条件进行遍历，并在 forall 当中调用 apply 来求出对应 condition 的值，这里的 forall 相当于 Kotlin 当中的 all，apply 相当于 Kotlin 当中函数的 invoke。</p><p>用法如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertAllTrue(returnFalse, returnTrue, () =&gt; returnFalse())</span><br></pre></td></tr></table></figure><p>注意到我们既可以直接把函数名作为值传入，这类似于 Kotlin 当中传入函数引用的做法，最后一个参数 <code>() =&gt; returnFalse()</code> 则是定义了一个 Lambda 表达式来包装到 returnFalse 函数的调用。</p><p>Hmmm，这么看起来跟 Kotlin 真是一模一样啊。</p><p>非也非也。Scala 的函数参数除了可以传递值以外，还有一种叫做传名参数，即仅在使用时才会触发求值的参数。我们还是以前面的 assertAllTrue 为例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertBothTrue</span></span>(left: =&gt; <span class="type">Boolean</span>, right: =&gt; <span class="type">Boolean</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    left &amp;&amp; right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可惜的是，Scala 的传名参数不支持变长参数，所以例子有点儿缩水，不过不影响说明问题。</p><p>函数体内的最后一行就是函数的返回值，所以 <code>left &amp;&amp; right</code> 的值就是 assertBothTrue 的返回值了；而 left 和 right 的参数类型长得有点儿奇怪，如果说它是 Boolean 吧，可它的类型前面还有个 <code>=&gt;</code>，说它是函数类型吧， <code>=&gt;</code> 前面也没有参数呀，而且用起来跟 Boolean 类型的变量看起来也没什么两样 —— 对喽，这就是传名参数，只有访问时才会计算参数的值，访问的方式与普通的变量没有什么区别，不过每次访问都会重新计算它的值，这一点又与函数的行为相同。</p><p>接下来我们看下怎么使用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertBothTrue(returnFalse(), returnTrue())</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><p>我们看到传参时也没什么特别之处，直接传就好了，与我们通常的认知的不同之处在于，assertBothTrue 调用时不会立即对它的参数求值，所以其实这样看起来确实不太直观（这大概是 Kotlin 设计者最不喜欢 Scala 的地方了。。）。</p><p>整体比较起来，Scala 对延迟求值做了语言级别的正式支持，因此语法上更省事儿，有些情况下代码显得也更自然。</p><p>哦，对了，例子缩水的问题其实也是有办法解决的，哪有 Scala 解决不了的问题呢。。。：）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanByName</span>(<span class="params">value: =&gt; <span class="type">Boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valueByName</span></span>: <span class="type">Boolean</span> = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertAllTrue</span></span>(conditions: <span class="type">BooleanByName</span>*): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    conditions.forall(_.valueByName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路也简单，既然 Scala 不支持把传名参数声明为变长参数，那么我们就换个其他类型，巧就巧在 Scala 还支持类型隐式转换，所以定义一个 BooleanByName 即可，这样我们调用 assertAllTrue 传的参数就可以是 Boolean 类型的表达式，编译器会帮我们自动转换为 BooleanByName 类型丢给 assertAllTrue 函数。BooleanByName 中的 valueByName 是一个函数，Scala 当中对于不修改类内部状态的无参函数通常声明成没有括号的样子，这样的函数调用时如同访问属性一样（ 如代码中的 <code>_.valueByName</code>），这在 Kotlin 当中的等价写法就是一个没有 backingfield 的只读属性的 getter。</p><h2 id="Swift-的延迟求值"><a href="#Swift-的延迟求值" class="headerlink" title="Swift 的延迟求值"></a>Swift 的延迟求值</h2><p>最近比较喜欢 Swift，因为跟 Kotlin 长得像啊。不过随着了解的深入，发现二者虽然看起来很像，但用起来差异太大了，至少在延迟求值这个语法特性的设计上，Swift 形式上更像 Scala。</p><p>Swift 的 lazy 也是一个关键字，可以修饰类的属性，不过它不支持修饰局部变量，因此我们只能：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyDemo</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> value = complicatedComputing()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">complicatedComputing</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难想到，只要第一次访问 value 时，complicatedComputing 才会被调用。从延迟求值的角度来讲与 Scala 是没什么差别的，不过大家仔细看会发现我们声明属性时用的是 var，也就是说 value 是可变的，这与 Scala、Kotlin 都不一样。更有趣的是，如果我们希望 value 是只读的，将它的声明改为 <code>lazy let value = ...</code>，Swift 编译器会抱怨说 lazy 只能修饰 var。</p><p>纳尼？你们这些语言的设计者是怎么回事，意见居然这么不统一？</p><p>其实 Swift 当中对于变量的读写有更严格的设计，这一点从 struct 与 class 的差异就可见一斑。而 lazy 之所以只能修饰 var，原因也很简单，声明的时候 value 虽然还没有初始化，但在后续访问的时候会触发求值，因此存在声明之后再赋值的逻辑。Hmmm，这个赋值行为从语言运行的角度来讲确实如此，可是这个逻辑不应该对开发者是透明的么，为什么要让开发者操心这么多？</p><p>当然，如果想要保护 lazy 修饰的属性的写权限，可以考虑私有化 setter：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="built_in">lazy</span> <span class="keyword">var</span> value = ...</span><br></pre></td></tr></table></figure><p>但类内部仍然可以修改 value 的值，所以这个方法的作用也很有限。</p><p>接下来看下 Swift 当中函数参数的延迟求值。不难想到，我们将函数作为参数传入就可以实现这一点：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertAllTrue</span><span class="params">(<span class="number">_</span> conditions: <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span> ...) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    conditions.allSatisfy &#123; condition <span class="keyword">in</span> condition() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体上写法与 Kotlin 类似，不过有几个细节我们来解释下。</p><ul><li>参数 conditions 前面的下划线，一般语言的参数都只有参数名，也就是 conditions，Swift 还有一个参数标签的概念，用于函数调用时指定（其实我们在 Kotlin 当中调用函数时也可以在参数前加参数名，但作为位置参数时不强制），用下划线可以省略掉这个标签。</li><li><code>() -&gt; Bool</code> 表示 Swift 当中的函数类型，这与 Kotlin 的写法基本一致，后面的 … 则表示这个参数为变长参数。</li><li><code>{ condition in condition() }</code> 是 Swift 当中的 Lambda （在 Swift 当中称为 Closure，其实是一个东西），完整的写法是 <code>{ (condition: () -&gt; Bool) in condition() }</code>，不难看出，in 是用来分隔参数列表和表达式体的，condition 是参数，它的类型是 <code>() -&gt; Bool</code>。</li></ul><p>好，那我们下面调用一下这个函数试试看：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = assertAllTrue(&#123; returnFalse() &#125;, returnTrue, returnFalse)</span><br></pre></td></tr></table></figure><p>第一个参数使用 Lambda 表达式包装对 returnFalse 函数的调用；后面的两个参数直接使用函数名传入，这类似于 Kotlin 当中的函数引用的用法。结果不言而喻。</p><p>这么看来 Swift 也可以通过传入函数来实现延迟求值。有了前面 Scala 的经验，我们就不免要想，函数参数延迟求值的写法上能否进一步简化呢？答案是能，通过 @autoclosure 来实现。不过不巧的是 @autoclosure 也不支持变长参数（嗯？？这句话好像在哪儿听到过？），所以我们的例子就又缩水成了下面这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertBothTrue</span><span class="params">(<span class="number">_</span> <span class="keyword">left</span>: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>, <span class="number">_</span> <span class="keyword">right</span>: <span class="meta">@autoclosure</span> () -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">left</span>() &amp;&amp; <span class="keyword">right</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那调用时有什么不一样呢？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = assertBothTrue(returnFalse(), returnTrue())</span><br></pre></td></tr></table></figure><p>我们直接传入表达式，Swift 会帮我们用 <code>{}</code> 把它包装起来，换句话说，参数里面的 returnFalse 和 returnTrue 这两个函数只有用到的时候才会被调用。</p><p>简单总结一下，Swift 通过 lazy 关键字来实现类属性的延迟求值，这一点写法上虽然与 Scala 很像，但只能修饰类或结构体的成员，而且是可读写的成员；Swift 同样可以通过传入函数的形式来支持函数参数的延迟求值，可以通过 @autoclosure 来简化调用过程中参数的写法，这一点其实从形式上与 Scala 的传名参数类似。</p><h2 id="再来一个有趣的例子"><a href="#再来一个有趣的例子" class="headerlink" title="再来一个有趣的例子"></a>再来一个有趣的例子</h2><p>当语言设计地足够灵活，基于已有的语法经常也能造出“新特性”，接下来我们就造一个。</p><p>常见的语言当中都有 <code>while</code> 循环，为什么没有 <code>whileNot</code> 呢？聪明的我们想到了这一点，于是就开始造语法了。先来看看 Kotlin 怎么实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">whileNot</span><span class="params">(condition: () -&gt; <span class="type">Boolean</span>, action: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!condition()) &#123;</span><br><span class="line">        action()</span><br><span class="line">        whileNot(condition, action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">whileNot(&#123; i &lt; <span class="number">0</span> &#125;)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出就是 10 9 … 0</p><p>Scala 呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whileNot</span></span>(condition: =&gt; <span class="type">Boolean</span>)(action: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition) &#123;</span><br><span class="line">        action</span><br><span class="line">        whileNot(condition)(action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能让第二个参数用 <code>{ ... }</code> 以类似于 Kotlin 的方式传入，我们用柯里化的方式声明了这个函数，来瞧瞧用法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">whileNot(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>矮？是不是有那味了？这看着跟 while 已经没差了。</p><p>下面是 Swift 的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whileNot</span><span class="params">(<span class="number">_</span> condition: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>, <span class="number">_</span> action: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> !condition() &#123;</span><br><span class="line">        action()</span><br><span class="line">        whileNot(condition(), action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我似乎已经感觉到了那味儿~</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">whileNot(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么样，Swift 造出来的 whileNot 也几乎可以以假乱真了。</p><p>看来真的只有你家 Kotlin “稍逊一筹” 啊，条件那里还必须加个 <code>{}</code>，没有语法糖可以将这个去掉。不过，（咳咳，官方口吻）Kotlin 一向不喜欢偷偷摸摸的，我们必须要保留 <code>{}</code> 让你一眼就能看出来那是个函数，而不像某些语言搞得那么暧昧。</p><p>其实吧，单从这个例子的角度来讲，函数的参数类型声明还是挺清楚的，现在 IDE 这么牛逼，所以支持一下这样的特性算不算违反 Kotlin 的设计原则其实也不一定，不过目前看来这种不痛不痒的小特性还是算了吧，跨平台才是最牛逼的，加油 Kotlin，我等着 Android Studio 5.0 写 iOS 呢（zZZ）。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下：</p><ol><li>Kotlin 没有 lazy 关键字，通过属性代理实现只读属性的延迟求值，而 Scala 和 Swift 则通过 lazy 关键字来做到这一点</li><li>Kotlin 和 Scala 对于属性的延迟求值只支持只读属性，Swift 只支持可变属性</li><li>Kotlin 和 Scala 的延迟求值还支持局部变量，Swift 不支持。</li><li>他们仨都支持通过传入函数的方式来实现函数参数的延迟求值。</li><li>Scala 和 Swift 对函数参数延迟求值在语法上有更友好的支持，前者通过传名参数，后者通过 @autoclosure。</li><li>Kotlin 是唯一一个通过其他特性顺带支持了一下延迟求值的，这很符合 Kotlin 设计者的一贯做法（(⊙o⊙)…）。</li></ol><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;“懒”是程序员最优秀的品质之一，程序也是如此。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="scala" scheme="https://www.bennyhuo.com/tags/scala/"/>
    
      <category term="lazy" scheme="https://www.bennyhuo.com/tags/lazy/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 的 Property Delegate 与 Swift 的 Property Wrapper</title>
    <link href="https://www.bennyhuo.com/2020/05/08/kotlin-swift-property-delegate/"/>
    <id>https://www.bennyhuo.com/2020/05/08/kotlin-swift-property-delegate/</id>
    <published>2020-05-07T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.215Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Swift 的属性代理，见识一下</p></blockquote><a id="more"></a><p>Swift 想必大家都已经非常熟悉了，它是苹果公司推出的一门开源语言。Swift 与 Kotlin 几乎是同一段时间开始研发，也是前后呈现在公众面前。二者语法设计上有诸多相似之处，它们的关系让我甚至想到了当年的 Java 和 C#。更神奇的是，Kotlin-Native 居然支持了与 Objective-C 的互调用，进而也就相当于某种意义上支持了与 Swift 的互调用，这下它们就更亲密了。</p><blockquote><p>Swift：我不是我没有别瞎说。</p></blockquote><p>本文我们来聊聊二者的属性代理的设计和使用。通过对比，我们能够更加清楚的认识到属性代理的设计意图，以及其优势和不足，此外我们还能够了解更多属性代理这一语法特性的使用场景。</p><h2 id="Kotlin-的属性代理（Property-Delegate）"><a href="#Kotlin-的属性代理（Property-Delegate）" class="headerlink" title="Kotlin 的属性代理（Property Delegate）"></a>Kotlin 的属性代理（Property Delegate）</h2><p>我们先来简单回顾下 Kotlin 的属性代理的一些基础知识和应用场景。</p><h3 id="简化存储的读写"><a href="#简化存储的读写" class="headerlink" title="简化存储的读写"></a>简化存储的读写</h3><p>Kotlin 的属性代理算是大多数开发者在学习过程中会遇到的一个小难点。这其实让我一直都感到比较意外，因为属性代理本身应该是一个很自然的需求，例如我们经常在 Android 当中会读写 SharedPreference，一个 Key 对应于一个 Value，读写的过程高度相似且繁琐：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="comment">// write</span></span><br><span class="line"><span class="keyword">val</span> prefs = context.getSharedPreferences(prefName, Context.MODE_PRIVATE)</span><br><span class="line">prefs.putString(key, value)</span><br><span class="line">prefs.apply()</span><br><span class="line"></span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="keyword">val</span> value = prefs.getString(key, defaultValue)</span><br></pre></td></tr></table></figure><p>这当中还经常需要定义一堆常量作为 key 的值，无论从代码编写的舒适度上还是从代码的编写效率上来看都不是最理想的状态。</p><p>实际上，如果我们把 SharedPreference 看成是类似内存一样的存储空间，那么为什么我们不能像读写内存中的变量那样轻松自在呢？于是乎我们通过属性代理将 SharedPreference 的读写操作做一下封装，实现了使用对变量的读写方式来读写 SharedPreference 的效果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loginName <span class="keyword">by</span> pref(context, <span class="keyword">default</span> = <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// save "bennyhuo" as key "loginName"</span></span><br><span class="line">loginName = <span class="string">"bennyhuo"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// load key "loginName" from SharedPreferences</span></span><br><span class="line"><span class="keyword">val</span> currentLoginName = loginName</span><br></pre></td></tr></table></figure><p>请大家注意，<code>pref</code> 是一个函数，它有一个泛型参数可以通过第二个函数参数的类型推导出来。对 <code>loginName</code> 的读写等同于对 SharedPreferences 中的 “loginName” 这个 key 的读写，这个操作是不是非常方便？想要实现这样的功能也不需要太多的逻辑，我们以 <code>String</code> 为例给出实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Preference</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> context: Context, <span class="keyword">val</span> name: String, </span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">default</span>: T, <span class="keyword">val</span> prefName: String = <span class="string">"default"</span>) : ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> prefs <span class="keyword">by</span> lazy &#123; context.getSharedPreferences(prefName, Context.MODE_PRIVATE) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> findPreference(findProperName(property), <span class="keyword">default</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        putPreference(findProperName(property), value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findProperName</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;)</span></span> = <span class="keyword">if</span>(name.isEmpty()) property.name <span class="keyword">else</span> name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;U&gt;</span> <span class="title">findPreference</span><span class="params">(name: <span class="type">String</span>, <span class="keyword">default</span>: <span class="type">U</span>)</span></span>: U = with(prefs) &#123;</span><br><span class="line">        <span class="keyword">val</span> res: Any = <span class="keyword">when</span> (<span class="keyword">default</span>) &#123;</span><br><span class="line">            <span class="keyword">is</span> String -&gt; getString(name, <span class="keyword">default</span>)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res <span class="keyword">as</span> U</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;U&gt;</span> <span class="title">putPreference</span><span class="params">(name: <span class="type">String</span>, value: <span class="type">U</span>)</span></span> = with(prefs.edit()) &#123;</span><br><span class="line">        <span class="keyword">when</span> (value) &#123;</span><br><span class="line">            <span class="keyword">is</span> String -&gt; putString(name, value)</span><br><span class="line">            ...</span><br><span class="line">        &#125;.apply()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他数据类型的支持大家可以根据需要自行扩展。</p><p>属性代理的本质就是 <code>getValue</code> 和 <code>setValue</code> 这两个方法，这里的代码实现了 <code>ReadWriteProperty</code> 这个接口，不过这不是必须的，我们当然也可以改成下面的样子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Preference</span>&lt;<span class="type">T</span>&gt;</span>(...) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> findPreference(findProperName(property), <span class="keyword">default</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        putPreference(findProperName(property), value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 <code>getValue</code> 和 <code>setValue</code> 还是运算符方法，其实这里我们甚至可以把它们定义成扩展方法，只要方法的类型符合要求就可以。</p><p>既然如此，那我们是不是还可以对 Java 的 <code>Properties</code> 文件提供类似的支持呢？当然。我们同样可以通过被代理的属性名来查询对应 key 在 <code>Properties</code> 文件中的值，这个逻辑与 SharedPreferences 如出一辙，大家有兴趣可以参考这里：<a href="https://github.com/enbandari/QCloudImageUploaderForMarkDown/blob/master/src/main/kotlin/com/bennyhuo/qcloud/prop/AbsProperties.kt" target="_blank" rel="noopener">AbsProperties.kt</a>。</p><p>官网在介绍属性代理的时候还给出了 Map 作为属性代理的用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name : String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age  : <span class="built_in">Int</span>    <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在很早的时候还专门写过一篇文章来介绍这个用法：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247484018&amp;idx=1&amp;sn=170499992c0f29d9304eeddc4379f34e&amp;chksm=e8a05d4fdfd7d459d7e75fa987eda85b39d43ce9b2ea5c8d2b8c884efc7b0431ae39b3c9c22f&amp;token=397611765&amp;lang=zh_CN#rd" target="_blank" rel="noopener">用 Map 为你的属性做代理</a>。其实 <code>Map</code> 也是一种存储的方式，这与前面提到的 SharedPreferences 又有什么区别呢？</p><p>这样的例子我们还能列举很多，如数据库读写、文件读写甚至网络读写等等。</p><h3 id="控制属性的生命周期"><a href="#控制属性的生命周期" class="headerlink" title="控制属性的生命周期"></a>控制属性的生命周期</h3><p>标准库中也提供了 Lazy、Observable 这样的属性代理实现，它们与前面的简化存储的写法不同，二者分别代表了控制、监听属性的读写的使用场景。Lazy 的例子想必大家已经见过很多了，我们可以通过 Lazy 代理属性的初始化逻辑，确保只有在第一次访问时才会对属性进行初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textView <span class="keyword">by</span> lazy &#123; rootView.findViewById(R.id.text) &#125;</span><br></pre></td></tr></table></figure><p>我们对属性进行延迟初始化的理由总是会有很多，例如初始化可能比较耗时，依赖的其他成员尚未初始化等等。</p><p>我们再来看个例子。</p><p>Kotlin 当中的变量类型分为可空和不可空，定义时必须明确其类型，例如下面例子中的 image：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> image: Bitmap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        image = <span class="literal">null</span> <span class="comment">// Error!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>image</code> 在定义时如果定义为 <code>Bitmap?</code>，那么在不需要的时候自然是可以置为 <code>null</code> 的，只不过用的时候每次都需要判空，感觉就很让人难受。而如果定义成 <code>Bitmap</code>，用的时候倒是省事儿了，可是最后我们又无法将其置为 <code>null</code>。怎么办？</p><p>有人说你这个是伪需求，不置为 <code>null</code> 也不会有内存泄露。不过，<code>Activity</code> 经常在 <code>onStop</code> 调用之后还会存续一段时间才会被销毁，对应的 <code>Bitmap</code> 对象也要晚一段时间才能被释放，不置为 <code>null</code> 似乎并不是一个最优的选择。不管怎样，如果我们就是想要把这个 <code>Bitmap</code> 对象（或者其他什么对象）置为空，又想不影响开发体验，似乎是不可行的。</p><p>但如果我们用属性代理来控制对象的内部逻辑呢：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> image <span class="keyword">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        <span class="comment">// release the Bitmap instance.</span></span><br><span class="line">        ::image.release() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过 <code>releasableNotNull</code> 函数来创建这样一个属性代理，这个属性代理的工作就是提供一个真正的属性存储，可读可写可释放，它的实现并不复杂：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">releasableNotNull</span><span class="params">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> value ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">"Not Initialized or released already."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span> = value != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isAccessible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">"Delegate is null or is not an instance of ReleasableNotNull."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过对属性代理类 <code>ReleasableNotNull</code> 实现了对真正存储值的 <code>value</code> 的代理，前面对 <code>image</code> 的访问实际上就是对 <code>value</code> 的访问，而 <code>value</code> 的类型又是可空的，因此我们实现了既可将属性置为 <code>null</code> 又可将属性 <code>image</code> 声明为不可空的 <code>Bitmap</code> 类型的需求。</p><p>这个小功能已经开源并上传到 jcenter，大家可以通过配置依赖 <code>com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0</code> 来使用它，也可以直接到我的 GitHub 上查看它的源码：<a href="https://github.com/enbandari/ReleasableVar" target="_blank" rel="noopener">ReleasableVar</a>，源码当中我也给出了不依赖 Kotlin 反射的实现方法。</p><blockquote><p>例子当中的 <code>KProperty0&lt;R&gt;.release</code> 扩展方法实际上是为被代理的属性的引用添加了一个扩展，其中使用反射可以获取到代理对象，这样我们就可以使用 <code>::image.release()</code> 来实现对 image 背后的值的置空。请大家留意我们获取属性代理对象的方式，这在 Kotlin 当中需要用到反射；后面我们会看到， Swift 则直接提供了更好的语法来支持这样的功能。</p></blockquote><h3 id="代理其他类属性或者方法"><a href="#代理其他类属性或者方法" class="headerlink" title="代理其他类属性或者方法"></a>代理其他类属性或者方法</h3><p>前面的例子都比较直观，我们再给大家看一个更复杂的用法。</p><p>假设我们现在有这么一类，它有一些方法和属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapped</span></span>(<span class="keyword">var</span> x: <span class="built_in">Boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> z = <span class="number">10L</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setY</span><span class="params">(y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getY</span><span class="params">()</span></span> = <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的实例会被包在另一个类当中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Boolean</span> = ...</span><br><span class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span> = ...</span><br><span class="line">    <span class="keyword">val</span> z: <span class="built_in">Long</span> = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>Wrapper</code> 类当中还想把 <code>Wrapped</code> 类的一些成员暴露给外部调用者，可能的实现就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = wrapped.x</span><br><span class="line">        <span class="keyword">set</span>(value) &#123; wrapped.x = value &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的写法并不是很简洁，我们可以通过属性代理实现这样的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">by</span> wrapped::x.delegator()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性代理本质上就是 <code>setValue</code> 和 <code>getValue</code>，所以代理 getter 和 setter <code>也是顺理成章。delegator</code> 函数是 <code>x</code> 的属性引用的扩展成员，定义也不复杂：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> KProperty0<span class="type">&lt;T&gt;</span>.<span class="title">delegator</span><span class="params">(initializedValue: <span class="type">T</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">    : ReadWriteProperty&lt;Any, T&gt;</span><br><span class="line">        = ObjectPropertyDelegate0(</span><br><span class="line">            propertyRef = <span class="keyword">this</span> <span class="keyword">as</span> PropertyReference, </span><br><span class="line">            initializedValue = initializedValue</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectPropertyDelegate0</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> getter: (() -&gt; T), </span><br><span class="line">        <span class="keyword">val</span> setter: ((T) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span>, </span><br><span class="line">        initializedValue: T? = <span class="literal">null</span>) : ReadWriteProperty&lt;Any, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        propertyRef: PropertyReference, </span><br><span class="line">        initializedValue: T? = <span class="literal">null</span></span><br><span class="line">        ): <span class="keyword">this</span>(</span><br><span class="line">            (propertyRef <span class="keyword">as</span> KProperty0&lt;T&gt;)::<span class="keyword">get</span>, </span><br><span class="line">            <span class="keyword">if</span> (propertyRef <span class="keyword">is</span> KMutableProperty0&lt;*&gt;) (propertyRef <span class="keyword">as</span> KMutableProperty0&lt;T&gt;)::<span class="keyword">set</span> <span class="keyword">else</span> <span class="literal">null</span>, initializedValue</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        initializedValue?.let &#123; setter?.invoke(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> getter.invoke()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        setter?.invoke(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有点儿像请求转发一样，对 <code>Wrapper</code> 的属性 <code>x</code> 的读写直接转发给了 <code>Wrapped</code> 的属性 <code>x</code> 。既然我们把属性拆解开看做是 getter 和 setter，那么所有符合此类特征的函数也是可以被代理的，因此对于 <code>Wrapped</code> 的 <code>getY</code> 也可以代理成一个只读属性，<code>setY</code> 也可以单独代理成一个可变属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> y <span class="keyword">by</span> wrapped::setY.delegator(defaultValue = <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> yGetter <span class="keyword">by</span> wrapped::getY.delegator()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>getY</code> 的代理比较容易理解。对于 <code>setY</code> 的代理就有些奇怪了，属性 <code>y</code> 只代理了 <code>wrapped::setY</code>，那读取 <code>y</code> 的值时从哪儿获取呢？这其实也不难做到，我们可以通过属性代理提供一个 backingfield 来保存这个值就可以了。其实对于 setter 的代理的场景还真有，例如对于 Android 中某些 <code>View</code> 的属性只有 setter 的方法，没有对应的 getter，如果我想要做一个属性动画，那么这样的属性代理就会比较有帮助。</p><p>当然，类似的扩展我们还可以做很多，甚至支持 lazy：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> delegateLazyOf(TextView::getText, TextView::setText) &#123; textView &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们前面的例子当中 <code>wrapped</code> 从一开始就被初始化了，而这个例子当中 <code>textView</code> 需要等到 <code>Activity</code> 的 <code>onCreate</code> 调用之后才会初始化，因此 <code>lazy</code> 就显得非常必要了。具体实现就不一一列举了，有兴趣的朋友可以参考我的 GitHub 项目：<a href="https://github.com/enbandari/ObjectPropertyDelegate" target="_blank" rel="noopener">ObjectPropertyDelegate</a>，大家也可以通过引入 <code>com.bennyhuo.kotlin:delegates:1.0</code> 来直接使用它。</p><p>需要补充说明的一点是，根据 Kotlin 官方最新发布的博客来看，从 Kotlin 1.4-M2 开始会直接支持使用属性代理其他属性，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> newName: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">   <span class="meta">@Deprecated(<span class="meta-string">"Use 'newName' instead"</span>, ReplaceWith(<span class="meta-string">"newName"</span>)</span>)</span><br><span class="line">   <span class="keyword">var</span> oldName: <span class="built_in">Int</span> <span class="keyword">by</span> <span class="keyword">this</span>::newName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上与我们前面使用属性代理其他属性问题的处理上如出一辙。其实这个写法只不过是为 <code>KProperty0&lt;R&gt;</code> 实现了 <code>getValue</code> 和 <code>setValue</code> 扩展，我们在 Kotlin 1.4 以前的版本自己就可以实现这样的效果，只需要添加以下扩展即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">get</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KMutableProperty0<span class="type">&lt;R&gt;</span>.<span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">R</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">set</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个用法实际上也进一步说明了 Kotlin 对属性代理类本身没有类型要求的好处，如果强制属性代理类实现某一个接口的话，那这个效果就只能通过修改 <code>KProperty0</code> 的继承结果来实现了。当然，官方给出的这个例子还直接展示了这个特性的一个使用场景，即属性重命名。</p><h2 id="Swift-的属性包装器（Property-Wrapper）"><a href="#Swift-的属性包装器（Property-Wrapper）" class="headerlink" title="Swift 的属性包装器（Property Wrapper）"></a>Swift 的属性包装器（Property Wrapper）</h2><p>Swift 的属性包装器其实就是属性代理，最早推出这个特性的时候实际上也叫做 Property Delegate，但设计者们觉得 Property Wrapper 更贴切它的实际用法和含义，加上 Delegate 这个词在 Swift 当中（或者说更早的 Objective-C 当中）已经有了非常确切的含义，因此改成了Property Wrapper。这个名字看上去确实比属性代理表达出来的意图更加明显。</p><p>大家也可以参考 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#user-defaults" target="_blank" rel="noopener">Swift 的属性包装器的设计文档</a>，文档中详细列出了一些使用场景和方法，以及一些设计细节，这其中绝大多数的使用场景我们也可以通过 Kotlin 的属性代理在 Kotlin 当中实现。</p><p>这个特性在 Swift 5 才推出，可以说是非常晚了。说来也有趣，在它的设计文档中还特意 “diss” 了 Kotlin 的属性代理的语法设计：单独为了属性代理搞了一个 by 关键字实在是有些重，在其他场景下也不太好复用，于是 Swift 的属性包装器采用了与 Java/Kotlin 的注解类似的长相的设计。</p><h3 id="代理-UserDefaults"><a href="#代理-UserDefaults" class="headerlink" title="代理 UserDefaults"></a>代理 UserDefaults</h3><p><code>UserDefaults</code> 是苹果家族的平台上通用的类似于 SharedPreferences 的配置存储，也是 key-value 的形式进行读写，我们可以使用属性包装器来进行代理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserDefault</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> defaultValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UserDefaults</span>.standard.object(forKey: key) <span class="keyword">as</span>? <span class="type">T</span> ?? defaultValue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(newValue, forKey: key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>@PropertyWrapper</code> 将 <code>UserDefault</code> 声明为一个属性包装器，我们很自然想到要提供 getter 和 setter 的实现，Swift 通过 <code>wrappedValue</code> 这个计算属性来做到这一点，这样对于被包装的属性的访问其实就转发到对 <code>wrappedValue</code> 的访问上。用法也很直接：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalSettings</span> </span>&#123;</span><br><span class="line">    @<span class="type">UserDefault</span>(key: <span class="string">"FOO_FEATURE_ENABLED"</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isFooFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    @<span class="type">UserDefault</span>(key: <span class="string">"BAR_FEATURE_ENABLED"</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子就是设计文档中的例子，大家可以在 Swift 5.2 当中运行测试。</p><p>稍微提一句，在 Swift 中，struct 是值类型，class 是引用类型，对于属性包装器来讲，二者都是可以的，用哪个取决于具体需求。</p><p>除了语法形式的不同之外，从功能上，Swift 的属性包装器的 wrappedValue 相当于 Kotlin 的属性代理的 <code>getValue</code> 和 <code>setValue</code> 的实现，不同之处在于 Kotlin 在 <code>getValue</code> 和 <code>setValue</code> 中提供了 <code>KProperty</code> 这个参数，我们可以通过它来获取对应属性的一些元信息，最常用的就是 name，所以我们在前面使用 Kotlin 代理 SharedPreferences 的例子当中完全可以不用主动传入 key 的值。</p><p>相比之下，Kotlin 的属性代理的语法更加自由，我们可以轻松地模拟 Swift 的写法来实现属性代理，主要以下是 Kotlin 代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PropertyWrapper</span>&lt;<span class="type">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: Value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: Value = wrappedValue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">Value</span>)</span></span> &#123;</span><br><span class="line">        wrappedValue = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这个思路，实现具体的属性代理，只需要实现这个接口并覆写即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObservableDelegate</span>&lt;<span class="type">Value</span>&gt;</span>(</span><br><span class="line">    initializedValue: Value,</span><br><span class="line">    <span class="keyword">val</span> changedListener: (previous: Value, current: Value) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : PropertyWrapper&lt;Value&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> wrappedValue: Value = initializedValue</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">val</span> previous = field</span><br><span class="line">            field = value</span><br><span class="line">            changedListener(previous, value)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法没有什么特殊之处：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> state: <span class="built_in">Int</span> <span class="keyword">by</span> ObservableDelegate(<span class="number">0</span>) &#123; previous, current -&gt;</span><br><span class="line">    println(<span class="string">"changed <span class="variable">$previous</span> -&gt; <span class="variable">$current</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">state = <span class="number">2</span> <span class="comment">// changed 0 -&gt; 2</span></span><br><span class="line">state = <span class="number">3</span> <span class="comment">// changed 2 -&gt; 3</span></span><br><span class="line">state = <span class="number">4</span> <span class="comment">// changed 3 -&gt; 4</span></span><br></pre></td></tr></table></figure><h3 id="属性包装器的-projectedValue"><a href="#属性包装器的-projectedValue" class="headerlink" title="属性包装器的 projectedValue"></a>属性包装器的 projectedValue</h3><p>我是在学 Swift UI 的时候才开始接触到 Swift 的属性包装器的。Swift UI 就是使用 Swift 代码直接布局的写法，这种写法现在比较流行，例如 Flutter 的 Dart， Android 上之前的 Kotlin Anko 以及现在的 Compose。</p><p>我们来看一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> isEnabled: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(isOn: $isEnabled) &#123;</span><br><span class="line">            isEnabled ? <span class="type">Text</span>(<span class="string">"Click to disable"</span>).foregroundColor(.red)</span><br><span class="line">                : <span class="type">Text</span>(<span class="string">"Click to enable"</span>).foregroundColor(.green)</span><br><span class="line">        &#125;.padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>body</code> 是布局的 View，里面只有一个控件就是一个开关 <code>Toggle</code>，它需要与 <code>isEnabled</code> 这个属性绑定，UI 的效果如下：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-23.png" alt=""></p><p><strong><center>isEnabled 为 false 时的 UI</center></strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-42.png" alt=""></p><p><strong><center>isEnabled 为 true 时的 UI</center></strong></p><p><code>isEnabled</code> 这个属性被 <code>State</code> 这个属性包装器包装，<code>State</code> 为它提供了一个 <code>projectedValue</code> 的属性，这个 <code>projectedValue</code> 可以通过 <strong><code>$</code> + 属性名</strong> 来获取，也就是说作为 <code>Toggle</code> 的参数 <code>isOn</code> 的 <code>$isEnabled</code> 实际上就是 <code>isEnabled</code> 这个属性的包装器提供的 <code>projectValue</code>。</p><p>这个 <code>projectedValue</code> 实际上也是一个属性包装器，它的类型是 <code>Binding&lt;Bool&gt;</code>，<code>Binding</code> 这个属性包装器的作用比较直接，类似于我们前面介绍 Kotlin 的属性代理时提到的 <code>wrapped::x.delegator()</code>，它的作用就是提供了属性的 getter 和 setter，这样我们将 <code>Binding&lt;Bool&gt;</code> 对象传给 <code>Toggle</code> 的时候，它就可以在其中方便的修改 <code>isEnabled</code> 这个属性了。</p><p><code>State</code> 当然还提供了与 View 的刷新机制相关的逻辑，它实现了 <code>DynamicProperty</code> 协议，可以在属性被修改时调用 <code>update</code> 方法来刷新 UI。</p><p>下面我们给出 <code>State</code> 的声明，具体实现没有开源，但可以想到的是在 <code>wrappedValue</code> 的 setter 调用时一定会触发 <code>DynamicProperty</code> 协议的 <code>update</code> 方法的调用，<code>projectedValue</code> 则是返回一个包装了被 <code>State</code> 包装的属性的 getter 和 setter 的对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line">@frozen <span class="meta">@propertyWrapper</span> <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">State</span>&lt;<span class="title">Value</span>&gt; : <span class="title">DynamicProperty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Initialize with the provided initial value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(wrappedValue value: <span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Initialize with the provided initial value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(initialValue value: <span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The current state value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123; <span class="keyword">get</span> <span class="keyword">nonmutating</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Produces the binding referencing this state value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> projectedValue: <span class="type">Binding</span>&lt;<span class="type">Value</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们考虑下 Kotlin 当中是否存在对应的特性。</p><p>对于 <code>Binding</code> 的使用场景，Kotlin 当中大可不必这么大费周章，因为 Kotlin 的属性引用可以很方便的允许我们传递一个属性的 setter 和 getter，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isEnabled: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get property reference</span></span><br><span class="line"><span class="keyword">val</span> view = View()</span><br><span class="line"><span class="keyword">val</span> isEnabledRef = view::isEnabled</span><br><span class="line"></span><br><span class="line"><span class="comment">// operate on property reference</span></span><br><span class="line">isEnabledRef.<span class="keyword">set</span>(<span class="literal">true</span>)</span><br><span class="line">println(isEnabledRef.<span class="keyword">get</span>())</span><br></pre></td></tr></table></figure><p>也就是说，Swift UI 当中的 <code>Binding</code> 在当中可以使用 Kotlin 的属性引用来替代，以上代码也不需要额外引入 Kotlin 反射。</p><p>但可以确定的是，Kotlin 当中没有 <code>projectedValue</code> 这样的特性，即便我们在前面模拟 Swift 声明的 <code>PropertyWrapper</code> 接口中添加这样的属性，我们也没有直接的类似于 <code>$isEnabled</code> 这样的语法来获取它。不仅如此，在 Kotlin 当中想要获取属性代理对象本身也不是一件轻松的事情，而在 Swift 当中我们可以使用 <code>projectedValue</code> 直接返回自身（也可以返回别的，例如 <code>State</code> 中就没有返回自己，而是返回了 <code>Binding</code>）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserDefault</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> defaultValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> projectedValue: <span class="type">UserDefault</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalSettings</span> </span>&#123;</span><br><span class="line">    @<span class="type">UserDefault</span>(key: <span class="string">"FOO_FEATURE_ENABLED"</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isFooFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    @<span class="type">UserDefault</span>(key: <span class="string">"BAR_FEATURE_ENABLED"</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.isBarFeatureEnabled) </span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDefault&lt;Bool&gt;(key: "BAR_FEATURE_ENABLED", defaultValue: false)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.$isBarFeatureEnabled) </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.$isBarFeatureEnabled.wrappedValue) </span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDefault&lt;Bool&gt;(key: "BAR_FEATURE_ENABLED", defaultValue: false)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.$isBarFeatureEnabled.projectedValue)</span><br></pre></td></tr></table></figure><p>实际上如果是在被包装的属性所在的类内部，我们还可以直接拿到包装属性的实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalSettings</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @<span class="type">UserDefault</span>(key: <span class="string">"BAR_FEATURE_ENABLED"</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getIsBarFeatureEnabledWrapper</span><span class="params">()</span></span> -&gt; <span class="type">UserDefault</span>&lt;<span class="type">Bool</span>&gt; &#123;</span><br><span class="line">        _isBarFeatureEnabled</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <code>_isBarFeatureEnabled</code> 得到的就是包装 <code>isBarFeatureEnabled</code> 的实例。</p><p>而这在 Kotlin 当中我们就只能通过反射来做到这一点了。不知道大家是否注意到我们用 Kotlin 属性代理实现的 ReleasableVar 这个组件中用到了 Kotlin 反射方法 <code>getDelegate</code> 来获取属性代理对象，即便我们可以接受使用反射这个前提，但它返回的类型 <code>Any?</code> 也同样不如 Swift 当中可以通过 <code>$</code> 直接获取 <code>projectedValue</code> 以及通过 <code>_</code> 获取属性包装器实例来的直接和安全。更何况 <code>getDelegate</code> 这个反射方法目前只能在 JVM 上使用，无法实现多平台。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="class"><span class="keyword">interface</span> <span class="title">KProperty0</span>&lt;<span class="type">out R</span>&gt; : <span class="type">KProperty</span>&lt;<span class="type">R</span>&gt;, <span class="type"></span></span>() -&gt; R &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of the delegate if this is a delegated property, or `null` if this property is not delegated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDelegate</span><span class="params">()</span></span>: Any?</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们在 Kotlin 当中可以直接把属性代理对象先定义出来，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"><span class="keyword">val</span> delegate = ObservableDelegate(<span class="number">0</span>) &#123; previous, current -&gt;</span><br><span class="line">    println(<span class="string">"changed <span class="variable">$previous</span> -&gt; <span class="variable">$current</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> state <span class="keyword">by</span> delegate</span><br></pre></td></tr></table></figure><p>但这个写法又显得 <code>delegate</code> 与 <code>state</code> 的联系没有那么紧密，因此 Swift 的属性包装器在 <code>projectedValue</code> 的设计上为开发者提供了更大的发挥空间。</p><p>Kotlin 的规划和提议方面也暂时没有看到有类似的设计，如果我们想要在 Kotlin 当中也实现类似于 <code>projectedValue</code> 的功能，也许可以借助一下 Kotlin 编译器插件来完成。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>属性代理或者属性包装器本质上提供了把读写操作简化成对变量的读写的可能性，能够提供更大程度上的抽象，简化程序的代码重复度。</p><p>Kotlin 的属性代理的语法结构没有类型上的强制约束，只要实现 <code>getValue</code> 和 <code>setValue</code> 这两个方法即可用作属性代理的对象，没有实现接口的限制可以为已有的类型提供更多的扩展可能性；不过，获取一个属性的代理对象的方式不是特别友好，一方面需要使用到反射，另一方面获取到的类型是 <code>Any?</code>，没有静态类型的约束。</p><p>相比之下 Swift 的属性包装器提供了类似的能力，也通过提供 projectedValue 可以衍生出更多灵活的用法。</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Swift 的属性代理，见识一下&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="property" scheme="https://www.bennyhuo.com/tags/property/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Native 写 Jni 第三弹：改造成 MPP 的工程结构</title>
    <link href="https://www.bennyhuo.com/2020/04/19/kotlin-native-android-mpp/"/>
    <id>https://www.bennyhuo.com/2020/04/19/kotlin-native-android-mpp/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。</p></blockquote><a id="more"></a><p>在读这篇文章之前，大家可以去参考下之前的文章：</p><ul><li><a href="https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/">用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏</a></li><li><a href="https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/">Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法</a></li></ul><p>之前两篇文章已经介绍了如何通过 <code>CName</code> 注解来限定 Kotlin-Native 代码编出来的动态链接库的符号名，以实现与 Java 的 native 方法的绑定，也介绍了如何使用 <code>JNI_OnLoad</code> 来动态注册 native 方法来实现绑定。换句话说，如果你想要知道如何用 Kotlin-Native 写 Android 的 Jni 的 Native 层代码，那么前面的两篇文章里面就有答案。</p><p>前文撰写的时候 Kotlin-Native 的构建插件尚未稳定，当时除了 Multiplatform Project（以下简称 mpp） 的 Gradle 插件以外还有一个单独的 native 的插件，用法也不是特别统一，现在后者已经被废弃，因此我们只需要用 mpp 的插件来构建 Kotlin-Native 的工程即可。顺带提一句，现在使用 Kotlin DSL 来编写 Gradle 脚本体验已经比之前强多了，建议大家把 IDE 的 Kotlin 插件升级到 1.3.70 以上版本来体验。</p><p>接下来我们就把之前的工程改造一下，工程源码见：<a href="https://github.com/enbandari/hello-kni" target="_blank" rel="noopener">hello-kni</a>。</p><p>首先我们创建一个 Module，你可以选择使用 IntelliJ 的 new module 方式，选择创建一个 Android library，当然也可以自己创建一个目录，然后再创建一个 build.gradle.kts 文件，就像这样：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-08-37-45.png" alt=""></p><p>接着，在 settings.gradle.kts 当中引入这个 Module：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="string">":app"</span>, <span class="string">":nativeLib"</span>)</span><br></pre></td></tr></table></figure><p>好，关键来了，剩下的主要就是修改 build.gradle.kts。我们先来添加 mpp 的 Gradle 插件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">"multiplatform"</span>) version <span class="string">"1.3.71"</span></span><br><span class="line">    id(<span class="string">"com.android.library"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到我们还添加了 Android 的 library 插件，原因是我们想要把 Kotlin-Native 编译出来的 so 打进一个 aar 里面作为 Android 的依赖提供给 app 工程。</p><p>所以构建出来的 so 文件我们需要引入到 aar 的编译流程中，可以将这个 so 文件复制到一个路径，我们把这个路径添加为 Android 的 jniLibs 路径即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jniLibDir = File(project.buildDir, arrayOf(<span class="string">"generated"</span>, <span class="string">"jniLibs"</span>).joinToString(File.separator))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        <span class="keyword">val</span> main <span class="keyword">by</span> getting &#123;</span><br><span class="line">            jniLibs.srcDir(jniLibDir)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 build 目录下选了 generated/jniLibs 作为 jniLibs 目录添加到了 aar 的编译流程中。接下来我们只需要完成 so 文件的复制即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kotlin &#123;</span><br><span class="line">    androidNativeArm32 &#123;</span><br><span class="line">        binaries &#123;</span><br><span class="line">            sharedLib(<span class="string">"knlib"</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(buildType == NativeBuildType.RELEASE)&#123;</span><br><span class="line">                    linkTask.doLast &#123;</span><br><span class="line">                        copy &#123;</span><br><span class="line">                            from(outputFile)</span><br><span class="line">                            into(File(jniLibDir, <span class="string">"armeabi-v7a"</span>))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    afterEvaluate &#123;</span><br><span class="line">                        <span class="keyword">val</span> preReleaseBuild <span class="keyword">by</span> tasks.getting</span><br><span class="line">                        preReleaseBuild.dependsOn(linkTask)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin mpp 的工程配置非常清晰：</p><ol><li>内部的第一层是选择目标平台，这里选择的是 androidNativeArm32，当然如果你想要构建 iOS 平台的，也可以选择 iosArm64 等等。</li><li>第二层是 binaries 就是定义产出物，其内部的 sharedLib 表示产出物是共享库（shared object，so），当然如果希望编译出可执行文件，就替换成 executable。sharedLib 有两个参数，第一个是库的名字，我们这里与原来保持了一致，将库的名字指定为 knlib，这样编译出来的 so 文件就是 libknlib.so。</li><li>我们通过 buildType 来选择将 RELEASE 的产出物复制到指定路径（也就是刚才定义的 jniLibDir），如果做得更完善的话也可以分别对 DEBUG/RELEASE 进行处理。</li><li>为 aar 的构建流程中的 preReleaseBuild 任务添加依赖，这样在 assembleRelease 执行时可以触发对 Kotlin-Native 代码的编译。当然，这里也可以选择其他的任务进行依赖，只要能够在 assemble 时触发编译即可。</li></ol><p>工程配置搞定之后，我们还需要把源码添加进来。androidNativeArm32 的源码路径默认为 src/androidNativeArm32Main/kotlin，因此我们把之前已经写好的 Kotlin-Native 的源文件添加进去即可：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-18-01-24.png" alt=""></p><p>另外作为 Android Library 工程，manifest 文件当然是必须的，不过里面也不需要有什么特别的配置。</p><p>至此，使用 Kotlin-Native 编写 Jni 的工程改造就完成了，在 app 工程中添加依赖：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(project(<span class="string">":nativeLib"</span>))</span><br></pre></td></tr></table></figure><p>直接编译运行 app 工程即可运行，再也不用使用命令行编译啦。</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="kotlin-native" scheme="https://www.bennyhuo.com/tags/kotlin-native/"/>
    
      <category term="mpp" scheme="https://www.bennyhuo.com/tags/mpp/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 新版本也有了交叉类型和联合类型？</title>
    <link href="https://www.bennyhuo.com/2020/04/06/kotlin-intersect-type/"/>
    <id>https://www.bennyhuo.com/2020/04/06/kotlin-intersect-type/</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。</p></blockquote><a id="more"></a><p>Kotlin 1.4-m1 发布之后，我曾整理了一下官方博客中提到的语法更新，见 <a href="https://www.bennyhuo.com/2020/03/26/kotlin-1.4-preview/">Kotlin 1.4 新特性预览</a>。除了前面的文章中提到的变化，新类型推导算法对于我们平常的代码编写的提升实际上还会体现在很多方面，接下来我们再为大家展示一个 case，来一起感受下新版本的厉害之处。</p><h2 id="1-分支表达式的类型推导问题"><a href="#1-分支表达式的类型推导问题" class="headerlink" title="1. 分支表达式的类型推导问题"></a>1. 分支表达式的类型推导问题</h2><p>先来看一段代码：</p><p><strong>代码清单 1：Kotlin 的分支表达式</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> number = <span class="keyword">if</span> (validation()) <span class="number">1F</span> <span class="keyword">else</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>请问 number 的类型是什么？</p><p>直觉告诉我们，number 的类型应该就是 Number 呀，因为两个分支分别是 Float 和 Double 类型，而 Number 是它俩的父类，因此是 Number 没毛病。</p><p>逻辑上确实如此，不过实际情况就要各种打脸了。你也许想不到，Float 还实现了一个 Comparable<float>的接口，而 Double 则实现了 Comparable<double>，于是 Float 和 Double 应该同样是 Comparable 的子类才对。也就是说 Float 和 Double 有两个父类（接口），那么再想想，number 究竟是什么类型？Comparable 还是 Number？</double></float></p><p>都不是。Kotlin 1.3 当中，我们可以通过 IntelliJ 很容易的得到答案：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-13-42.png" alt=""></p><p><strong><center>图 1：Kotlin 1.3 对分支表达式的类型推导</center></strong></p><p>是不是很吃惊？居然是 Any。因为 Kotlin 编译器在类型推导时遇到这种模棱两可的情况实在不知道如何做出选择，因此干脆不选。</p><p>当然，如果你为 number 添加类型声明，例如：</p><p><strong>代码清单 2：为分支表达式添加类型信息</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> number: Number = <span class="keyword">if</span> (validation()) <span class="number">1F</span> <span class="keyword">else</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>这样 number 的类型就可以确定为 Number 了，Kotlin 编译器也算是松了一口气。</p><blockquote><p>有关这个问题的详细分析，我曾经在两年前写过一篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247484051&amp;idx=1&amp;sn=4676580d88e9751df9a5ae192fd8d0da&amp;chksm=e8a05daedfd7d4b8d7b7cc9201f287ba3f3206ddba246266c450c02d821959b99344e4cbf42c&amp;token=482430266&amp;lang=zh_CN#rd" target="_blank" rel="noopener">val b = a?: 0，a 是 Double 类型，那 b 是什么类型？</a>，有兴趣的读者可以去了解下。</p></blockquote><h2 id="2-新类型推导算法的推导结果"><a href="#2-新类型推导算法的推导结果" class="headerlink" title="2. 新类型推导算法的推导结果"></a>2. 新类型推导算法的推导结果</h2><p>那么问题来了，新类型推导算法难道可以自动帮我们选择我们想要的类型嘛？额，说实话，这种情况下编译器并不知道你究竟想要什么类型，于是做出选择那是不可能的事儿了。既然做不出选择，那为什么还要选呢？小孩子才做选择，我当然是都要啊！</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-26-20.png" alt=""></p><p><strong><center>图 2：Kotlin 1.4 对分支表达式的类型推导</center></strong></p><p>这是什么情况？这个类型我没见过啊。确实如此，这样的类型我们也没有办法显式声明出来，只有靠编译器推导才能得到。那么这个 {A &amp; B} 的类型究竟算是什么类型呢？字面意思就是既是 A 类型，又是 B 类型，实际含义也是如此。也就是说，{Comparable{Double &amp; Float} &amp; Number} 这个类型既是 Comparable 类型，又是 Number 类型。</p><p>于是在 Kotlin 1.4 当中，以下代码就成了合法的用法：</p><p><strong>代码清单 3：Kotlin 1.4 中对于分支表达式类型的使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Number.<span class="title">compareTo</span><span class="params">(other: <span class="type">Number</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toDouble().compareTo(other.toDouble())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> number = <span class="keyword">if</span> (validation()) <span class="number">1F</span> <span class="keyword">else</span> <span class="number">2.0</span></span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$number</span> &gt; 2"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$number</span> &lt;= 2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在 Kotlin 1.3 当中默认会无法通过编译。</p><h2 id="3-交叉类型与联合类型"><a href="#3-交叉类型与联合类型" class="headerlink" title="3. 交叉类型与联合类型"></a>3. 交叉类型与联合类型</h2><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-49-34.png" alt=""></p><p><strong><center>图 3：Double 和 Float 的类型关系</center></strong></p><p>两个类型的交叉类型就是两个类型的交集，因此对于类型 A &amp; B，如果我们把 A 和 B 看做集合的话，相当于 A ∩ B。图 3 的含义其实还涉及到另一个概念：联合类型。对于文章开头的分支表达式，它的类型是 Double 或者 Float，即 Double | Float，这个类型就是一个联合类型，从集合的角度来讲实际上就是 Double ∪ Float。通俗的说，交叉类型是“既是 A 也是 B”的关系，联合类型则是“不是 A 就是 B”的关系。</p><p>既然如此，从图上来看，Comparable &amp; Number == Double | Float，因为我们前面讲到过，Double 和 Float 的公共父类（接口）包括 Comparable 和 Number。请注意，Kotlin 在表达联合类型时实际上是取了一个类型的近似值，这个值就是公共父类。</p><p>坦率地讲，Kotlin 当中的联合类型与真正理想的联合类型还是不一样的，我们给出 TypeScript 中的联合类型让大家感受下：</p><p><strong>代码清单 4：TypeScript 中的联合类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">    fly(): <span class="built_in">void</span>;</span><br><span class="line">    layEggs(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    swim(): <span class="built_in">void</span>;</span><br><span class="line">    layEggs(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"><span class="comment">// OK，两个类型的公共成员</span></span><br><span class="line">pet.layEggs();</span><br></pre></td></tr></table></figure><p>虽然 Bird 和 Fish 两个接口没有公共父接口，但 Bird | Fish 却有二者的公共成员 layEggs。如果这段代码放到 Kotlin 当中，结果可想而知：</p><p><strong>代码清单 5：Kotlin 的联合类型</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">layEggs</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">swim</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">layEggs</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> pet = <span class="keyword">if</span>(validation()) <span class="keyword">object</span> : Bird&#123; ... &#125; <span class="keyword">else</span> <span class="keyword">object</span> : Fish&#123; ... &#125;</span><br><span class="line">pet.layEggs() <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>这里 pet 理论上应该是 Bird | Fish，但 Kotlin 编译器总是会尝试将其类型“退化”成一个当前类型系统可表达的类型，这个退化的方法就是寻找二者的公共父类，即 Any。因此，Kotlin 编译器将分支表达式的类型推导为 Any，pet 自然无法直接访问 layEggs 了，尽管 Bird 和 Fish 都有这个函数。</p><p>按照 Kotlin 语言规范的说法，Kotlin 当中的交叉类型和联合类型都是不能直接声明的，只是会在某些语法现象中产生，例如类型智能转换等等。一旦产生了这样的类型，Kotlin 会采用类型近似、类型退化等手段来找到一个现有类型系统中合适的类型来表达它们。</p><h2 id="4-为什么不直接支持交叉类型和联合类型呢？"><a href="#4-为什么不直接支持交叉类型和联合类型呢？" class="headerlink" title="4. 为什么不直接支持交叉类型和联合类型呢？"></a>4. 为什么不直接支持交叉类型和联合类型呢？</h2><p>其实这个问题已经争论了挺久了。从各方的讨论来看，目前 Kotlin 没有正式引入这样的类型主要有以下原因：</p><ol><li>伪需求。支持引入这个特性的开发者提供的一些 use case 多数情况下可以通过诸如函数重载、泛型约束等特性来实现，有些情况下实际上更应该优化类型设计而不是寄希望于一个更复杂的类型系统。</li><li>存在滥用风险。类型系统复杂一点点，带来的项目代码的复杂度提升可能都会是巨大的。这一点从 Kotlin 对函数类型的支持上就可见一斑，当然不同之处在于函数类型确实是刚需。</li></ol><p>对于这个问题大家怎么看呢？留言说出你的看法吧。</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="type" scheme="https://www.bennyhuo.com/tags/type/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 1.4 新特性预览</title>
    <link href="https://www.bennyhuo.com/2020/03/26/kotlin-1.4-preview/"/>
    <id>https://www.bennyhuo.com/2020/03/26/kotlin-1.4-preview/</id>
    <published>2020-03-25T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。</p></blockquote><a id="more"></a><h2 id="1-安装-Kotlin-1-4"><a href="#1-安装-Kotlin-1-4" class="headerlink" title="1. 安装 Kotlin 1.4"></a>1. 安装 Kotlin 1.4</h2><p>Kotlin 1.4 的第一个里程碑版本发布了，具体发布信息可以在<a href="https://github.com/JetBrains/kotlin/blob/1.4-M1/ChangeLog.md" target="_blank" rel="noopener">这里查看</a>。</p><p>生产环境当中最好仍然使用 Kotlin 的稳定版本（例如最新的 1.3.71），如果你想要立刻马上体验 1.4 的新特性，那么我的建议是先安装一个 EAP 版本的 IntelliJ IDEA EAP 版本是 IntelliJ IDEA 2020.1 Beta，然后再在这个版本的 IntelliJ 上安装最新版的 Kotlin 插件，这样既可以继续使用 1.3 做项目，又不耽误体验新特性：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-10-40.png" alt=""></p><p><strong><center>图 1：IntelliJ IDEA EAP 版本与正式版可以共存</center></strong></p><p>安装 Kotlin 1.4 的插件方法想必大家都已经轻车熟路了，打开设置，搜 Kotlin，找到插件版本管理的下拉菜单，选择 Early Access Preview 1.4.x 即可：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-20-21.png" alt=""></p><p><strong><center>图 2：升级 Kotlin 插件</center></strong></p><p>好了，重启 IntelliJ，新建一个工程试试看吧~~</p><h2 id="2-主要的语法更新"><a href="#2-主要的语法更新" class="headerlink" title="2. 主要的语法更新"></a>2. 主要的语法更新</h2><p>接下来我们就按照官方博客给出的介绍 <a href="https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-4-m1-released/" target="_blank" rel="noopener">Kotlin 1.4-M1 Released</a> 来体验下新特性。</p><p>本文源码均已整理至 GitHub：<a href="https://github.com/enbandari/Kotlin1.4FeaturesSample" target="_blank" rel="noopener">Kotlin1.4FeaturesSample</a>。</p><h3 id="2-1-Kotlin-接口和函数的-SAM-转换"><a href="#2-1-Kotlin-接口和函数的-SAM-转换" class="headerlink" title="2.1 Kotlin 接口和函数的 SAM 转换"></a>2.1 Kotlin 接口和函数的 SAM 转换</h3><p>一个就是大家期待已久的 Kotlin 接口和函数的 SAM 转换。得益于新的类型推导算法，之前一直只有调用接收 Java 单一方法接口的 Java 的方法时才可以有 SAM 转换，现在这个问题不存在了，且看例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意 fun interface 是新特性</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin 函数，参数为 Kotlin 单一方法接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runAction</span><span class="params">(a: <span class="type">Action</span>)</span></span> = a.run()</span><br><span class="line"><span class="comment">// Kotlin 函数，参数为 Java 单一方法接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runRunnable</span><span class="params">(r: <span class="type">Runnable</span>)</span></span> = r.run()</span><br></pre></td></tr></table></figure><p>在 1.4 以前，我们只能：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runAction(<span class="keyword">object</span>: Action&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Not good.."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runAction(Action &#123; println(<span class="string">"Not good.."</span>) &#125;)</span><br></pre></td></tr></table></figure><p>runRunnable 函数虽然接收的是 Java 的接口，同样不支持 SAM。</p><p>现在在 1.4 当中呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runAction &#123; println(<span class="string">"Hello, Kotlin 1.4!"</span>) &#125;</span><br><span class="line">runRunnable &#123; println(<span class="string">"Hello, Kotlin 1.4!"</span>) &#125;</span><br></pre></td></tr></table></figure><p>真是妙啊。</p><h3 id="2-2-类型推导支持了更多的场景"><a href="#2-2-类型推导支持了更多的场景" class="headerlink" title="2.2 类型推导支持了更多的场景"></a>2.2 类型推导支持了更多的场景</h3><p>类型推导让 Kotlin 的语法获得了极大的简洁性。不过，大家在使用 Kotlin 开发时，一定会发现有些情况下明明类型是很确定的，编译器却一定要让我们显式的声明出来，这其实就是类型推导算法没有覆盖到的场景了。</p><p>例如以下代码在 Kotlin 1.3 当中会提示类型不匹配的问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rulesMap: Map&lt;String, (String?) -&gt; <span class="built_in">Boolean</span>&gt; = mapOf(</span><br><span class="line">    <span class="string">"weak"</span> to &#123; it != <span class="literal">null</span> &#125;,</span><br><span class="line">    <span class="string">"medium"</span> to &#123; !it.isNullOrBlank() &#125;,</span><br><span class="line">    <span class="string">"strong"</span> to &#123; it != <span class="literal">null</span> &amp;&amp; <span class="string">"^[a-zA-Z0-9]+$"</span>.toRegex().matches(it) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-47-00.png" alt=""></p><p><strong><center>图 3：Kotlin 1.3 中提示类型不匹配</center></strong></p><p>博客原文中给出的这个例子乍一看挺复杂，仔细想想问题主要在于我们可以通过 rulesMap 的类型来确定 mapOf 的返回值类型，进而再确定出 mapOf 的参数类型，即 Pair 的泛型参数类型。类型信息是充分的，不过这段代码在 Kotlin 1.4 以前是无法通过编译的，应该是类型推导的层次有点儿多导致算法没有覆盖到。好在新的推导算法解决了这个问题，能够应付更加复杂的推导场景。</p><h3 id="2-3-Lambda-表达式最后一行的智能类型转换"><a href="#2-3-Lambda-表达式最后一行的智能类型转换" class="headerlink" title="2.3 Lambda 表达式最后一行的智能类型转换"></a>2.3 Lambda 表达式最后一行的智能类型转换</h3><p>这个比较容易理解，直接看例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = run &#123;</span><br><span class="line">    <span class="keyword">var</span> str = currentValue()</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">        str = <span class="string">"test"</span></span><br><span class="line">    &#125;</span><br><span class="line">    str <span class="comment">// the Kotlin compiler knows that str is not null here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The type of 'result' is String? in Kotlin 1.3 and String in Kotlin 1.4</span></span><br></pre></td></tr></table></figure><p>这里 result 作为 run 的返回值，实际上也是 run 的参数 Lambda 的返回值，因此它的类型需要通过 str 的类型来推断。</p><p>在 1.3 当中，str 的类型是可以推断成 String 的，因为 str 是个局部变量，对它的修改是可控的。问题在于虽然 str 被推断为 String 类型，Lambda 表达式的返回值类型却没有使用推断的类型 String 来判断，而是选择使用了 str 的声明类型 String?。</p><p>在 1.4 解决了这个问题，既然 str 可以被推断为 String，那么 Lambda 表达式的结果自然就是 String 了。</p><p>稍微提一下，IntelliJ 的类型提示貌似有 bug，有些情况下会出现不一致的情况：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-12-55-09.png" alt=""></p><p><strong><center>图 4：疑似 IntelliJ 行内的类型提示的 bug</center></strong></p><p>我们可以通过快捷键查看 result 的类型为 String，但是行内的类型提示却为 String?，不过这个不影响程序的运行。</p><p>当然，有些开发者经常会抱怨类似下面的这种情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="string">"Hello"</span></span><br><span class="line">    <span class="keyword">if</span>(x != <span class="literal">null</span>)&#123;</span><br><span class="line">        println(x.length) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我明明已经判断了 x 不为空，为什么却不能自动推导成 String？请一定要注意，这种情况不是类型推导算法的问题，而是 x 的类型确实无法推导，因为对于一个共享的可变变量来讲，任何前一秒的判断都无法作为后一秒的依据。</p><h3 id="2-4-带有默认参数的函数的类型支持"><a href="#2-4-带有默认参数的函数的类型支持" class="headerlink" title="2.4 带有默认参数的函数的类型支持"></a>2.4 带有默认参数的函数的类型支持</h3><p>如果一个函数有默认参数，我们在调用它的时候就可以不传入这个参数了，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span> = <span class="number">0</span>)</span></span>: String = <span class="string">"<span class="variable">$i</span>!"</span></span><br></pre></td></tr></table></figure><p>调用的时候既可以是 foo() 也可以是 foo(5)，看上去就如同两个函数一样。在 1.4 以前，如果我们想要获取它的引用，就只能获取到 (Int) -&gt; String 这样的类型，显得不是很方便，现在这个问题解决了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">apply1</span><span class="params">(func: () -&gt; <span class="type">String</span>)</span></span>: String = func()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">apply2</span><span class="params">(func: (<span class="type">Int</span>) -&gt; <span class="type">String</span>)</span></span>: String = func(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(apply1(::foo))</span><br><span class="line">    println(apply2(::foo))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过请注意，通常情况下 ::foo 的类型始终为 (Int) -&gt; String，除了作为参数传递给接收 () -&gt; String 的情况下编译器会自动帮忙转换以外，其他情况下是不可以的。</p><h3 id="2-5-属性代理的类型推导"><a href="#2-5-属性代理的类型推导" class="headerlink" title="2.5 属性代理的类型推导"></a>2.5 属性代理的类型推导</h3><p>在推断代理表达式的类型时，以往不会考虑属性代理的类型，因此我们经常需要在代理表达式中显式的声明泛型参数，下面的例子就是这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prop: String? <span class="keyword">by</span> Delegates.observable(<span class="literal">null</span>) &#123; p, old, new -&gt;</span><br><span class="line">        println(<span class="string">"<span class="variable">$old</span> → <span class="variable">$new</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    prop = <span class="string">"abc"</span></span><br><span class="line">    prop = <span class="string">"xyz"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子在 1.4 中可以运行，但如果是在 1.3 当中，就需要明确泛型类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prop: String? <span class="keyword">by</span> Delegates.observable&lt;String?&gt;(<span class="literal">null</span>) &#123; p, old, new -&gt;</span><br><span class="line">    println(<span class="string">"<span class="variable">$old</span> → <span class="variable">$new</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-混合位置参数和具名参数"><a href="#2-6-混合位置参数和具名参数" class="headerlink" title="2.6 混合位置参数和具名参数"></a>2.6 混合位置参数和具名参数</h3><p>位置参数就是按位置传入的参数，Java 当中只有位置参数，是大家最熟悉的写法。Kotlin 支持了具名参数，那么入参时二者混合使用会怎样呢？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-06-09.png" alt=""></p><p><strong><center>图 5：1.3 当中不允许在具名参数之后添加位置参数</center></strong></p><p>1.3 当中，第三个参数会提示错误，理由就是位置参数前面已经有了具名参数了，这是禁止的。这样主要的目的也是希望开发者能够避免写出混乱的入参例子，不过这个例子似乎并不会有什么令人疑惑的地方，于是 1.4 我们可以在具名参数后面跟位置参数啦。</p><p>其实这个特性并不会对入参有很大的影响。首先位置参数的位置仍然必须是对应的，其次具名参数的位置也不能乱来。例如我们为例子中的 a 添加一个默认值：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-16-35.png" alt=""></p><p><strong><center>图 6：1.4 当中具名参数之后添加位置参数需要保证位置对应</center></strong></p><p>注意图 6 是 1.4 环境下的情形，这样调用时我们就可以不必显式的传入 a 的值了，这时候直觉告诉我参数 b 后面的参数应该是 c，然而编译器却不领情。这样看来，即便是在 1.4 当中，我们也需要确保具名参数和位置参数与形参的位置对应才能在具名参数之后添加位置参数。</p><p>因此，我个人的建议是对于参数比较多且容易混淆的情形最好都以具名参数的形式给出，对于参数个数较少的情形则可以全部采用位置参数。在这里还有另外的一个建议就是函数的参数不宜过多，参数越多意味着函数复杂度越高，越可能需要重构。</p><h3 id="2-7-优化属性代理的编译"><a href="#2-7-优化属性代理的编译" class="headerlink" title="2.7 优化属性代理的编译"></a>2.7 优化属性代理的编译</h3><p>如果大家自己写过属性代理类的话，一定知道 get 和 set 两个函数都有一个 KProperty 的参数，这个参数其实就是被代理的属性。为了获取这个参数，编译器会生成一个数组来存放这代理的属性，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> lazyProp <span class="keyword">by</span> lazy &#123; <span class="number">42</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后生成的字节码反编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">bennyhuo</span>.<span class="title">kotlin</span>.<span class="title">MyOtherClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> kotlin.reflect.KProperty[] $$delegatedProperties;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getLazyProp</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> com.bennyhuo.kotlin.MyOtherClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 $$delegatedProperties 这个数组就是我们所说的存被代理的属性的数组。不过，绝大多数的属性代理其实不会用到 KProperty 对象，因此无差别的生成这个数组其实存在一定的浪费。</p><p>因此对于属性代理类的 get 和 set 函数实现为内联函数的情形，编译器可以确切的分析出 KProperty 是否被用到，如果没有被用到，那么就不会生成这个 KProperty 对象。</p><p>这里还有一个细节，如果一个类当中同时存在用到和没用到 KProperty 对象的两类属性代理，那么生成的数组在 1.4 当中只包含用到的 KProperty 对象，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> lazyProp <span class="keyword">by</span> lazy &#123; <span class="number">42</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> myProp: String <span class="keyword">by</span> Delegates.observable(<span class="string">"&lt;no name&gt;"</span>) &#123;</span><br><span class="line">            kProperty, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">"<span class="subst">$&#123;kProperty.name&#125;</span>: <span class="variable">$oldValue</span> -&gt; <span class="variable">$newValue</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 myProp 用到了 KProperty 对象，lazyProp 没有用到，那么生成的 $$delegatedProperties 当中就只包含 myProp 的属性引用了。</p><h3 id="2-8-参数列表最后的逗号"><a href="#2-8-参数列表最后的逗号" class="headerlink" title="2.8 参数列表最后的逗号"></a>2.8 参数列表最后的逗号</h3><p>这个需求别看小，非常有用。我们来看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(</span><br><span class="line">        <span class="string">"bennyhuo"</span>,</span><br><span class="line">        <span class="number">30</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person 类有多个参数，传参的时候就会出现前面的参数后面都有个逗号，最后一个没有。这样看上去好像也没什么问题是吧？那有可能你没有用到过多行编辑：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-04-01.png" alt=""></p><p><strong><center>图 7：多行编辑逗号的问题</center></strong></p><p>这里这个逗号有时候会特别碍事儿，但如何每一行都可以有一个逗号这个问题就简单多了：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-05-25.png" alt=""></p><p><strong><center>图 8：多行编辑所有参数</center></strong></p><p>除了这个场景之外，还有就是调整参数列表的时候，例如我给 Person 在最后加了个 id，我还得单独给 age 的参数后面加个逗号：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-08-36.png" alt=""></p><p><strong><center>图 9：增加参数给原来的参数加逗号</center></strong></p><p>这时候我又觉得 id 应该放到最前面，于是做了个复制粘贴，发现还是要修改逗号。当然，最后的这个功能 IntelliJ 有个快捷键可以直接交换行，同时帮我们自动处理逗号的问题，不过整体上这个小功能还是很有意思的。</p><p>说起来，JavaScript 当中的对象字面量当中也允许最后一个字段后面加逗号：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-12-48.png" alt=""></p><p><strong><center>图 10：JavaScript 的对象字面量</center></strong></p><p>不过请注意，尽管它与 JSON 有着深厚的渊源，但 JSON 的最后一个字段后面是不允许加逗号的（当然还有字段要加引号）。</p><h3 id="2-9-when-表达式中使用-continue-和-break"><a href="#2-9-when-表达式中使用-continue-和-break" class="headerlink" title="2.9 when 表达式中使用 continue 和 break"></a>2.9 when 表达式中使用 continue 和 break</h3><p>continue 和 break 的含义没有任何变化，这二者仍然在循环当中使用，只不过循环内部的 when 表达式当中在之前是不可以使用 continue 和 break 的，按照官方的说法，他们之前有意将 continue 或者 break 用作 when 表达式条件 fallthrough 的，不过看样子现在还没想好，只是不想再耽误 continue 和 break 的正常功能了。</p><h3 id="2-10-尾递归函数的优化"><a href="#2-10-尾递归函数的优化" class="headerlink" title="2.10 尾递归函数的优化"></a>2.10 尾递归函数的优化</h3><p>尾递归函数估计大家用的不多，这里主要有两个优化点</p><ul><li>尾递归函数的默认参数的初始化顺序改为从左向右：</li><li>尾递归函数不能声明为 open 的，即不能被子类覆写，因为尾递归函数的形式有明确的要求，即函数的最后一个操作必须只能是调用自己，父类的函数声明为 tailrec 并不能保证子类能够正确地按要求覆写，于是产生矛盾。</li></ul><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-25-23.png" alt=""></p><p><strong><center>图 11：1.4 中尾递归函数的默认参数列表初始化顺序</center></strong></p><h3 id="2-11-契约的支持"><a href="#2-11-契约的支持" class="headerlink" title="2.11 契约的支持"></a>2.11 契约的支持</h3><p>从 1.3 开始，Kotlin 引入了一个实验特性契约（Contract），主要来应对一些“显而易见”情况下的类型推导或者智能类型转换。</p><p>在 1.4 当中，这个特性仍然会继续保持实验状态，不过有两项改进：</p><ul><li>支持使用内联特化的函数来实现契约</li><li>1.3当中不能为成员函数添加契约，从1.4开始支持为 final 的成员函数添加契约（当然任意成员函数可能存在被覆写的问题，因而不能添加）</li></ul><h3 id="2-12-其他的一些改动"><a href="#2-12-其他的一些改动" class="headerlink" title="2.12 其他的一些改动"></a>2.12 其他的一些改动</h3><p>除了语法上的明显的改动之外，1.4 当中也直接移除了 1.1-1.2 当中协程的实验阶段的 API，有条件的情况下应该尽快去除对废弃的协程 API 的使用，如果暂时无法完成迁移，也可以使用协程的兼容包 kotlin-coroutines-experimental-compat.jar。</p><p>剩下的主要就是针对编译器、使用体验的各种优化了，实际上这才是 Kotlin 1.4 最重要的工作。这些内容相对抽象，我就不做介绍了。</p><p>补充一点，在本文撰写过程中，我使用 IntelliJ IDEA 2019.3.3 来运行 Kotlin 1.3，使用 IntelliJ IDEA 2020.1 BETA 来运行 Kotlin 1.4-M1，结果发现后者的代码提示速度似乎有明显的提升，不知道是不是我的错觉，大家可以自行感受下并发表你的评论。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>Kotlin 目前的语法已经比较成熟了，还是那句话，提升开发体验，扩展应用场景才是它现在最应该发力的点。</p><p>未来可期。</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="release" scheme="https://www.bennyhuo.com/tags/release/"/>
    
      <category term="news" scheme="https://www.bennyhuo.com/tags/news/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(11) - Flow 篇</title>
    <link href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/"/>
    <id>https://www.bennyhuo.com/2020/03/14/coroutine-flow/</id>
    <published>2020-03-13T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。</p></blockquote><a id="more"></a><p>随着 RxJava 的流行，响应式编程模型逐步深入人心。<code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物。</p><p><em>本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶段，后续也可能会发生细微的调整。</em></p><h2 id="认识-Flow"><a href="#认识-Flow" class="headerlink" title="认识 Flow"></a>认识 Flow</h2><p>介绍 <code>Flow</code> 之前，我们先来回顾下序列生成器：</p><p><strong>代码清单1： 序列生成器</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ints = sequence &#123;</span><br><span class="line">  (<span class="number">1</span>..<span class="number">3</span>).forEach &#123; </span><br><span class="line">    yield(it)</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次访问 <code>ints</code> 的下一个元素的时候它就执行内部的逻辑直到遇到 <code>yield</code>，如果我希望在元素之间加个延时呢？</p><p><strong>代码清单2：序列生成器中不能调用其他挂起函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ints = sequence &#123;</span><br><span class="line">  (<span class="number">1</span>..<span class="number">3</span>).forEach &#123; </span><br><span class="line">    yield(it)</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// ERROR!</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受 <code>RestrictsSuspension</code> 注解的约束，<code>delay</code> 不能在 <code>SequenceScope</code> 的扩展成员当中被调用，因而不能在序列生成器的协程体内调用了。</p><p>假设序列生成器不受这个限制，调用 <code>delay</code> 会导致后续的执行流程的线程发生变化，外部的调用者发现在访问 <code>ints</code> 的下一个元素的时候居然还会有切换线程的副作用，这个是不是算一个“惊喜”呢？不仅如此，我想通过指定调度器来限定序列创建所在的线程，同样是不可以的，我们甚至没有办法为它设置协程上下文。</p><p>既然序列生成器有这么多限制，那我们是时候需要认识一下 <code>Flow</code> 了。它的 API 与序列生成器极为相似：</p><p><strong>代码清单3：创建 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intFlow = flow &#123;</span><br><span class="line">  (<span class="number">1</span>..<span class="number">3</span>).forEach &#123; </span><br><span class="line">    emit(it)</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新元素通过 <code>emit</code> 函数提供，Flow 的执行体内部也可以调用其他挂起函数，这样我们就可以在每次提供一个新元素后再延时 100ms 了。</p><p>Flow 也可以设定它运行时所使用的调度器：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intFlow.flowOn(Dispatchers.IO)</span><br></pre></td></tr></table></figure><p>通过 <code>flowOn</code> 设置的调度器只对它之前的操作有影响，因此这里意味着 intFlow 的构造逻辑会在 <code>IO</code> 调度器上执行。</p><p>最终消费 <code>intFlow</code> 需要调用 <code>collect</code> 函数，这个函数也是一个挂起函数，我们启动一个协程来消费 <code>intFlow</code>：</p><p><strong>代码清单4： 消费 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(myDispatcher) &#123;</span><br><span class="line">  intFlow.flowOn(Dispatchers.IO)</span><br><span class="line">    .collect &#123; println(it) &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><p>为了区分调度器，我们为协程设置了一个自定义的调度器，它会将协程调度到名叫 <code>MyThread</code> 的线程上，结果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[MyThread] <span class="number">1</span></span><br><span class="line">[MyThread] <span class="number">2</span></span><br><span class="line">[MyThread] <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="对比-RxJava-的线程切换"><a href="#对比-RxJava-的线程切换" class="headerlink" title="对比 RxJava 的线程切换"></a>对比 RxJava 的线程切换</h2><p>RxJava 也是一个基于响应式编程模型的异步框架，它提供了两个切换调度器的 API 分别是 <code>subscribeOn</code> 和 <code>observeOn</code>：</p><p><strong>代码清单5：RxJava 的调度器切换</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">  (<span class="number">1</span>..<span class="number">3</span>).forEach &#123; e -&gt;</span><br><span class="line">    it.onNext(e)</span><br><span class="line">  &#125;</span><br><span class="line">  it.onComplete()</span><br><span class="line">&#125;.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(Schedulers.from(myExecutor))</span><br><span class="line">.subscribe &#123;</span><br><span class="line">  println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>subscribeOn</code> 指定的调度器影响前面的逻辑，<code>observeOn</code> 影响的是后面的逻辑，因此 <code>it.onNext(e)</code> 执行在它的 <code>io</code> 这个调度器上，而最后的 <code>println(it)</code> 执行在通过 <code>myExecutor</code> 创建出来的调度器上。</p><p>Flow 的调度器 API 中看似只有 <code>flowOn</code> 与 <code>subscribeOn</code> 对应，其实不然， <code>collect</code> 所在协程的调度器则与 <code>observeOn</code> 指定的调度器对应。</p><p>在 RxJava 的学习和使用过程中， <code>subscribeOn</code> 和 <code>observeOn</code> 经常容易被混淆；而在 Flow 当中 <code>collect</code> 所在的协程自然就是观察者，它想运行在什么调度器上它自己指定即可，非常容易区分。</p><h2 id="冷数据流"><a href="#冷数据流" class="headerlink" title="冷数据流"></a>冷数据流</h2><p>一个 Flow 创建出来之后，不消费则不生产，多次消费则多次生产，生产和消费总是相对应的。</p><p><strong>代码清单6：Flow 可以被重复消费</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><p><code>intFlow</code> 就是本节最开始我们创建的 Flow，消费它会输出 1,2,3，重复消费它会重复输出 1,2,3。</p><p>这一点其实类似于我们前面提到的 <code>sequence</code> 和 RxJava 例子，它们也都有自己的消费端。我们创建一个序列然后去迭代它，每次迭代都会创建一个新的迭代器从头开始迭代；RxJava 的 <code>Observable</code> 也是如此，每次调用它的 <code>subscribe</code> 都会重新消费一次。</p><p>所谓<strong>冷</strong>数据流，就是只有消费时才会生产的数据流，这一点与 <code>Channel</code> 正对应：<code>Channel</code> 的发送端并不依赖于接收端。</p><blockquote><p><strong>说明</strong> RxJava 也存在热数据流，可以通过一定的手段实现冷热数据流的转化。不过相比之下，冷数据流的应用场景更为丰富。</p></blockquote><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Flow 的异常处理也比较直接，直接调用 <code>catch</code> 函数即可：</p><p><strong>代码清单7：捕获 Flow 的异常</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">"Div 0"</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">"caught error: <span class="variable">$t</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 Flow 的参数中抛了一个异常，在 <code>catch</code> 函数中就可以直接捕获到这个异常。如果没有调用 <code>catch</code> 函数，未捕获异常会在消费时抛出。请注意，<code>catch</code> 函数只能捕获它的上游的异常。</p><p>如果我们想要在流完成时执行逻辑，可以使用 <code>onCompletion</code>：</p><p><strong>代码清单8：订阅流的完成</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">"Div 0"</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">"caught error: <span class="variable">$t</span>"</span>)</span><br><span class="line">&#125;.onCompletion &#123; t: Throwable? -&gt;</span><br><span class="line">  println(<span class="string">"finally."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onCompletion</code> 用起来比较类似于 <code>try ... catch ... finally</code> 中的 <code>finally</code>，无论前面是否存在异常，它都会被调用，参数 <code>t</code> 则是前面未捕获的异常。</p><p>Flow 的设计初衷是希望确保流操作中异常透明。因此，以下写法是违反 Flow 的设计原则的：</p><p><strong>代码清单9：命令式的异常处理（不推荐）</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flow &#123; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    emit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> ArithmeticException(<span class="string">"Div 0"</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (t: Throwable)&#123;</span><br><span class="line">    println(<span class="string">"caught error: <span class="variable">$t</span>"</span>)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    println(<span class="string">"finally."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在流操作内部使用 <code>try ... catch ... finally</code> 这样的写法后续可能被禁用。</p><p>在 RxJava 当中还有 <code>onErrorReturn</code> 类似的操作：</p><p><strong>代码清单10：RxJava 从异常中恢复</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> observable = Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;.onErrorReturn &#123;</span><br><span class="line">  println(t)</span><br><span class="line">  <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获异常后，返回 10 作为下一个值。</p><p>我们在 Flow 当中也可以模拟这样的操作：</p><p><strong>代码清单11：Flow 从异常中恢复</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">"Div 0"</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">"caught error: <span class="variable">$t</span>"</span>)</span><br><span class="line">  emit(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以使用 <code>emit</code> 重新生产新元素出来。细心的读者一定会发现，<code>emit</code> 定义在 <code>FlowCollector</code> 当中，因此只要遇到 Receiver 为 <code>FlowCollector</code> 的函数，我们就可以生产新元素。</p><blockquote><p><strong>说明</strong> onCompletion 预计在协程框架的 1.4 版本中会被重新设计，之后它的作用类似于 RxJava 中 Subscriber 的 onComplete，即作为整个 Flow 的完成回调使用，回调的参数也将包含整个 Flow 的未捕获异常，参见 GitHub Issue：<a href="https://github.com/Kotlin/kotlinx.coroutines/pull/1732" target="_blank" rel="noopener">Breaking change: Experimental Flow.onCompletion contract for cause #1732</a>。</p></blockquote><h2 id="末端操作符"><a href="#末端操作符" class="headerlink" title="末端操作符"></a>末端操作符</h2><p>前面的例子当中，我们用 <code>collect</code> 消费 Flow 的数据。<code>collect</code> 是最基本的<strong>末端操作符</strong>，功能与 RxJava 的 <code>subscribe</code> 类似。除了 <code>collect</code> 之外，还有其他常见的末端操作符，大体分为两类：</p><ol><li>集合类型转换操作，包括 <code>toList</code>、<code>toSet</code> 等。</li><li>聚合操作，包括将 Flow 规约到单值的 <code>reduce</code>、<code>fold</code> 等操作，以及获得单个元素的操作包括 <code>single</code>、<code>singleOrNull</code>、<code>first</code> 等。</li></ol><p>实际上，识别是否为末端操作符，还有一个简单方法，由于 Flow 的消费端一定需要运行在协程当中，因此末端操作符都是挂起函数。</p><h2 id="分离-flow-的消费和触发"><a href="#分离-flow-的消费和触发" class="headerlink" title="分离 flow 的消费和触发"></a>分离 flow 的消费和触发</h2><p>我们除了可以在 <code>collect</code> 处消费 Flow 的元素以外，还可以通过 <code>onEach</code> 来做到这一点。这样消费的具体操作就不需要与末端操作符放到一起，<code>collect</code> 函数可以放到其他任意位置调用，例如：</p><p><strong>代码清单12：分离 Flow 的消费和触发</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createFlow</span><span class="params">()</span></span> = flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).forEach &#123;</span><br><span class="line">      emit(it)</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.onEach &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  GlobalScope.launch &#123;</span><br><span class="line">    createFlow().collect()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此，我们又可以衍生出一种新的消费 Flow 的写法：</p><p><strong>代码清单13：使用协程作用域直接触发 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  createFlow().launchIn(GlobalScope)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>launchIn</code> 函数只接收一个 <code>CoroutineScope</code> 类型的参数。</p><h2 id="Flow-的取消"><a href="#Flow-的取消" class="headerlink" title="Flow 的取消"></a>Flow 的取消</h2><p>Flow 没有提供取消操作，原因很简单：不需要。</p><p>我们前面已经介绍了 Flow 的消费依赖于 <code>collect</code> 这样的末端操作符，而它们又必须在协程当中调用，因此 Flow 的取消主要依赖于末端操作符所在的协程的状态。</p><p><strong>代码清单14：Flow 的取消</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">  <span class="keyword">val</span> intFlow = flow &#123;</span><br><span class="line">    (<span class="number">1</span>..<span class="number">3</span>).forEach &#123;</span><br><span class="line">      delay(<span class="number">1000</span>)</span><br><span class="line">      emit(it)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">2500</span>)</span><br><span class="line">job.cancelAndJoin()</span><br></pre></td></tr></table></figure><p>每隔 1000ms 生产一个元素，2500ms 以后协程被取消，因此最后一个元素生产前 Flow 就已经被取消，输出为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">▶ <span class="number">1000</span>ms later</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>如此看来，想要取消 Flow 只需要取消它所在的协程即可。</p><h2 id="其他-Flow-的创建方式"><a href="#其他-Flow-的创建方式" class="headerlink" title="其他 Flow 的创建方式"></a>其他 Flow 的创建方式</h2><p>我们已经知道了 <code>flow { ... }</code> 这种形式的创建方式，不过在这当中无法随意切换调度器，这是因为 <code>emit</code> 函数不是线程安全的：</p><p><strong>代码清单15：不能在 Flow 中直接切换调度器</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flow &#123; <span class="comment">// BAD!!</span></span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  withContext(Dispatchers.IO)&#123;</span><br><span class="line">    emit(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在生成元素时切换调度器，就必须使用 <code>channelFlow</code> 函数来创建 Flow：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channelFlow &#123;</span><br><span class="line">  send(<span class="number">1</span>)</span><br><span class="line">  withContext(Dispatchers.IO) &#123;</span><br><span class="line">    send(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，我们也可以通过集合框架来创建 Flow：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asFlow()</span><br><span class="line">setOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asFlow()</span><br><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="Flow-的背压"><a href="#Flow-的背压" class="headerlink" title="Flow 的背压"></a>Flow 的背压</h2><p>只要是响应式编程，就一定会有背压问题，我们先来看看背压究竟是什么。</p><p>背压问题在生产者的生产速率高于消费者的处理速率的情况下出现。为了保证数据不丢失，我们也会考虑添加缓存来缓解问题：</p><p><strong>代码清单16：为 Flow 添加缓冲</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.buffer()</span><br></pre></td></tr></table></figure><p>我们也可以为 <code>buffer</code> 指定一个容量。不过，如果我们只是单纯地添加缓存，而不是从根本上解决问题就始终会造成数据积压。</p><p>问题产生的根本原因是生产和消费速率的不匹配，除直接优化消费者的性能以外，我们也可以采取一些取舍的手段。</p><p>第一种是 <code>conflate</code>。与 <code>Channel</code> 的 <code>Conflate</code> 模式一致，新数据会覆盖老数据，例如：</p><p><strong>代码清单17：使用 conflate 解决背压问题</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.conflate()</span><br><span class="line">.collect &#123; value -&gt;</span><br><span class="line">  println(<span class="string">"Collecting <span class="variable">$value</span>"</span>)</span><br><span class="line">  delay(<span class="number">100</span>) </span><br><span class="line">  println(<span class="string">"<span class="variable">$value</span> collected"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们快速地发送了 100 个元素，最后接收到的只有两个，当然这个结果每次都不一定一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting <span class="number">1</span></span><br><span class="line"><span class="number">1</span> collected</span><br><span class="line">Collecting <span class="number">99</span></span><br><span class="line"><span class="number">99</span> collected</span><br></pre></td></tr></table></figure><p>第二种是 <code>collectLatest</code>。顾名思义，只处理最新的数据，这看上去似乎与 <code>conflate</code> 没有区别，其实区别大了：它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p><p>还是前面的例子，我们稍作修改：</p><p><strong>代码清单18：使用 collectLatest 解决背压问题</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.collectLatest &#123; value -&gt;</span><br><span class="line">  println(<span class="string">"Collecting <span class="variable">$value</span>"</span>)</span><br><span class="line">  delay(<span class="number">100</span>)</span><br><span class="line">  println(<span class="string">"<span class="variable">$value</span> collected"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collecting 0</span><br><span class="line">Collecting 1</span><br><span class="line">...</span><br><span class="line">Collecting 97</span><br><span class="line">Collecting 98</span><br><span class="line">Collecting 99</span><br><span class="line">▶ 100ms later</span><br><span class="line">99 collected</span><br></pre></td></tr></table></figure><p>前面的 <code>Collecting</code> 输出了 0 ~ 99 的所有结果，而 <code>collected</code> 却只有 99，因为后面的数据到达时，处理上一个数据的操作正好被挂起了（请注意<code>delay(100)</code>）。</p><p>除 <code>collectLatest</code> 之外还有 <code>mapLatest</code>、<code>flatMapLatest</code> 等等，都是这个作用。</p><h2 id="Flow-的变换"><a href="#Flow-的变换" class="headerlink" title="Flow 的变换"></a>Flow 的变换</h2><p>我们已经对集合框架的变换非常熟悉了，<code>Flow</code> 看上去极其类似于这样的数据结构，这一点与 RxJava 的 <code>Observable</code> 的表现也基本一致。</p><p>例如我们可以使用 <code>map</code> 来变换 <code>Flow</code> 的数据：</p><p><strong>代码清单19：Flow 的元素变换</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123; </span><br><span class="line">  it * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以映射成其他 Flow：</p><p><strong>代码清单20：Flow 的嵌套</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123;</span><br><span class="line">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上得到的是一个数据类型为 <code>Flow</code> 的 <code>Flow</code>，如果希望将它们拼接起来，可以使用 <code>flattenConcat</code>：</p><p><strong>代码清单21：拼接 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123;</span><br><span class="line">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class="line">&#125;.flattenConcat()</span><br><span class="line">  .collect &#123; println(it) &#125;</span><br></pre></td></tr></table></figure><p>拼接的操作中 <code>flattenConcat</code> 是按顺序拼接的，结果的顺序仍然是生产时的顺序；还有一个是 <code>flattenMerge</code>，它会并发拼接，因此结果不会保证顺序。</p><h2 id="使用-Flow-实现多路复用"><a href="#使用-Flow-实现多路复用" class="headerlink" title="使用 Flow 实现多路复用"></a>使用 Flow 实现多路复用</h2><p>多数情况下，我们可以通过构造合适的 Flow 来实现多路复用的效果。</p><p>上一篇文章<a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程(10) - Select 篇</a>中对 await 的复用我们可以用 Flow 实现如下：</p><p><strong>代码清单22：使用 Flow 实现对 await 的多路复用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">coroutineScope &#123;</span><br><span class="line">  <span class="keyword">val</span> login = <span class="string">"..."</span></span><br><span class="line">  listOf(::getUserFromApi, ::getUserFromLocal) ... ①</span><br><span class="line">    .map &#123; function -&gt;</span><br><span class="line">      function.call(login) ... ②</span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123; deferred -&gt;</span><br><span class="line">      flow &#123; emit(deferred.await()) &#125; ... ③</span><br><span class="line">    &#125;</span><br><span class="line">    .merge() ... ④</span><br><span class="line">    .onEach &#123; user -&gt;</span><br><span class="line">      println(<span class="string">"Result: <span class="variable">$user</span>"</span>)</span><br><span class="line">    &#125;.launchIn(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中，① 处用创建了两个函数引用组成的 List；② 处调用它们得到 deferred；③ 处比较关键，对于每一个 deferred 我们创建一个单独的 Flow，并在 Flow 内部发送 deferred.await() 返回的结果，即返回的 User 对象；现在我们有了两个 Flow 实例，我们需要将它们整合成一个 Flow 进行处理，调用 merge 函数即可。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png" alt=""></p><p><strong>图1：使用 merge 合并 Flow</strong></p><p>同样的，对 Channel 的读取复用的场景也可以使用 Flow 来完成。对照<a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程(10) - Select 篇</a>，我们给出 Flow 的实现版本：</p><p><strong>代码清单23：使用 Flow 实现对 Channel 的复用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channels = List(<span class="number">10</span>) &#123; Channel&lt;<span class="built_in">Int</span>&gt;() &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> result = channels.map &#123;</span><br><span class="line">    it.consumeAsFlow()</span><br><span class="line">  &#125;</span><br><span class="line">  .merge()</span><br><span class="line">  .first()</span><br></pre></td></tr></table></figure><p>这比 <code>select</code> 的版本看上去要更简洁明了，每个 Channel 都通过 <code>consumeAsFlow</code> 函数被映射成 Flow，再 merge 成一个 Flow，取第一个元素。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Flow</code> 是协程当中比较重要的异步工具，它的用法与其他类似的响应式编程框架非常相近，大家可以采取类比的学习方式去了解它的功能。</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;code&gt;Flow&lt;/code&gt; 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="flow" scheme="https://www.bennyhuo.com/tags/flow/"/>
    
      <category term="rxjava" scheme="https://www.bennyhuo.com/tags/rxjava/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 官网大变样？这是要干啥？</title>
    <link href="https://www.bennyhuo.com/2020/02/13/kotlin-news-202002/"/>
    <id>https://www.bennyhuo.com/2020/02/13/kotlin-news-202002/</id>
    <published>2020-02-12T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.207Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。</p></blockquote><a id="more"></a><p>最近有小伙伴提醒我，Kotlin 官网更新了，我打开一看直接吓尿：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-34-00.png" alt=""></p><p>这是要干啥？我听说过的没听说过的您这是都要承包吗？</p><p>最有意思的是居然把 Android 放到了最后，hmmm，Kotlin 开发者里面搞 Android 的应该是最多的吧？这么不受待见？</p><p>所以我有个大胆的想法，Kotlin 团队肯定觉得 Android 大军切换 Kotlin 指日可待，基本上稳稳的，所以过河拆桥：Android 已经不再是 Kotlin 唯一的大腿啦，你们看看，最前面的是移动端跨平台，原来谷爸爸的大腿刚捂热乎，就又抱上了果爸爸，真是不得了哇：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-38-52.png" alt=""></p><p>其实很早之前我们就一直在聊到 Kotlin 2019 年的重心一定在 Native 上，当时觉得可能是盯上了 5G 时代的物联网的机会？不过一年过去了，5G 手机我还没用上，这不小米 10 刚发布，正琢磨要不要换个呢，嵌入式领域 C 称霸天下哪里会那么快换代，再说还有 Go 和 Rust 虎视眈眈，哪儿有 Kotlin 什么事儿。</p><p>不过从 Android 起家的 Kotlin 横向切入 iOS 这个路子真的是很合适，用户群体都不用怎么变，还让过去不会 iOS 的 Android 开发者有了更多更容易的机会扩展自己的技术栈，即可以扩大自己的影响力，又给开发者带来福利，真是双赢 666。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-17-54-20.png" alt=""></p><p>当然，这个移动端跨平台并不是什么特别新鲜的事儿，毕竟开源项目嘛，没事儿刷刷 Kotlin 的 <a href="https://kotl.in/slack" target="_blank" rel="noopener">Slack</a>，啥都能提前知道。而且本身 Kotlin 跨平台共享代码从 1.2 刚开始公测就理论上包含了 Kotlin-Jvm@Android 和 Kotlin-Native@iOS 的代码共享能力，所以我们似乎不应该意外，我只是想说 JetBrains 居然把移动端跨平台专门上升到了这么高的优先级，还专门做了 Kotlin Native 与 Objective-C &amp; Swift 的互调用的支持，真是任性~~</p><p>如果过一段时间 Dukat 这个项目逐渐成熟，Kotlin-Js 的编译工具也进一步完善，特别是对 npm 依赖的管理能更加灵活（目前 Kotlin-js 的 Gradle 依赖当中不会自动携带 npm 依赖这个让人非常难受），JavaScript 常见的框架都有了自己的 Kotlin 接口声明，那时候我估计写到最前面的也许还会发生一些变化，那时候也许叫 “Kotlin for 大前端”？</p><p>说到这里有人担心 Kotlin 这是不是在跟 Flutter 叫板。显然不是嘛，Kotlin 跨平台一直都声称自己只是为了逻辑代码的共享，UI 大家还是用原生的就好啦。于是乎 Android 原来该用 ConstraintLayout 你就用你的 XML 布局，iOS 呢就还是用你的 storyboard。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-02-29.png" alt=""></p><p>Flutter 抢的是 UI 的饭碗，UI 层跨平台的问题解决了，有人就说我们底层的逻辑也选一套跨平台的方案好不好？这要是放到几年前，怕是没有别的选择了，C++ 是最好的语言；而现在，你可以选择 Kotlin，最为神奇的是 Kotlin 的跨平台和 C++ 的机制非常不同，它在 Android 上使用 Kotlin-Jvm，iOS 上则使用 Kotlin-Native。你要是非想在 Android 上使用 JNI 的话，Kotlin-Native 也已经支持了绝大多数 Android 的 CPU 架构。所以很早就有人发文章报告 Flutter + Kotlin-Native 实现移动端跨平台开发的优秀体验，所以 Flutter 该学就学，不矛盾。</p><p>而且它俩的这基友关系嘛。。。依我看，这 Logo 就已经说明一切了。。。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-06-19.png" alt=""></p><p>还有一个比较引人注目的就是 <strong>Data science</strong> 了吧。毕竟 Python 因为这个都火的不得了了，过去的一年里我已经鼓动我们组好几个小伙伴上手 Python，要恰饭的嘛，艺多不压身，免得错过一些项目的机会。现在好了，Kotlin 也能搞科学计算了，目测大概的切入思路暂时还是依托于强大的 Jvm，Java 能用的框架 Kotlin 自然能用，Java 不能直接用的，例如 Python numpy，可以 JNI 直接搞一个封装 <a href="https://github.com/Kotlin/kotlin-numpy" target="_blank" rel="noopener">kotlin-numpy</a>；等 Kotlin Native 翅膀硬了之后就更省事儿了，直接跟 C 玩去，连 Jvm 都用不着了。这么发展着，最后也许是我的当然是我的，你的也是我的。。。</p><p>忘了说了，现在已经有了 Jupyter 的 Kotlin 内核，所以以前在 Jupyter Notebook 里用 Python 写的代码也可以用 Kotlin 写了，贴一张官网的效果图：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-16-54-47.png" alt=""></p><p>很美是吧，之前 KotlinConf 2019 期间官博就发了一篇文章介绍这个能力，也可以参考一下：Making Kotlin Ready for Data Science [<a href="https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/" target="_blank" rel="noopener">原文</a>] [<a href="https://www.kotliner.cn/2020/01/making-kotlin-ready-for-data-science/" target="_blank" rel="noopener">中文翻译</a>]。</p><p>顺便提一句，调用 GPU 其实也是 IO 操作，我看了几个 cuda 的程序都很有意思，要么是阻塞调用，要么就是异步调用之后在主流程里死循环等待结果返回。这似乎与我们的 Socket 读写类似，异步的 API 可能在大规模调用时性能更好，但代码编写起来更加复杂。前几天读到一篇论文讲的就是如何使用 C++ 的协程来降低 GPU 编程的复杂度(<a href="https://iopscience.iop.org/article/10.1088/1742-6596/681/1/012048/pdf" target="_blank" rel="noopener">Integrating GPGPU computations with CPU coroutines in C++</a>)，随着 Kotlin Native 的逐渐成熟稳定，我们可以直接通过 C 接口编写 GPU 相关程序，Kotlin 协程也许可以为 GPU 编程带来一定的便利。</p><p>这么看来，预计在 2020年春天发布的 Kotlin 1.4 的形势也比较明朗了，正如 Kotlin 之父 Andrey 说的，这个版本没有什么太多的新特性。因为作为一门语言本身，Kotlin 已经比较成熟，现在最应当关注的是开发体验，开发效率，稳定性，易用性以及应用场景等等语言生态的内容。</p><p>我之前还比较担心 Kotlin Multiplatform 和 Kotlin Native 会不会借此机会正式发布，从官网的这次改动来看，这样的担心应该是多余的了。我们来回顾一下过去 Kotlin 的重要版本的发布时间：</p><ul><li>Kotlin 1.0：2016.2</li><li>Kotlin 1.1：2017.3（13个月之后）</li><li>Kotlin 1.2：2017.11（8个月之后）</li><li>Kotlin 1.3：2018.10（11个月之后）</li></ul><p>多数情况下 Kotlin 的大版本都是保持一年左右一个的（1.2 这个版本估计是趁着热度努力冲了一波 KPI，毕竟 2017 年 Kotlin 出名了），小版本大概两个月一个，所以一般小版本到 1.x.7 的时候也就是下一个大版本发布的时间。现在 1.3.70 已经 EAP 了一个多月了，你们懂我意思吧。</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="news" scheme="https://www.bennyhuo.com/tags/news/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(10) - Select 篇</title>
    <link href="https://www.bennyhuo.com/2020/02/03/coroutine-select/"/>
    <id>https://www.bennyhuo.com/2020/02/03/coroutine-select/</id>
    <published>2020-02-02T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。</p></blockquote><a id="more"></a><h2 id="复用多个-await"><a href="#复用多个-await" class="headerlink" title="复用多个 await"></a>复用多个 await</h2><p>我们前面已经接触了很多挂起函数，那么如果我有这样一个场景，两个 API 分别从网络和本地缓存获取数据，期望哪个先返回就先用哪个做展示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">getUserFromApi</span><span class="params">(login: <span class="type">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class="line">    gitHubServiceApi.getUserSuspend(login)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">getUserFromLocal</span><span class="params">(login:<span class="type">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class="line">    File(localDir, login).takeIf &#123; it.exists() &#125;?.readText()?.let &#123; gson.fromJson(it, User::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管先调用哪个 API 返回的 <code>Deferred</code> 的 <code>await</code>，都会被挂起，如果想要实现这一需求就要启动两个协程来调用 <code>await</code>，这样反而将问题复杂化了。</p><p>接下来我们用 <code>select</code> 来解决这个问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> localDeferred = getUserFromLocal(login)</span><br><span class="line">    <span class="keyword">val</span> remoteDeferred = getUserFromApi(login)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userResponse = select&lt;Response&lt;User?&gt;&gt; &#123;</span><br><span class="line">        localDeferred.onAwait &#123; Response(it, <span class="literal">true</span>) &#125;</span><br><span class="line">        remoteDeferred.onAwait &#123; Response(it, <span class="literal">false</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><p>大家可以看到，我们没有直接调用 <code>await</code>，而是调用了 <code>onAwait</code> 在 <code>select</code> 当中注册了个回调，不管哪个先回调，<code>select</code> 立即返回对应回调中的结果。假设 <code>localDeferred.onAwait</code> 先返回，那么 <code>userResponse</code> 的值就是 <code>Response(it, true)</code>，当然由于我们的本地缓存可能不存在，因此 <code>select</code> 的结果类型是 <code>Response&lt;User?&gt;</code>。</p><p>对于这个案例本身，如果先返回的是本地缓存，那么我们还需要获取网络结果来展示最新结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    ...</span><br><span class="line">    userResponse.value?.let &#123; log(it) &#125;</span><br><span class="line">    userResponse.isLocal.takeIf &#123; it &#125;?.let &#123;</span><br><span class="line">        <span class="keyword">val</span> userFromApi = remoteDeferred.await()</span><br><span class="line">        cacheUser(login, userFromApi)</span><br><span class="line">        log(userFromApi)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><h2 id="复用多个-Channel"><a href="#复用多个-Channel" class="headerlink" title="复用多个 Channel"></a>复用多个 Channel</h2><p>对于多个 <code>Channel</code> 的情况，也比较类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channels = List(<span class="number">10</span>) &#123; Channel&lt;<span class="built_in">Int</span>&gt;() &#125;</span><br><span class="line"></span><br><span class="line">select&lt;<span class="built_in">Int</span>?&gt; &#123;</span><br><span class="line">    channels.forEach &#123; channel -&gt;</span><br><span class="line">        channel.onReceive &#123; it &#125;</span><br><span class="line">        <span class="comment">// OR</span></span><br><span class="line">        channel.onReceiveOrNull &#123; it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>onReceive</code>，如果 <code>Channel</code> 被关闭，<code>select</code> 会直接抛出异常；而对于 <code>onReceiveOrNull</code> 如果遇到 <code>Channel</code> 被关闭的情况，<code>it</code> 的值就是 <code>null</code>。</p><h2 id="SelectClause"><a href="#SelectClause" class="headerlink" title="SelectClause"></a>SelectClause</h2><p>我们怎么知道哪些事件可以被 <code>select</code> 呢？其实所有能够被 <code>select</code> 的事件都是 <code>SelectClauseN</code> 类型，包括：</p><ul><li><p><code>SelectClause0</code>：对应事件没有返回值，例如 <code>join</code> 没有返回值，对应的 <code>onJoin</code> 就是这个类型，使用时 <code>onJoin</code> 的参数是一个无参函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    job.onJoin &#123; log(<span class="string">"Join resumed!"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>SelectClause1</code>：对应事件有返回值，前面的 <code>onAwait</code> 和 <code>onReceive</code> 都是此类情况。</li><li><p><code>SelectClause2</code>：对应事件有返回值，此外还需要额外的一个参数，例如 <code>Channel.onSend</code> 有两个参数，第一个就是一个 <code>Channel</code> 数据类型的值，表示即将发送的值，第二个是发送成功时的回调：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List(<span class="number">100</span>) &#123; element -&gt;</span><br><span class="line">    select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        channels.forEach &#123; channel -&gt;</span><br><span class="line">            channel.onSend(element) &#123; sentChannel -&gt; log(<span class="string">"sent on <span class="variable">$sentChannel</span>"</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消费者的消费效率较低时，数据能发给哪个就发给哪个进行处理，<code>onSend</code> 的第二个参数的参数是数据成功发送到的 <code>Channel</code> 对象。</p></li></ul><p>因此如果大家想要确认挂起函数是否支持 <code>select</code>，只需要查看其是否存在对应的 <code>SelectClauseN</code> 即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在协程当中，Select 的语义与 Java NIO 或者 Unix 的 IO 多路复用类似，它的存在使得我们可以轻松实现 1 拖 N，实现哪个先来就处理哪个。尽管 Select 和 Channel 比起标准库的协程 API 已经更接近业务开发了，不过个人认为它们仍属于相对底层的 API 封装，在实践当中多数情况下也可以使用 Flow API 来解决。</p><p>而这个 Flow API，完全就是响应式编程的协程版 API，我们简直可以照着 RxJava 来学习它，所以我们下一篇再见吧~~~</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
      <category term="select" scheme="https://www.bennyhuo.com/tags/select/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 最近怎么样了</title>
    <link href="https://www.bennyhuo.com/2019/12/23/kotlin-2019-whats-new/"/>
    <id>https://www.bennyhuo.com/2019/12/23/kotlin-2019-whats-new/</id>
    <published>2019-12-22T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 已经很成熟了。有多成熟呢？Kotlin Team 现在的重心已经是在为各个领域内的 Kotlin 实践提供支持了。</p></blockquote><a id="more"></a><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p>KotlinConf 在 12月5日前后的那几天开完了。Kotlin 1.4 有什么新特性吗？还真有一个，那就是 Kotlin 接口的 SAM 转换（KT-7770）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runAction</span><span class="params">(action: <span class="type">Action</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    runAction &#123;</span><br><span class="line">        <span class="comment">//action here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈，终于在新的类型推导到来时，这个特性被支持了。前不久我在录制 《Kotlin 入门到精通》这门课的时候讲到这个点的时候还说“我也不知道什么时候，会不会支持这个特性”，好了，Kotlin Team 终于听到了人民的呼声。</p><h2 id="新形势"><a href="#新形势" class="headerlink" title="新形势"></a>新形势</h2><p>Kotlin 1.0 发布到现在已经快 4 年了，我推广 Kotlin 差不多也 4 年多了。在 Google 开始决定扶持 Kotlin 之前，我们社区的小伙伴的内心感觉大概跟之前的 Rust 社区的小伙伴差不多吧，然后 Google 从 2017 年把 Kotlin 确定为 Android 的一级语言（表示会从官方提供支持，开发者可以使用）到 2019 年转变为首选语言（表示官方推荐你用 Kotlin），社区小伙伴们最初得到这样的消息大概也许相当于 Rust 社区的小伙伴们听到微软决定要用 Rust 来重写部分操作系统模块一样吧（激动）。</p><p>我们来看看现在 Kotlin 的排名情况，第一个是大家用的比较多的：</p><p><strong>TIOBE Index for December 2019</strong><br><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761917429814.jpg" alt=""></p><p>这个排名上 Kotlin 上升的还是比较缓慢的，不过也已经不错了，两年前的时候还在 50 名那儿呢。当然，这个排名其实也有一些争议，因为它是按照互联网上现有的某一门语言的网页数来计算排名的，排名前几的某些语言其实有很多网页都大概都没什么人访问。</p><p>第二个是我觉得比较能反映现在大家对待一门语言的态度的排名：</p><p><strong>PYPL PopularitY of Programming Language</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761920410684.jpg" alt=""></p><p>（我把图截得大了一些，主要是想把我同样也很喜欢的 Lua 截进来，(～￣▽￣)～）</p><p>这个索引比较科学的地方主要在于它关注的是大家搜索这门语言的教程的频次，这个表明今年 12月大家学习 Kotlin 的热度比起去年上升了 0.5%，名次上升了 4 位。</p><p>也就是说，这两个索引一个反应存量，一个反应增量，数据上就能看出 Kotlin 的潜力还是非常巨大的，尽管现在开发者群体还比不上当红的 Java Python 这类“发达”语言，但这个增速绝对就是“发展中”语言中一道亮丽的风景线。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15770731567913.jpg" alt=""><br>PYPL 的排名确实能够比较真实的反映时下大家的态度，Java 已经被唱衰了好几年，Python 近几年火热到一下冒出特别多新书。Kotlin 在 Native 领域存活自然需要直面 Go，在 JavaScript 上当然也离不开 TypeScript，正好我们也对比下它们各自的发展，Kotlin 作为后起之秀真实有后来居上的气势。</p><h2 id="新发展"><a href="#新发展" class="headerlink" title="新发展"></a>新发展</h2><p>事实上，Kotlin 的主要应用领域当然就是 Android 了。可以说 Kotlin 简直运气好到了极点（也可以说是 Kotlin Team 的决策高明），选择从 Android 撕开一道口子切入市场，道理很简单啊，搞后台的人选择面太广了，Android 端除了忍受 Java，实在没有什么办法，我当时尝试了 Groovy 和 Scala 写 Android，结果标准库方法数一个 3W ，一个 5W，几年前我们还在饱受方法数的折磨，大家应该懂我是什么意思。可是 Kotlin 就很聪明，我不造轮子，标准库方法数 7k ，而且一直到现在都没怎么增加太多，所以大家就开始尝试。到现在，很多人都还觉得 Kotlin 一定是给 Android 开发者准备的 —— 怎么会呢。不过要说支持的比较好的，当然还是 Android，<a href="https://developer.android.com/kotlin/ktx" target="_blank" rel="noopener">KTX 的库</a>已经非常丰富，<a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">Lifecycle</a>、<a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="noopener">Room</a> 这样的组件也已经支持协程（前者提供 scope，后者的 Dao 支持 suspend 函数），第三方的 <a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a> 早在 2.6.0 就支持 suspend 函数，<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a> 4.x 已经完全用 Kotlin 重写等等。就连我们公司年初开源的（实际上这个项目在内部也早就开源）插件化框架 <a href="https://github.com/Tencent/Shadow" target="_blank" rel="noopener">Shadow</a> 也有很多模块是使用 Kotlin 开发的。数不胜数。</p><p>其次自然就是 Java 所覆盖的其他领域。印象中 <a href="https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0" target="_blank" rel="noopener">Spring 5.0 就开始支持 Kotlin</a>，前不久试了下 <a href="https://www.baeldung.com/spring-boot-kotlin-coroutines" target="_blank" rel="noopener">WebFlux 都已经支持 <code>suspend</code> 函数作为 RestController 的 API </a>，也提供了各种 <code>Flux</code> 与 <code>Flow</code> 的互转操作，使用体验真实不要太赞。Kotlin Team 的亲儿子 <a href="https://ktor.io" target="_blank" rel="noopener">Ktor</a> 就更不用说了，函数式的 Route 声明，让我一度以为自己在写 Node.js，但又显然不是，Node.js 哪里会提示有什么 API 呢；原生的协程支持，让我们几乎处处可以写 <code>suspend</code> 调用，感觉空气都新鲜了。</p><p>不甘寂寞的 Kotlin Team 很早就开始支持 Js，不过工具链却一直没有跟上，今年还是重点迭代的 <a href="https://github.com/Kotlin/dukat" target="_blank" rel="noopener">Dukat</a> 项目就是为了解决 Kotlin 与 JavaScript 交互时，Kotlin 的强类型问题。这个项目可以把现有的 JavaScript 界类型的事实标准 *.d.ts 文件转成 Kotlin 声明，这样就很好的解决了类型问题，省得我们以前写 Kotlin 调用 JavaScript API 的时候要么自己手动在 Kotlin 源码中声明对应的 API，要么就是各种类型都声明为 dynamic 逃过编译器检查。听说 WASM 也要独立门户了，过去一直都在 Kotlin Native 当中，后面也许也是一个重点的发力方向。</p><p>Kotlin Native 最早比较让人难受的就是编译慢的问题了。最开始编译 Hello World 都需要 40s，后来终于缩短到了 10s 以内（我的笔记本是 2015 mbp），当然这个时间随着代码量的增加也并不会有特别显著的增长，所以对于大型项目来讲，编译时间已经不再是问题。还有就是调试麻烦的事儿，如果是写独立的 Kotlin Native 项目，可以直接 CLion 中调试，也可以在 IntelliJ 中安装 Native Debug 插件调试，可是最近很流行的 Kotlin Native 写 iOS 程序呢，貌似不太好办 —— Kotlin Team 宣布会在明年开始 preview 一款运行在 Android Studio 上的插件用来调试跑在 iOS 上的 Kotlin Native 代码，这就有点儿秀了。哦，对了，Kotlin Native 的协程只能跑在一个线程当中的问题也应该很快就能解决，期待一下。</p><p>还有 Kotlin 的脚本，在 3.0 时代就开始尝试支持 Kotlin 的 <a href="https://docs.gradle.org/5.0/release-notes.html" target="_blank" rel="noopener">Gradle 在 5.0 正式宣布支持 Kotlin</a>，并且官方文档都配备了 Kotlin 和 Groovy 两个版本，写过 Gradle 插件的都知道，Gradle API 本来就比较复杂，用 Groovy 写没有 IDE 提示的日子有多痛苦，用 Kotlin 就完全不同了。</p><p>更重磅的是，来看看新鲜出炉的 <a href="https://github.com/Kotlin/kotlin-jupyter" target="_blank" rel="noopener">kotlin-jupyter</a>，官方博客也刚刚更新了 <a href="https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/" target="_blank" rel="noopener">Kotlin 对科学计算支持的介绍文章</a>。看来，Kotlin Team 的野心真的不小啊，我现在就是有点儿担心 Kotlin Team 人手不够了 —— 玩笑话，Kotlin 已经不再是 Kotlin Team 自己的了，而是我们所有开发者的。</p><p>稍微提一下，在函数式编程方面，Kotlin Team 目前没有（明面儿上）专门支持，不过开源项目 <a href="https://github.com/arrow-kt/arrow" target="_blank" rel="noopener">Arrow</a> 已经颇具规模，由于 Kotlin 1.4 有公开编译器插件的 API 的计划，Arrow 团队也在积极引进编译器层面的支持来加强某些特性的实现（例如 typeclass，目前在 Java 平台上主要靠 APT）。</p><h2 id="一如既往的建议"><a href="#一如既往的建议" class="headerlink" title="一如既往的建议"></a>一如既往的建议</h2><p>尽管发展趋势日新月异，不过建议却一直没变。现如今的 Kotlin 的发展形势越来越好 ，如果现在你还没有趁早用起来，难道要等到几年后后悔吗？当然也有很多小伙伴说用 Kotlin 的时候“巨坑”，然后我问他们都哪儿坑了，说出来之后结果发现都是因为对 Kotlin 甚至是对 Java 不熟悉造成的。其实大家只要认真阅读官方文档，稍微练习上几天，一定会逐渐熟悉起来的，如果英文吃力，可以关注下<a href="https://www.kotlincn.net" target="_blank" rel="noopener">中文 Kotlin 官网</a>，有问题可以到<a href="https://discuss.kotliner.cn/" target="_blank" rel="noopener">Kotlin 中文论坛</a>提问。当然，如果大家喜欢通过视频学习，也可以在慕课网关注下 “<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">新版 Kotlin 从入门到精通</a>“ 这门课，我大概从国庆前后开始基于 Kotlin 1.3.50 制作了这套新版的视频教程，Kotlin 的知识点基本上都有覆盖，也结合了过去推广教学的经验对重难点进行了深入剖析，希望对大家在 Kotlin 入门或是进阶的过程中提供帮助。</p><p>Have a nice Kotlin!</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，大家可以在2019年12月26日之前联系慕课网客服索取价值 150 元的定向代金券，结合课程的限时优惠只需要 115 元即可升级新课。新课限时优惠同样截止于2019年12月26日，因此有需要的小伙伴们一定要抓紧了哟！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Kotlin 已经很成熟了。有多成熟呢？Kotlin Team 现在的重心已经是在为各个领域内的 Kotlin 实践提供支持了。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="News" scheme="https://www.bennyhuo.com/tags/news/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程 番外篇(2) - 协程的几类常见的实现</title>
    <link href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/"/>
    <id>https://www.bennyhuo.com/2019/12/01/coroutine-implementations/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。</p></blockquote><a id="more"></a><p>前面一篇文章我们大概讨论了协程是怎么一回事，也举了一些例子，不过整体上覆盖的细节比较少。这篇文章我们按照协程的经典论文 “Revisiting Coroutines” 的思路展开，详细的讨论下协程究竟是怎样的存在。当然由于涉及语言较多，个人水平有限，如有不恰当之处，欢迎大家指正。</p><h2 id="1-协程的分类"><a href="#1-协程的分类" class="headerlink" title="1. 协程的分类"></a>1. 协程的分类</h2><p>协程的主流实现虽然细节上差异较大，但总体来讲仍然有章可循。</p><h3 id="1-1-按调用栈分类"><a href="#1-1-按调用栈分类" class="headerlink" title="1.1 按调用栈分类"></a>1.1 按调用栈分类</h3><p>由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似地，线程会因为 CPU 调度权的切换而被中断，它的中断状态会保存在调用栈当中，因而协程的实现也按照是否开辟相应的调用栈存在以下两种类型：</p><ul><li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li><li>无栈协程 Stackless Coroutine：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法来实现。</li></ul><p>有栈协程的优点就是可以在任意函数调用层级的任意位置进行挂起，并转移调度权，例如 Lua 的协程，这方面多数无栈协程就显得力不从心了，例如 Python 的 Generator；通常来讲，有栈协程因为总是会给协程开辟一块儿栈内存，因此内存开销也相对可观，而无栈协程在内存方面就比较有优势了。</p><p>当然也有反例。</p><p>Go 语言的 go routine 可以认为是有栈协程的一个实现，不过 Go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB，相比之下线程的栈空间通常是 MB 级别，因而它在内存方面的表现也相对轻量。</p><p>Kotlin 的协程是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现的，不过 Kotlin 的协程可以在任意调用层次挂起，换句话说我们启动一个 Kotlin 协程，可以在其中任意嵌套 <code>suspend</code> 函数，而这又恰恰是有栈协程最重要的特性之一：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">level_0</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"I'm in level 0!"</span>)</span><br><span class="line">    level_1() <span class="comment">// ............ ①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">level_1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"I'm in level 1!"</span>)</span><br><span class="line">    suspendNow() <span class="comment">// ............ ②</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendNow</span><span class="params">()</span></span> </span><br><span class="line">        = suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中 ① 处并没有真正直接挂起，② 处的调用才会真正挂起，Kotlin 通过 <code>suspend</code> 函数嵌套调用的方式可以实现任意函数调用层次的挂起。</p><p>当然，想要在任意位置挂起，那就需要调用栈了，与开发者通过调用 API 显式地挂起协程相比，任意位置的挂起主要用于运行时对协程执行的干预，这种挂起方式对于开发者不可见，因而是一种隐式的挂起操作。Go 语言的 go routine 可以通过对 channel 的读写来实现挂起和恢复，除了这种显式地切换调度权之外，Go 运行时还会对长期占用调度权的 go routine 进行隐式挂起，并将调度权转移给其他 go routine，这实际上就是我们熟悉的线程的抢占式调度了。</p><h3 id="1-2-按调度方式分类"><a href="#1-2-按调度方式分类" class="headerlink" title="1.2 按调度方式分类"></a>1.2 按调度方式分类</h3><p>调度过程中，根据协程转移调度权的目标又将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>：</p><ul><li>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。</li><li>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li></ul><p>对称协程实际上已经非常接近线程的样子了，例如 Go 语言中的 go routine 可以通过读写不同的 channel 来实现控制权的自由转移。而非对称协程的调用关系实际上也更符合我们的思维方式，常见的语言对协程的实现大多是非对称实现，例如 Lua 的协程中当前协程调用 <code>yield</code> 总是会将调度权转移给 <code>resume</code> 它的协程；还有就是我们在前面提到的 <code>async</code>/<code>await</code>，<code>await</code> 时将调度权转移到异步调用中，异步调用返回结果或抛出异常时总是将调度权转移回 <code>await</code> 的位置。</p><p>从实现的角度来讲，非对称协程的实现更自然，也相对容易；不过，我们只要对非对称协程稍作修改，即可实现对称协程的能力。在非对称协程的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有的协程在挂起时都将控制权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，例如 Lua 的第三方库 <a href="https://luapower.com/coro" target="_blank" rel="noopener">coro</a>，以及 Kotlin 协程框架中基于 <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html" target="_blank" rel="noopener">Channel</a> 的通信等。</p><h2 id="2-协程的实现举例"><a href="#2-协程的实现举例" class="headerlink" title="2. 协程的实现举例"></a>2. 协程的实现举例</h2><p>我们已经介绍了非常多的协程相关的理论知识，简单来说协程需要关注的就是程序自己处理挂起和恢复，只不过在分类的时候又根据解决挂起和恢复时具体实现细节的不同又区分了按照<strong>栈</strong>的有无和<strong>调度权</strong>转移的对称性的分类。不管怎样，协程的关注点就是程序自己处理挂起和恢复，以下我们给出一些实现，请大家留意它们是如何做到这一点的。</p><h3 id="2-1-Python-的-Generator"><a href="#2-1-Python-的-Generator" class="headerlink" title="2.1 Python 的 Generator"></a>2.1 Python 的 Generator</h3><p>Python 的 Generator 也是协程，是一个典型的无栈协程的实现，我们可以在任意 Python 函数中调用 <code>yield</code> 来实现当前函数调用的挂起，<code>yield</code> 的参数作为对下一次 <code>next(num_generator)</code>调用的返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span>(i) <span class="comment"># ..................... ①</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">num_generator = numbers()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"[0] <span class="subst">&#123;next(num_generator)&#125;</span>"</span>) <span class="comment"># ... ②</span></span><br><span class="line">print(<span class="string">f"[1] <span class="subst">&#123;next(num_generator)&#125;</span>"</span>) <span class="comment"># ... ③</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_generator: <span class="comment"># ............... ④</span></span><br><span class="line">    print(<span class="string">f"[Loop] <span class="subst">&#123;i&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p>所以运行这段程序时，首先会在 ① 处 <code>yield</code>，并将 <code>0</code> 传出，在 ② 处输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0] 0</span><br></pre></td></tr></table></figure><p>接着自 ③ 处调用 <code>next</code>，将调度权从主流程转移到 <code>numbers</code> 函数当中，从上一次挂起的位置 ① 处继续执行，<code>i</code> 的值修改为 <code>1</code>，1s 后，再次通过 <code>yield(1)</code> 挂起，③ 处输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br></pre></td></tr></table></figure><p>后续就以同样的逻辑在 <code>for</code> 循环中一直输出 <code>[Loop] n</code>，直到程序被终止。</p><p>我们看到，之所以称 Python 的 Generator 为协程，就是因为它具备了通过 <code>yield</code> 来挂起当前 Generator 函数的执行，通过 <code>next</code> 来恢复参数对应的 Generator 执行来实现挂起、恢复的协程调度权控制转移的。</p><p>当然，如果在 <code>numbers</code> 函数中嵌套调用 <code>yield</code>，就无法对 <code>numbers</code> 的调用进行中断了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        yield_here(i) <span class="comment"># ................. ①</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yield_here</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span>(i)</span><br></pre></td></tr></table></figure><p>这时候我们再调用 <code>numbers</code> 函数，就会陷入死循环而无法返回，因为这次 <code>yield_here</code> 的返回值才是 Generator。</p><blockquote><p><strong>说明</strong> Python 的 Generator 属于<strong>非对称无栈协程</strong>的一种实现。从 Python 3.5 开始也支持 <code>async</code>/<code>await</code>，原理与 JavaScript 的实现类似，与 Generator 的不同之处在于我们可以通过这一组关键字实现在函数嵌套调用挂起。</p></blockquote><h3 id="2-2-Lua-标准库的协程实现"><a href="#2-2-Lua-标准库的协程实现" class="headerlink" title="2.2 Lua 标准库的协程实现"></a>2.2 Lua 标准库的协程实现</h3><p>Lua 的协程实现可以认为是一个教科书式的案例了，它提供了几个 API 允许开发者灵活控制协程的执行：</p><ul><li><code>coroutine.create</code>：创建协程，参数为函数，作为协程的执行体，返回协程实例。</li><li><code>coroutine.yield</code>：挂起协程，第一个参数为被挂起的协程实例，后面的参数则作为外部调用 <code>resume</code> 来继续当前协程时的返回值，而它的返回值则又是外部下一次 <code>resume</code> 调用时传入的参数。</li><li><code>coroutine.resume</code>：继续协程，第一个参数为被继续的协程实例，后面的参数则作为协程内部 <code>yield</code> 时的返回值，返回值则为协程内部下一次 <code>yield</code> 时传出的参数；如果是第一次对该协程实例执行 <code>resume</code>，参数会作为协程函数的参数传入。</li></ul><p>Lua 的协程也有几个状态，挂起（suspended）、运行（running）、结束（dead）。其中，调用 <code>yield</code> 之后的协程处于挂起态，获得执行权而正在运行的协程则是处于运行态，协程对应的函数运行结束后，则处于结束态。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span> </span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>, <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"send "</span>..i)</span><br><span class="line">        coroutine.<span class="built_in">yield</span>(i) <span class="comment">-- ④</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"End Producer"</span>)</span><br><span class="line"><span class="keyword">end</span>            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(value)</span></span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"receive "</span>..value)</span><br><span class="line">        value = coroutine.<span class="built_in">yield</span>() <span class="comment">-- ⑤</span></span><br><span class="line">    <span class="keyword">until</span>(<span class="keyword">not</span> value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"End Consumer"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">producerCoroutine = coroutine.<span class="built_in">create</span>(producer) <span class="comment">-- ①</span></span><br><span class="line">consumerCoroutine = coroutine.<span class="built_in">create</span>(consumer) <span class="comment">-- ②</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">status</span>, product = coroutine.<span class="built_in">resume</span>(producerCoroutine) <span class="comment">-- ③</span></span><br><span class="line">    coroutine.<span class="built_in">resume</span>(consumerCoroutine, product) <span class="comment">-- ⑥</span></span><br><span class="line"><span class="keyword">until</span>(<span class="keyword">not</span> <span class="built_in">status</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"End Main"</span>)</span><br></pre></td></tr></table></figure><p>这段代码在 ①、②两处创建协程，③处开始执行，<code>producer</code> 在 ④ 处 <code>yield(0)</code>，意味着 ③ 的返回值 <code>product</code> 就是 <code>0</code>，我们把 <code>0</code> 作为参数又传给 <code>consumer</code>，第一次 <code>resume</code> 参数 <code>0</code> 会作为 <code>consumer</code> 的参数 <code>value</code> 传入，因此会打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">send 0</span><br><span class="line">receive 0</span><br></pre></td></tr></table></figure><p>接下来 <code>consumer</code> 通过 ⑤ 处的 <code>yield</code> 挂起，它的参数会作为 ⑥ 处的返回值，不过我们没有传任何参数。这时控制权又回到主流程，<code>status</code> 的值在对应的协程结束后会返回 <code>false</code>，这时候 <code>producer</code> 尚未结束，因此是 <code>true</code>，于是循环继续执行，后续流程类似，输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">send 1</span><br><span class="line">receive 1</span><br><span class="line">send 2</span><br><span class="line">receive 2</span><br><span class="line">send 3</span><br><span class="line">receive 3</span><br><span class="line">End Producer</span><br><span class="line">End Consumer</span><br><span class="line">End Main</span><br></pre></td></tr></table></figure><p>通过这个例子，希望大家能够对协程有一个更加具体的认识，我们看到对于协程来讲，它包括：</p><ul><li>协程的执行体，主要是指启动协程时对应的函数</li><li>协程的控制实例，我们可以通过协程创建时返回的实例控制协程的调用流转</li><li>协程的状态，在调用流程转移前后，协程的状态会发生相应的变化</li></ul><blockquote><p><strong>说明</strong> Lua 标准库的协程属于<strong>非对称有栈协程</strong>，不过第三方提供了基于标准库的<strong>对称协程</strong>的实现，有兴趣的话可以参考： <a href="https://luapower.com/coro" target="_blank" rel="noopener">coro</a>。有趣的是，这也恰恰是<strong>对称协程</strong>的实现可以基于<strong>非对称协程</strong>来实现的很好的例证。</p></blockquote><h3 id="2-3-Go-语言中的-go-routine"><a href="#2-3-Go-语言中的-go-routine" class="headerlink" title="2.3 Go 语言中的 go routine"></a>2.3 Go 语言中的 go routine</h3><p>go routine 的调度没有 Lua 那么明显，没有类似 <code>yield</code> 和 <code>resume</code> 的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// .......... ①</span></span><br><span class="line"><span class="keyword">var</span> readChannel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = channel</span><br><span class="line"><span class="keyword">var</span> writeChannel <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = channel</span><br><span class="line"></span><br><span class="line"><span class="comment">// reader</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// ........................ ②</span></span><br><span class="line">    fmt.Println(<span class="string">"wait for read"</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> readChannel &#123; <span class="comment">// ... ③</span></span><br><span class="line">        fmt.Println(<span class="string">"read"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"read end"</span>)</span><br><span class="line">&#125;()  <span class="comment">// ............................... ④</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// writer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">        fmt.Println(<span class="string">"write"</span>, i)</span><br><span class="line">        writeChannel &lt;- i <span class="comment">// .......... ⑤</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>我们先来简单介绍下 go routine 的启动方式。在任意函数调用前面加关键字 <code>go</code> 即可启动一个 go routine，并在该 go routine 中调用这个函数，例如 ② 处实际上是创建了一个匿名函数，并在后面 ④ 处立即调用了该函数。我们把这两个 go routine 依次称为 “reader” 和 “writer”。</p><p>① 处创建了一个双向的 <code>channel</code>，可读可写，接着创建的 <code>readChannel</code> 声明为只读类型，<code>writeChannel</code> 声明为只写类型，这二者实际上是同一个 <code>channel</code>，并且由于这个 <code>channel</code> 没有缓冲区，因此写操作会一直挂起直到读操作执行，反过来也是如此。</p><p>在 reader 中，③ 处的 <code>for</code> 循环会对 <code>readChannel</code> 进行读操作，如果此时还没有对饮的写操作，就会挂起，直到有数据写入；在 writer 中，⑤ 处表示向 <code>writeChannel</code> 中写入 <code>i</code>，同样，如果写入时尚未有对应的读操作，就会挂起，直到有数据读取。整段程序的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait for read</span><br><span class="line">write 0</span><br><span class="line">read 0</span><br><span class="line">write 1</span><br><span class="line">read 1</span><br><span class="line">write 2</span><br><span class="line">read 2</span><br><span class="line">read end</span><br></pre></td></tr></table></figure><p>如果我们有多个 go routine 对 <code>channel</code> 进行读写，或者有多个 <code>channel</code> 供多个 go routine 读写，那么这时的读写操作实际上就是在 go routine 之间平等的转移调度权，因此可以认为 go routine 是<strong>对称</strong>的协程实现。</p><p>这个示例看上去对于 <code>channel</code> 的读写操作有点儿类似两个线程中的阻塞式 IO 操作，不过 go routine 相对操作系统的内核线程来说要轻量得都，切换的成本也很低，因此在读写过程中挂起的成本也远比我们熟悉的线程阻塞的调用切换成本。实际上这两个 go routine 在切换时，很大概率不会有线程的切换，为了让示例更加能说明问题，我们为输出添加了当前的线程 id，同时将每次向 <code>writeChannel</code> 写入数据之后的 <code>Sleep</code> 操作去掉：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(windows.GetCurrentThreadId(), <span class="string">"wait for read"</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> readChannel &#123;</span><br><span class="line">        fmt.Println(windows.GetCurrentThreadId(), <span class="string">"read"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(windows.GetCurrentThreadId(), <span class="string">"read end"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">        fmt.Println(windows.GetCurrentThreadId(), <span class="string">"write"</span>, i)</span><br><span class="line">        writeChannel &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>修改后的运行结果可以看到程序在输出时所在的线程 id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">181808 write 0</span><br><span class="line">183984 wait for read</span><br><span class="line">181808 read 0</span><br><span class="line">181808 write 1</span><br><span class="line">181808 write 2</span><br><span class="line">181808 read 1</span><br><span class="line">181808 read 2</span><br><span class="line">181808 read end</span><br></pre></td></tr></table></figure><p>两个 go routine 除了开始运行时占用了两个线程，后续都在一个线程中转移调度权（不同场景的实际运行结果可能有细微差异，这取决于 Go 运行时的调度器）。</p><blockquote><p><strong>获取线程 id</strong> 本例在 windows 上调试，通过 <a href="https://github.com/golang/sys" target="_blank" rel="noopener">sys</a> 库的 windows 包下提供的 <code>GetCurrentThreadId</code> 函数来获取线程 id。Linux 系统可以通过 <code>syscall.Gettid</code> 来获取。</p></blockquote><blockquote><p><strong>说明</strong> 我们虽然一直在用 go routine 做例子，并把它称作为<strong>对称有栈协程</strong>的一种实现，但考虑到 Go 运行时本身做了足够多超出其他语言的能力，例如栈优化，调度优化等，特别是的调度器还支持特定场景下的抢占式调度，某种意义上已经超越了协程概念的讨论范围，因此也有很多人认为 go routine 不能简单的认为就是协程。</p></blockquote><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>本文整体上对协程的分类做了较为详细的探讨。不管怎么分类，协程的本质就是程序自己处理挂起和恢复。协程描述了多个程序之间如何通过相互出让运行调度权来完成执行，基于这一对基本的控制转移操作进而衍生出各种异步模型，并发模型例如 <code>async</code>/<code>await</code>，Channel 等。</p><p>相比之下，有朋友抱怨 Kotlin 的协程没有其他语言的 <code>async</code>/<code>await</code> 那么容易上手，也没有 go routine 那么容易使用，原因也很简单，Kotlin 的协程用一个最基本的 <code>suspend</code> 关键字来支持了最基本的挂起恢复逻辑，进而在上层封装，衍生出了以上提到的几乎所有的模型，让我们在 Kotlin 当中可以有机会使用 <code>async</code>/<code>await</code>、Channel，以及最新出的 Flow API，将来还会有更多（也许包括在 issue 中被提到想要重做的 Actor），它想做的事儿太多了，也确实在一步一步地做到。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 中文论坛的使用技巧</title>
    <link href="https://www.bennyhuo.com/2019/10/22/kotlin-forum-mobile/"/>
    <id>https://www.bennyhuo.com/2019/10/22/kotlin-forum-mobile/</id>
    <published>2019-10-21T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.421Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！</p></blockquote><a id="more"></a><p>欢迎访问 <a href="https://discuss.kotliner.cn/" target="_blank" rel="noopener">Kotlin 中文论坛</a> 讨论 Kotlin！为了能够有时间刷论坛，我卸载了知乎卸载了脉脉，来吧，抛出你的问题~~</p><p>大家知道，额，估计不知道吧。。。我们的 Kotlin 中文论坛实际上是采用了与官方论坛相同的框架 <a href="https://www.discourse.org/" target="_blank" rel="noopener">Discourse</a>，很厉害的项目呢。这个框架界面风格都非常的清爽，Github 的论坛、Gradle 论坛好多论坛都采用了这个项目搭建：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716995316308.jpg" alt=""></p><p>我其实一直以为它的优点就只有这么点儿，直到我发现用手机端的 Chrome 可以直接创建一个快捷方式：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716998152892.jpg" alt=""></p><p>之后呢？我们就可以在桌面上看到：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999181369.jpg" alt=""></p><p>点击这个 icon 进入之后，就好像原生 App 一样：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999799086.jpg" alt=""></p><p>浏览器的地址不见了有没有，使用体验也很不错，小伙伴们就可以随时随地刷论坛啦！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！</p><hr><p>经过小伙伴们之处，桌面也可以：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720452651204.jpg" alt=""></p><p>然后就得到了一个桌面 APP 有木有！</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720453054368.jpg" alt=""></p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Website" scheme="https://www.bennyhuo.com/tags/website/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程 番外篇(1) - 协程为什么被称为『轻量级线程』？</title>
    <link href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/"/>
    <id>https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/</id>
    <published>2019-10-18T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接触新概念，最好的办法就是先整体看个大概，再回过头来细细品味。</p></blockquote><a id="more"></a><p>文中如果没有特别说明，协程指编程语言级别的协程，线程则特指操作系统内核线程。</p><h2 id="1-协程到底是啥？"><a href="#1-协程到底是啥？" class="headerlink" title="1. 协程到底是啥？"></a>1. 协程到底是啥？</h2><p>Kotlin 的协程从 v1.1 开始公测(Experimental) 到现在，已经算是非常成熟了，但大家对它的看法却一直存在各种疑问，为什么呢？因为即便我们把 Kotlin 丢掉，单纯协程这个东西本身就已经长时间让大家感到疑惑了，不信的话可以单独搜一下协程或者 Coroutine，甚至连 Lua 之父在提到为什么协程鲜见于早期语言实现，就是因为这概念没有一个清晰的界定。</p><p>更有意思的是，在查阅资料的过程中，你会经常会陷入一种一会儿『啊，我懂了』，一会儿『啊，我懂个屁』的循环当中，不瞒各位说，我从七八年前刚开始学 Lua 的时候面对 Lua 的协程也是这个破感觉，后来接触 goroutine 又来了一遍，接触 Kotlin 的协程又来了一遍，习惯就好。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712859864288.jpg" alt=""></p><p>那么问题的关键在于，协程的概念是不是真的混乱呢？其实不是的，协程的概念最核心的点其实就是函数或者一段程序能够被挂起（说暂停其实也没啥问题），待会儿再恢复，挂起和恢复是开发者的程序逻辑自己控制的，协程是通过主动挂起出让运行权来实现协作的，就没了，一句话就能说明白的事儿是不是特简单？它跟线程最大的区别在于线程一旦开始执行，从任务的角度来看，就不会被暂停，直到任务结束这个过程都是连续的，线程之间是抢占式的调度，因此也不存在协作问题。</p><p>那么我们再来理一理协程的概念：</p><ul><li>挂起恢复</li><li>程序自己处理挂起恢复</li><li>程序自己处理挂起恢复来实现协程的协作运行</li></ul><p>关键核心就是协程是一个能挂起并且待会儿恢复执行的东西。任何时候自己产生疑惑的时候都回过来再想想这几句话，就算协程最终呈现给我们的样子可能『花里胡哨』，但万变不离其宗。</p><blockquote><p>有的朋友不理解什么叫挂起，挂起这个词其实还真是源于操作系统的叫法，直观的理解上，你就当做暂停理解吧。</p></blockquote><h2 id="2-为什么协程的概念会有混乱的感觉？"><a href="#2-为什么协程的概念会有混乱的感觉？" class="headerlink" title="2. 为什么协程的概念会有混乱的感觉？"></a>2. 为什么协程的概念会有混乱的感觉？</h2><p>我们前面提到，协程的概念其实并不混乱，那么混乱的是什么？是各家对它的实现。这就好像牛顿第二定律一样，看似很简单，F = ma，用起来就五花八门了，衍生的各种公式更是层出不穷。</p><p>协程不就是要挂起、恢复么，请问挂起恢复具体要怎么做？没有定义呀。既然没有定义是不是就可以随便？是的，抓住老鼠就是好猫~</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712868953541.jpg" alt=""></p><p>协程这一点儿跟线程真的是没法比啊，主流操作系统都有成熟的线程模型，应用层经常提到的线程的概念大多就是映射方式的差异，所以不同的编程语言一旦引入了线程，那么基本上就是照搬了系统线程的概念，线程本身也不是他们实现的——这很好理解，因为线程调度是操作系统做的嘛。</p><blockquote><p>Java 对线程做了很好的支持，这也是 Java 在高并发场景风生水起的一个关键支柱，不过如果你有兴趣去看下虚拟机底层对线程的支持，例如 Android 虚拟机，其实就是 pthread。Java 的 Object 还有一个 wait 方法，这个方法几乎支撑了各种锁的实现，它底层是 condition。</p></blockquote><p>绝大多数协程都是语言层面自己的实现，不同的编程语言有不同的使用场景，自然在实现上也看似有很大的差异，甚至还有的语言自己没有实现协程，但开发者通过第三方框架的方式提供了协程的能力，例如 Java 的框架 <a href="http://docs.paralleluniverse.co/quasar/" target="_blank" rel="noopener">Quasar</a>，加上协程实现本身在操作系统层面就有过一系列演进，因此出现了虽然理论上看起来很简单，但实现上却多样化的局面。</p><h2 id="3-协程有哪些主流的实现？"><a href="#3-协程有哪些主流的实现？" class="headerlink" title="3. 协程有哪些主流的实现？"></a>3. 协程有哪些主流的实现？</h2><p>我们在前面讲各个语言的实现有差异，说的是看似有很大的差异，主要是各自的关键字、类型命名不一样，但总结下来大家对于协程的分类更倾向于按照有没有栈来分，即：</p><ul><li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li><li>无栈协程 Stackless Coroutine：协程没有自己的调用栈。</li></ul><p>栈这个东西大家应该都很熟悉了，我们递归调用函数的层次太多就会导致 <code>StackOverflowException</code>，因为栈内存是有限的；我们的程序出现了异常我们总是希望看到异常点的调用关系，这样方便定位问题，这也需要栈。</p><p>有栈协程有什么好处呢？因为有栈，所以在任何一个调用的地方运行时都可以选择把栈保存起来，暂停这个协程，听起来就跟线程一样了，只不过挂起和恢复执行的权限在程序自己，而不是操作系统。缺点也是非常明显的，每创建一个协程不管有没有在运行都要为它开辟一个栈，这也是目前无栈协程流行的原因。</p><blockquote><p>goroutine 看上去似乎不像协程，因为开发者自己无法决定一个协程的挂起和恢复，这个工作是 go 运行时自己处理的。为了支持 goroutine 在任意位置能挂起，goroutine 其实是一个有栈协程，go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB。</p></blockquote><p>JavaScript、C# 还有 Python 的协程，或者干脆就说 async/await，相比之下就轻量多了，它们看起来更像是针对回调加了个语法糖的支持——它们其实就是无栈协程的实现了。无栈，顾名思义，每一个协程都不会单独开辟调用栈，那么问题来了，它的上下文是如何保存的？</p><p>这就要提到传说中的 CPS 了，即 continuation-passing-style。我们来想象一下，程序被挂起，或者说中断，最关键的是什么？是保存挂起点，或者中断点，对于线程被操作系统中断，中断点就是被保存在调用栈当中的，而我们的无栈协程要保存到哪儿呢？保存到 Continuation 对象当中，这个东西可能在不同的语言当中叫法不一样，但本质上都是一个 Continuation，它就是一个普通的对象，占用内存非常小，还是很抽象是吧，想想你常见的 Callback，它其实就是一个 Continuation 的实现。</p><blockquote><p>Kotlin 的协程的根基就是一个叫做 Continuation 的类。我在前面的文章不止一次提到，这家伙长得横看竖看就是一个回调，resume 就是 onSuccess，resumeWithException 就是 onFailure。</p></blockquote><p>Continuation 携带了协程继续执行所需要的上下文，同时它自己又是挂起点，因为待会儿恢复执行的时候只需要执行它回调的函数体就可以了。对于 Kotlin 来讲，每一个 <code>suspend</code> 函数都是一个挂起点，意味着对于当前协程来说，每遇到一个 <code>suspend</code> 函数的调用，它都有可能会被挂起。每一个 <code>suspend</code> 函数都被编译器插入了一个 Continuation 类型的参数用来保存当前的调用点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = suspendCoroutine&lt;<span class="built_in">Int</span>&gt;&#123; continuation -&gt;</span><br><span class="line">    println(<span class="string">"Hello"</span>)</span><br><span class="line">    continuation.resumeWith(Result.success(<span class="number">10086</span>))</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">我们定义了一个 `<span class="keyword">suspend</span>` 函数 `hello`，它看起来没有接收任何参数，如果真是这样，请问我们在后面调用 `resumeWith` 的 `continuation` 是哪里来的？</span><br><span class="line"></span><br><span class="line">都说挂起函数必须在协程内部调用，其实也不是，我们在前面讲挂起原理的时候就用 Java 代码直接去调用 `<span class="keyword">suspend</span>` 函数，大家也会发现这些 `<span class="keyword">suspend</span>` 函数都需要传入一个额外的 `Continuation`，就是这个意思。</span><br><span class="line"></span><br><span class="line">当然，Java 也不是必须的，我们只需要用点儿 Kotlin 反射，一样可以直接让 `<span class="keyword">suspend</span>` 函数现出原形：</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line"><span class="keyword">val</span> helloRef = ::hello</span><br><span class="line"><span class="keyword">val</span> result = helloRef.call(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"resumeWith: <span class="subst">$&#123;result.getOrNull()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这与我们在协程挂起原理那篇的做法如出一辙，我们虽然没有办法直接调用 <code>hello()</code>，但我们可以拿到它的函数引用，用发射调用它（这个做法后续可能也会被禁掉，但 1.3.50 目前仍然是可用的），调用的时候如果你什么参数都不传，编译器就会提示你它需要一个参数，呃，你看，它这么快就投降了——需要的这个参数正是 <code>Continuation</code>。</p><p>再强调一下，这段代码不需要运行在协程体内，或者其他的 <code>suspend</code> 函数中。现在请大家仔细想想，为什么官方要求 <code>suspend</code> 函数一定要运行在协程体内或者其他 <code>suspend</code> 函数中呢？</p><p>答案自然就是任何一个协程体或者 <code>suspend</code> 函数中都有一个隐含的 <code>Continuation</code> 实例，编译器能够对这个实例进行正确传递，并将这个细节隐藏在协程的背后，让我们的异步代码看起来像同步代码一样。</p><p>说到这里，我们已经接近 Kotlin 协程的本质了，它是一种无栈协程实现，它的本质就是一段代码 + Continuation 实例。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712876557532.jpg" alt=""></p><h2 id="4-Kotlin-协程真的只是一个线程框架吗？"><a href="#4-Kotlin-协程真的只是一个线程框架吗？" class="headerlink" title="4. Kotlin 协程真的只是一个线程框架吗？"></a>4. Kotlin 协程真的只是一个线程框架吗？</h2><p>这个说法其实是很奇怪的。我如果问你线程其实是一个 CPU 框架吗，你肯定会觉得这俩，啥啊？？？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712877286523.jpg" alt=""></p><p>Kotlin 协程确实在实现的过程中提供了切线程的能力，这是它的能力，不是它的身份，就好比拿着学位证非说这是身份证一样，学位证描述的是这人能干啥，不能描述这人是谁。</p><blockquote><p>杠精们可能会说学位证有照片有名字啊。你拿着学位证去买飞机票你看人家认不认呗。</p></blockquote><p>协程的世界可以没有线程，如果操作系统的 CPU 调度模型是协程的话；反过来也成立——这个应该不会有人反对吧。Kotlin 协程是不是可以没有线程呢？至少从 Java 虚拟机的实现上来看，好像。。。。不太行啊。没错，是不太行，不过这不是 Kotlin 协程的问题，是 Java 虚拟机的问题，谁让 Java 虚拟机的线程用起来没有那么难用呢，在它刚出来的时候简直吊打了当时其他语言对并发的支持（就像 goroutine 出来的时候吊打它一样）。</p><p>我们知道 Kotlin 除了支持 Java 虚拟机之外，还支持 JavaScript，还支持 Native。JavaScript 无论是跑在 Web 还是 Node.js 当中，都是单线程玩耍的；Kotlin Native 虽然可以调用 pthread，但官方表示我们有自己的并发模型（Worker），不建议直接使用线程。在这两个平台上跑，Kotlin 的协程其实都是单线程的，又怎么讲是个线程框架呢？</p><p>说到这儿可能又有人有疑问了，单线程要协程能做什么呢？这个前端同学可能会比较有感触，谁跟你们说的异步一定要多线程。。Android 开发的同学其实可以想想你在 <code>Activity</code> 刚创建的时候想要拿到一个 <code>View</code> 的大小一般返回都是 0，因为 <code>Activity</code> 的布局是在 <code>onResume</code> 方法调用之后完成的，所以 <code>handler.post</code> 一下就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    handler.post &#123;</span><br><span class="line">        <span class="keyword">val</span> width = myView.width</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是异步代码嘛，但这代码其实都运行在主线程的，我们当然可以用协程改写一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        <span class="keyword">val</span> width = handler.postSuspend &#123;</span><br><span class="line">            myView.width</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(<span class="string">"MyView"</span>, width.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Handler.<span class="title">postSuspend</span><span class="params">(block: () -&gt; <span class="type">T</span>)</span></span> = suspendCoroutine&lt;T&gt; &#123;</span><br><span class="line">    post &#123;</span><br><span class="line">        it.resume(block())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我个人觉得如果 Kotlin 协程的默认的调度器是 <code>Main</code>，并且这个 <code>Main</code> 会根据各自平台选择一个合适的事件循环，这样更能体现 Kotlin 协程在不同平台的一致性，例如对于 Android 来说 <code>Main</code> 就是 UI 线程上的事件循环，对于 Swing 同样是 Swing 的 UI 事件循环，只要是有事件循环的平台就默认基于这个循环来一个调度器，没有默认事件循环的也好办，Kotlin 协程本身就有 <code>runBlocking</code> 嘛，对于普通 Java 程序来说没有事件循环就给它构造一个就行了。</p><p>Kotlin 协程的设计者没有这样做，他们当然也有他们的道理，毕竟他们不愿意强迫开发者一定要用协程，甚至立刻马上就得对原有的代码进行改造，他们希望 Kotlin 只是一门编程语言，一门提供足够安全保障和灵活语法的编程语言，剩下的交给开发者去选择。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712879342461.jpg" alt=""></p><h2 id="5-协程真的比线程有优势吗？"><a href="#5-协程真的比线程有优势吗？" class="headerlink" title="5. 协程真的比线程有优势吗？"></a>5. 协程真的比线程有优势吗？</h2><p>这可不是一个很容易回答的问题。</p><p>Kotlin 协程刚出来的时候，有人就做过性能对比，觉得协程没有任何性能优势。我们完全可以认为他的测试方法是专业的，在一些场景确实用协程不会有任何性能上的优势，这就好比我们需要在一个单核 CPU 上跑一个计算密集型的程序还要开多个线程跑一样，任何特性都有适合它的场景和不适合它的领域。</p><p>想必大家看各类讲解协程的文章都会提到协程比线程轻量，这个其实我们前面也解释过了，编程语言级别实现的协程就是程序内部的逻辑，不会涉及操作系统的资源之间的切换，操作系统的内核线程自然会重一些，且不说每创建一个线程就会开辟的栈带来的内存开销，线程在上下文切换的时候需要 CPU 把高速缓存清掉并从内存中替换下一个线程的内存数据，并且处理上一个内存的中断点保存就是一个开销很大的事儿。如果没有直观的感受的话，就尽情想象一下你正要拿五杀的时候公司领导在微信群里发消息问你今天的活跃怎么跌了的场景。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712882561417.jpg" alt=""></p><p>线程除了包含内核线程本身执行代码能力的含义以外，通常也被赋予了逻辑任务的概念，所以协程是一种轻量级的『线程』的说法，更多描述的是它的使用场景，这句话也许这样说更贴切一些：</p><p><strong>协程更像一种轻量级的『线程』。</strong></p><p>线程自然可以享受到并行计算的优待，协程则只能依赖程序内部的线程来实现并行计算。协程的优势其实更多是体现在 IO 密集型程序上，这对于 Java 开发者来说可能又是一个很迷惑的事情，因为大家写 Java 这么多年，很少有人用上 NIO，绝大多数都是用 BIO 来读写 IO，因此不管开线程还是开协程，读写 IO 的时候总是要有一个线程在等待 IO，所以看上去似乎也没有什么区别。但用 NIO 就不一样了，IO 不阻塞，通过开一个或很少的几个线程来 select IO 的事件，有 IO 事件到达时再分配相应的线程去读写 IO，比起传统的 IO 就已经有了很大的提升。</p><p>欸？没有写错吗？你写的可是线程啊？</p><p>对啊，用了 NIO 以后，本身就可以减少线程的使用，没错的。可是协程呢？协程可以基于这个思路进一步简化代码的组织，虽然线程就能解决问题，但写起来其实是很累的，协程可以让你更轻松，特别是遇到多个任务需要访问公共资源时，如果每个任务都分配一个线程去处理，那么少不了就有线程会花费大量的时间在等待获取锁上，但如果我们用协程来承载任务，用极少量的线程来承载协程，那么锁优化就变得简单了：协程如果无法获取到锁，那么协程挂起，对应的线程就可以让出去运行其他协程了。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712887435643.jpg" alt=""></p><p>我更愿意把协程作为更贴近业务逻辑甚至人类思考层面的一种抽象，这个抽象层次其实已经比线程更高了。线程可以让我们的程序并发的跑，协程可以让并发程序跑得看起来更美好。</p><blockquote><p>线程本身就可以，为什么要用协程呢？这就像我们经常被人问起 Java 就可以解决问题，我为什么要用 Kotlin 呢？为什么你说呢？</p></blockquote><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712891180933.jpg" alt=""></p><p>总的来说，不管是异步代码同步化，还是并发代码简洁化，协程的出现其实是为代码从计算机向人类思维的贴近提供了可能。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;接触新概念，最好的办法就是先整体看个大概，再回过头来细细品味。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(9) - Channel 篇</title>
    <link href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/"/>
    <id>https://www.bennyhuo.com/2019/09/16/coroutine-channel/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Channel</code> 实际上就是协程在生产消费者模型上的应用，把过去你用 <code>BlockingQueue</code> 实现的功能替换成 <code>Channel</code>，也许会有新的发现~</p></blockquote><a id="more"></a><h2 id="1-认识-Channel"><a href="#1-认识-Channel" class="headerlink" title="1. 认识 Channel"></a>1. 认识 Channel</h2><p>Channel 实际上就是一个队列，而且是并发安全的，它可以用来连接协程，实现不同协程的通信。废话不多说，直接看例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            channel.send(i++)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> element = channel.receive()</span><br><span class="line">            Logger.debug(element)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    producer.join()</span><br><span class="line">    consumer.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们构造了两个协程，分别叫他们 producer 和 consumer，我们没有明确的指定调度器，所以他们的调度器都是默认的，在 Java 虚拟机上就是那个大家都很熟悉的线程池：他们可以运行在不同的线程上，当然也可以运行在同一个线程上。</p><p>例子的运行机制是，producer 当中每隔 1s 向 <code>Channel</code> 中发送一个数字，而 consumer 那边则是一直在读取 Channel 来获取这个数字并打印，我们能够发现这里发端是比收端慢的，在没有值可以读到的时候，receive 是挂起的，直到有新元素 send 过来——所以你知道了 receive 是一个挂起函数，那么 send 呢？</p><h2 id="2-Channel-的容量"><a href="#2-Channel-的容量" class="headerlink" title="2. Channel 的容量"></a>2. Channel 的容量</h2><p>如果你自己去 IDE 写了这段代码，你会发现 send 也是挂起函数。额，发端为什么会挂起？想想我们以前熟知的 <code>BlockingQueue</code>，我们往里面添加元素的时候，元素在队列里实际上是占用了空间的，如果这个队列空间不足，那么再往里面添加的时候就是两种情况：1. 阻塞，等待队列腾出空间；2. 抛异常，拒绝添加元素。send 也会面临同样的问题，我们说 Channel 实际上就是一个队列嘛，队列不应该有缓冲区吗，那么这个缓冲区一旦满了，并且也一直没有人调用 receive 取走元素的话，send 不就挂起了嘛。那么接下来我们看下 <code>Channel</code> 的缓冲区的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> <span class="title">Channel</span><span class="params">(capacity: <span class="type">Int</span> = RENDEZVOUS)</span></span>: Channel&lt;E&gt; =</span><br><span class="line">    <span class="keyword">when</span> (capacity) &#123;</span><br><span class="line">        RENDEZVOUS -&gt; RendezvousChannel()</span><br><span class="line">        UNLIMITED -&gt; LinkedListChannel()</span><br><span class="line">        CONFLATED -&gt; ConflatedChannel()</span><br><span class="line">        <span class="keyword">else</span> -&gt; ArrayChannel(capacity)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们构造 <code>Channel</code> 的时候调用了一个叫 <code>Channel</code> 的函数，hmm，这玩意儿确实不是它的构造器，在 Kotlin 当中我们可以随便定义一个顶级函数跟某些类名一样来伪装成构造器，这本质上就是个工厂方法。</p><blockquote><p>类似的还有 String，不信你去试试</p></blockquote><p>它有一个参数叫 capacity，指定缓冲区的容量，默认值 <code>RENDEZVOUS</code> 就是 0，这个词本意就是描述“不见不散”的场景，所以你不来 receive，我这 send 就一直搁这儿挂起等着。换句话说，我们开头的例子里面，如果 consumer 不 receive，producer 里面的第一个 send 就给挂起了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        i++ <span class="comment">//为了方便输出日志，我们将自增放到前面</span></span><br><span class="line">        Logger.debug(<span class="string">"before send <span class="variable">$i</span>"</span>)</span><br><span class="line">        channel.send(i)</span><br><span class="line">        Logger.debug(<span class="string">"before after <span class="variable">$i</span>"</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        delay(<span class="number">2000</span>) <span class="comment">//receive 之前延迟 2s</span></span><br><span class="line">        <span class="keyword">val</span> element = channel.receive()</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们故意让收端的节奏放慢，你就会发现，send 总是会挂起，直到 receive 之后才会继续往下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">07:11:23:119 [DefaultDispatcher-worker-2 @coroutine#1]  before send 1</span><br><span class="line">07:11:24:845 [DefaultDispatcher-worker-2 @coroutine#2]  1</span><br><span class="line">07:11:24:846 [DefaultDispatcher-worker-2 @coroutine#1]  before after 1</span><br><span class="line">07:11:25:849 [DefaultDispatcher-worker-4 @coroutine#1]  before send 2</span><br><span class="line">07:11:26:850 [DefaultDispatcher-worker-2 @coroutine#2]  2</span><br><span class="line">07:11:26:850 [DefaultDispatcher-worker-3 @coroutine#1]  before after 2</span><br></pre></td></tr></table></figure><p><code>UNLIMITED</code> 比较好理解，来者不拒，从它给出的实现 <code>LinkedListChannel</code> 来看，这一点也与我们的 <code>LinkedBlockingQueue</code> 有异曲同工之妙。</p><p><code>CONFLATED</code>，这个词是合并的意思，跟 inflate 是同一个词根，con- 前缀表示反着来，那是不是说我发了个 1、2、3、4、5 那边收的时候就会收到一个 [1,2,3,4,5] 的集合呢？毕竟字面意思是合并嘛。但实际上这个的效果是只保留最后一个元素，不是合并，应该是置换，换句话说，这个类型的 Channel 有一个元素大小的缓冲区，但每次有新元素过来，都会用新的替换旧的，也就是说我发了个 1、2、3、4、5 之后收端才接收的话，就只能收到 5 了。</p><p>剩下的就是 <code>ArrayChannel</code> 了，它接收一个值作为缓冲区容量的大小，这也比较类似于 <code>ArrayBlockingQueue</code>。</p><h2 id="3-迭代-Channel"><a href="#3-迭代-Channel" class="headerlink" title="3. 迭代 Channel"></a>3. 迭代 Channel</h2><p>前面我们在发送和读取 <code>Channel</code> 的时候用了 <code>while(true)</code>，因为我们想要去不断的进行读写操作，<code>Channel</code> 本身实际上也有点儿像序列，可以一个一个读，所以我们在读取的时候也可以直接获取一个 <code>Channel</code> 的 iterator：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> iterator = channel.iterator()</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123; <span class="comment">// 挂起点</span></span><br><span class="line">        <span class="keyword">val</span> element = iterator.next()</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个时候，iterator.hasNext() 是挂起函数，在判断是否有下一个元素的时候实际上就需要去 <code>Channel</code> 当中读取元素了。</p><p>这个写法自然可以简化成 for each：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> channel) &#123;</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-produce-和-actor"><a href="#4-produce-和-actor" class="headerlink" title="4. produce 和 actor"></a>4. produce 和 actor</h2><p>前面我们在协程外部定义 <code>Channel</code>，并在协程当中访问它，实现了一个简单的生产-消费者的示例，那么有没有便捷的办法构造生产者<br>和消费者呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> receiveChannel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = GlobalScope.produce &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        send(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>produce</code> 这个方法启动一个生产者协程，并返回一个 <code>ReceiveChannel</code>，其他协程就可以拿着这个 <code>Channel</code> 来接收数据了。反过来，我们可以用 <code>actor</code> 启动一个消费者协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sendChannel: SendChannel&lt;<span class="built_in">Int</span>&gt; = GlobalScope.actor&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> element = receive()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ReceiveChannel 和 SendChannel 都是 Channel 的父接口，前者定义了 receive，后者定义了 send，Channel 也因此既可以 receive 又可以 send。</p></blockquote><p><code>produce</code> 和 <code>actor</code> 与 <code>launch</code> 一样都被称作“协程启动器”。通过这两个协程的启动器启动的协程也自然的与返回的 <code>Channel</code> 绑定到了一起，因此 <code>Channel</code> 的关闭也会在协程结束时自动完成，以 <code>produce</code> 为例，它构造出了一个 <code>ProducerCoroutine</code> 的对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerCoroutine</span>&lt;<span class="type">E</span>&gt;</span>(</span><br><span class="line">    parentContext: CoroutineContext, channel: Channel&lt;E&gt;</span><br><span class="line">) : ChannelCoroutine&lt;E&gt;(parentContext, channel, active = <span class="literal">true</span>), ProducerScope&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCompleted</span><span class="params">(value: <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        _channel.close() <span class="comment">// 协程完成时</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancelled</span><span class="params">(cause: <span class="type">Throwable</span>, handled: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> processed = _channel.close(cause) <span class="comment">// 协程取消时</span></span><br><span class="line">        <span class="keyword">if</span> (!processed &amp;&amp; !handled) handleCoroutineException(context, cause)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在协程完成和取消的方法调用中，对应的 <code>_channel</code> 都会被关闭。</p><p>这样看上去还是挺有用的。不过截止这俩 API <code>produce</code> 和 <code>actor</code> 目前都没有稳定，前者仍被标记为 <code>ExperimentalCoroutinesApi</code>，后者则标记为 <code>ObsoleteCoroutinesApi</code>，这就比较尴尬了，明摆着不让用嘛。<code>actor</code> 的文档中提到的 issue 的讨论也说明相比基于 Actor 模型的并发框架，Kotlin 协程提供的这个 <code>actor</code> API 也不过就是提供了一个 <code>SendChannel</code> 的返回值而已。当然，协程的负责人也有实现一套更复杂的 Actor 的想法，只是这一段时间的高优明显是 <code>Flow</code>——这货从协程框架的 v1.2 开始公测，到协程 v1.3 就稳定，真是神速，我们后面的文章会介绍它。</p><p>虽然 <code>produce</code> 没有被标记为 <code>ObsoleteCoroutinesApi</code>，显然它作为 <code>actor</code> 的另一半，不可能单独转正的，这俩 API 我的建议是看看就好了。</p><h2 id="5-Channel-的关闭"><a href="#5-Channel-的关闭" class="headerlink" title="5. Channel 的关闭"></a>5. Channel 的关闭</h2><p>前我们提到了 <code>produce</code> 和 <code>actor</code> 返回的 <code>Channel</code> 都会伴随着对应的协程执行完毕而关闭。哦，原来 <code>Channel</code> 还有一个关闭的概念。</p><p><code>Channel</code> 和我们后面的文章即将要探讨的 <code>Flow</code> 不同，它是在线的，是一个热数据源，换句话说就是有想要收数据，就要有人在对面给他发，就像发微信一样。既然这样，就难免曲终人散，对于一个 <code>Channel</code>，如果我们调用了它的 <code>close</code>，它会立即停止接受新元素，也就是说这时候它的 <code>isClosedForSend</code> 会立即返回 <code>true</code>，而由于 <code>Channel</code> 缓冲区的存在，这时候可能还有一些元素没有被处理完，所以要等所有的元素都被读取之后 <code>isClosedForReceive</code> 才会返回 <code>true</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    List(<span class="number">5</span>)&#123;</span><br><span class="line">        channel.send(it)</span><br><span class="line">        Logger.debug(<span class="string">"send <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">    Logger.debug(<span class="string">"close channel. ClosedForSend = <span class="subst">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class="subst">$&#123;channel.isClosedForReceive&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> channel) &#123;</span><br><span class="line">        Logger.debug(<span class="string">"receive: <span class="variable">$element</span>"</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Logger.debug(<span class="string">"After Consuming. ClosedForSend = <span class="subst">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class="subst">$&#123;channel.isClosedForReceive&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把例子稍作修改，开了一个缓冲区大小为 3 的 <code>Channel</code>，在 producer 协程里面快速的发送元素出去，发送5个之后关闭 <code>Channel</code>，而在 consumer 协程当中每秒读取一个， 结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 0</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-3]  receive: 0</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 1</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 2</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 3</span><br><span class="line">11:05:21:688 [DefaultDispatcher-worker-3]  receive: 1</span><br><span class="line">11:05:21:688 [DefaultDispatcher-worker-3]  send 4</span><br><span class="line">11:05:21:689 [DefaultDispatcher-worker-3]  close channel. ClosedForSend &#x3D;true ClosedForReceive &#x3D; false</span><br><span class="line">11:05:22:693 [DefaultDispatcher-worker-3]  receive: 2</span><br><span class="line">11:05:23:694 [DefaultDispatcher-worker-4]  receive: 3</span><br><span class="line">11:05:24:698 [DefaultDispatcher-worker-4]  receive: 4</span><br><span class="line">11:05:25:700 [DefaultDispatcher-worker-4]  After Consuming. ClosedForSend &#x3D;true ClosedForReceive &#x3D; true</span><br></pre></td></tr></table></figure><p>下面我们来探讨下 <code>Channel</code> 关闭的意义。</p><p>一说起关闭，我们就容易想到 IO，如果不关闭可能造成资源泄露，那么 <code>Channel</code> 的关闭是个什么概念呢？我们前面提到过，<code>Channel</code> 其实内部的资源就是个缓冲区，这个东西本质上就是个线性表，就是一块儿内存，所以如果我们开了一个 <code>Channel</code> 而不去关闭它，其实也不会造成什么资源泄露，发端如果自己已经发完，它就可以不理会这个 <code>Channel</code> 了。嗯，看上去好像没什么问题是吧？</p><p>But，这时候在接收端就比较尴尬了，它不知道会不会有数据发过来，如果 <code>Channel</code> 是微信，那么接收端打开微信的窗口可能一直看到的是『对方正在输入』，然后它就一直这样了，孤独终老。所以这里的关闭更多像是一种约定：</p><blockquote><p>女：咱俩没戏，你别傻等了。<br>男：哦。（您的消息未发送成功）</p></blockquote><p>那么 <code>Channel</code> 的关闭究竟应该有谁来处理呢？正常的通信，如果是单向的，就好比领导讲话，讲完都会说『我讲完了』，你不能在领导还没讲完的时候就说『我听完了』，所以单向通信的情况比较推荐由发端处理关闭；而对于双向通信的情况，就要考虑协商了，双向通信从技术上两端是对等的，但业务场景下通常来说不是，建议由主导的一方处理关闭。</p><p>还有一些复杂的情况，前面我们看到的例子都是一对一的收发，其实还有一对多，多对多的情况，这种也仍然存在主导一方，<code>Channel</code> 的生命周期最好由主导方来维护。官方文档给出的扇入(fan-in)和扇出(fan-out)，其实就是这种情况。</p><blockquote><p>扇入和扇出的概念可能大家不是很熟悉，网上的说法不是很通俗，大家就想象它是一把折扇，折扇的边射向圆心就是扇入，这种情况圆心如果是通信的一端，那它就是接收方，如果是一个函数，那它就是被调用方。扇入越大，说明模块的复用程度越高，以函数为例，如果一个函数被调用的次数越多，那说明复用的程度越高。扇出就是反过来的情况，描述的是复杂度高的情形，例如一个 Model，负责调用网络模块、数据库、文件等很多模块。</p></blockquote><h2 id="6-BroadcastChannel"><a href="#6-BroadcastChannel" class="headerlink" title="6. BroadcastChannel"></a>6. BroadcastChannel</h2><p>前面提到了一对多的情形，从数据处理的本身来讲，虽然有多个接收端，同一个元素只会被一个接收端读到。广播则不然，多个接收端不存在互斥行为。</p><p>直接创建 <code>broadcastChannel</code> 的方法跟普通的 <code>Channel</code> 似乎也没什么太多的不一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> broadcastChannel = broadcastChannel&lt;<span class="built_in">Int</span>&gt;(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>如果要订阅，那么只需要调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> receiveChannel = broadcastChannel.openSubscription()</span><br></pre></td></tr></table></figure><p>这样我们就得到了一个 <code>ReceiveChannel</code>，获取订阅的消息，只需要调用它的 <code>receive</code>。</p><p>我们看一个完整一点儿的例子，例子中我们在发端发送 1 - 5，并启动 3 个协程同时接收广播：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    List(<span class="number">5</span>) &#123;</span><br><span class="line">        broadcastChannel.send(it)</span><br><span class="line">        Logger.debug(<span class="string">"send <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">List(<span class="number">3</span>) &#123; index -&gt;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> receiveChannel = broadcast.openSubscription()</span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> receiveChannel) &#123;</span><br><span class="line">            Logger.debug(<span class="string">"[<span class="variable">$index</span>] receive: <span class="variable">$element</span>"</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.forEach &#123; it.join() &#125;</span><br><span class="line">    </span><br><span class="line">producer.join()</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">12:34:59:656 [DefaultDispatcher-worker-6]  [2] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-3]  [1] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-5]  [0] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-7]  send 0</span><br><span class="line">12:34:59:657 [DefaultDispatcher-worker-7]  send 1</span><br><span class="line">12:34:59:658 [DefaultDispatcher-worker-7]  send 2</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-3]  [0] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-5]  [1] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-6]  [2] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-8]  send 3</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-8]  [0] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-3]  [1] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-6]  [2] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-8]  send 4</span><br><span class="line">12:35:02:674 [DefaultDispatcher-worker-8]  [0] receive: 3</span><br><span class="line">12:35:02:674 [DefaultDispatcher-worker-7]  [1] receive: 3</span><br><span class="line">12:35:02:675 [DefaultDispatcher-worker-3]  [2] receive: 3</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-8]  [1] receive: 4</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-3]  [0] receive: 4</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-1]  [2] receive: 4</span><br></pre></td></tr></table></figure><p>这里请大家重点关注每一个收端协程都可以读取到每一个元素。</p><blockquote><p>日志顺序不能非常直观的反映数据的读写顺序，如果大家自己再次运行，顺序上可能也有出入。</p></blockquote><p>除了直接创建以外，我们也可以直接用前面定义的普通的 <code>Channel</code> 来做个转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> broadcast = channel.broadcast(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>其中，参数表示缓冲区的大小。</p><p>实际上这里得到的这个 <code>broadcastChannel</code> 可以认为与原 <code>Channel</code> 是级联关系，这个扩展方法的源码其实很清晰的为我们展示了这一点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> ReceiveChannel<span class="type">&lt;E&gt;</span>.<span class="title">broadcast</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    capacity: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.LAZY</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: broadcastChannel&lt;E&gt; =</span><br><span class="line">    GlobalScope.broadcast(Dispatchers.Unconfined, capacity = capacity, start = start, onCompletion = consumes()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (e <span class="keyword">in</span> <span class="keyword">this</span><span class="symbol">@broadcast</span>) &#123;  <span class="comment">//这实际上就是在读取原 Channel</span></span><br><span class="line">            send(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>哦~原来对于 <code>BroadcastChannel</code>，官方也提供类似于 <code>produce</code> 和 <code>actor</code> 的方式，我们可以通过 <code>CoroutineScope.broadcast</code> 来直接启动一个协程，并返回一个 <code>BroadcastChannel</code>。</p><p>需要注意的是，从原始的 <code>Channel</code> 转换到 <code>BroadcastChannel</code> 其实就是对原 <code>Channel</code> 的一个读取操作，如果还有其他协程也在读这个原始的 <code>Channel</code>，那么会与 <code>BroadcastChannel</code> 产生互斥关系。</p><p>另外，<code>BroadcastChannel</code> 相关的 API 大部分被标记为 <code>ExperimentalCoroutinesApi</code>，后续也许还会有调整。</p><h2 id="7-Channel-版本的序列生成器"><a href="#7-Channel-版本的序列生成器" class="headerlink" title="7. Channel 版本的序列生成器"></a>7. Channel 版本的序列生成器</h2><p>前面的文章我们讲到过 <code>Sequence</code>，它的生成器是基于标准库的协程的 API 实现的，实际上 <code>Channel</code> 本身也可以用来生成序列，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class="line">    Logger.debug(<span class="string">"A"</span>)</span><br><span class="line">    send(<span class="number">1</span>)</span><br><span class="line">    Logger.debug(<span class="string">"B"</span>)</span><br><span class="line">    send(<span class="number">2</span>)</span><br><span class="line">    Logger.debug(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> channel) &#123;</span><br><span class="line">    Logger.debug(<span class="string">"Got <span class="variable">$item</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了前面的基础这个就很容易看懂了，<code>produce</code> 创建的协程返回了一个缓冲区大小为 0 的 <code>Channel</code>，为了问题描述起来比较容易，我们传入了一个 <code>Dispatchers.Unconfined</code> 调度器，意味着协程会立即在当前协程执行到第一个挂起点，所以会立即输出 <code>A</code> 并在 <code>send(1)</code> 处挂起，直到后面的 for 循环读到第一个值时，实际上就是 <code>channel</code> 的 <code>iterator</code> 的 <code>hasNext</code> 方法的调用，这个 <code>hasNext</code> 方法会检查是否有下一个元素，是一个挂起函数，在检查的过程中就会让前面启动的协程从 <code>send(1)</code> 挂起的位置继续执行，因此会看到日志 <code>B</code> 输出，然后再挂起到 <code>send(2)</code> 这里，这时候 <code>hasNext</code> 结束挂起，for 循环终于输出第一个元素，依次类推。输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">22:33:56:073 [main @coroutine#1]  A</span><br><span class="line">22:33:56:172 [main @coroutine#1]  B</span><br><span class="line">22:33:56:173 [main]  Got 1</span><br><span class="line">22:33:56:173 [main @coroutine#1]  Done</span><br><span class="line">22:33:56:176 [main]  Got 2</span><br></pre></td></tr></table></figure><p>我们看到 <code>B</code> 居然比 <code>Got 1</code> 先输出，同样，<code>Done</code> 也比 <code>Got 2</code> 先输出，这个看上去比较不符合直觉，不过挂起恢复的执行顺序确实如此，关键点就是我们前面提到的 <code>hasNext</code> 方法会挂起并触发了协程内部从挂起点继续执行的操作。如果你选择了其他调度器，当然也会有其他合理的结果输出。不管怎么样，我们体验了一把用 <code>Channel</code> 模拟 <code>sequence</code>。如果类似的代码换作 <code>sequence</code>，是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sequence = sequence &#123;</span><br><span class="line">    Logger.debug(<span class="string">"A"</span>)</span><br><span class="line">    yield(<span class="number">1</span>)</span><br><span class="line">    Logger.debug(<span class="string">"B"</span>)</span><br><span class="line">    yield(<span class="number">2</span>)</span><br><span class="line">    Logger.debug(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger.debug(<span class="string">"before sequence"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> sequence) &#123;</span><br><span class="line">    Logger.debug(<span class="string">"Got <span class="variable">$item</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sequence</code> 的执行顺序要直观的多，它没有调度器的概念，而且 <code>sequence</code> 的 <code>iterator</code> 的 <code>hasNext</code> 和 <code>next</code> 都不是挂起函数，在 <code>hasNext</code> 的时候同样会触发元素的查找，这时候就会触发 <code>sequence</code> 内部逻辑的执行，因此这次实际上是先触发了 <code>hasNext</code> 才会输出 A，<code>yield</code> 把 1 传出来作为 <code>sequence</code> 的第一个元素，这样就会有 Got 1 这样的输出，完整输出如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">600</span> [main]  A</span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">603</span> [main]  Got <span class="number">1</span></span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  B</span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  Got <span class="number">2</span></span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  Done</span><br></pre></td></tr></table></figure><p><code>sequence</code> 本质上就是基于标准库的协程 API 实现的，没有上层协程框架的作用域以及 Job 这样的概念。</p><p>所以我们可以在 <code>Channel</code> 的例子里面切换不同的调度器来生成元素，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class="line">    Logger.debug(<span class="number">1</span>)</span><br><span class="line">    send(<span class="number">1</span>)</span><br><span class="line">    withContext(Dispatchers.IO)&#123;</span><br><span class="line">        Logger.debug(<span class="number">2</span>)</span><br><span class="line">        send(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Logger.debug(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sequence 就不行了。</p><p>当然，单纯的用 <code>Channel</code> 当做序列生成器来使用有点儿小题大做，这里更多的是告诉大家存在这样的可能性，大家在将来遇到合适的场景时，就可以灵活运用了。</p><h2 id="8-Channel-的内部结构"><a href="#8-Channel-的内部结构" class="headerlink" title="8. Channel 的内部结构"></a>8. Channel 的内部结构</h2><p>前面我们提到 <code>sequence</code> 无法享受更上层的协程框架概念下的各种能力，还有一点 <code>sequence</code> 显然不是线程安全的，而 <code>Channel</code> 可以在并发场景下使用。</p><p><code>Channel</code> 内部结构我们主要说下缓冲区分别是链表和数组的版本。链表版本的定义主要是在 <code>AbstractSendChannel</code> 当中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSendChannel</span>&lt;<span class="type">E</span>&gt; : <span class="type">SendChannel</span>&lt;<span class="type">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> queue = LockFreeLinkedListHead()</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LockFreeLinkedListHead</code> 本身其实就是一个双向链表的节点，实际上 <code>Channel</code> 把它首尾相连成为了循环链表，而这个 <code>queque</code> 就是哨兵(sentinel)节点。有新的元素添加时，就在 <code>queue</code> 的前面插入，实际上就相当于在整个队列的最后插入元素了。</p><p>它所谓的 <code>LockFree</code> 在 Java 虚拟机上其实是通过原子读写来实现的， 对于链表来说，需要修改的无非就是前后节点的引用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeLinkedListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _next = atomic&lt;Any&gt;(<span class="keyword">this</span>) <span class="comment">// Node | Removed | OpDescriptor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _prev = atomic&lt;Any&gt;(<span class="keyword">this</span>) <span class="comment">// Node | Removed</span></span><br><span class="line">    ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现基于一篇论文中提到的无锁链表的实现，由于 CAS 原子操作通常只能修改一个引用，对于需要原子同时修改前后节点引用的情形是不适用的，例如单链表插入节点时需要修改两个引用，分别是操作节点的前一个节点的 next 和自己的 next，即 Head -&gt; A -&gt; B -&gt; C 在 A 、B 之间插件 X 时会需要先修改 X -&gt; B 再修改 A -&gt; X，如果这个过程中 A 被删除，那么可能的结果是 X 一并被删除，得到的链表是 Head -&gt; B -&gt; C。</p><p>这个无锁链表的实现通过引入 prev 来辅助解决这个问题，即在 A 被删除的问题发生的同时，其实我们是可以做到 X.next = B，X.prev = A 的，这时候判断如果 A 已经被移除了，那么 B.prev 本来是 A，结果就变成了 Head，这时候就可以将 X.prev 再次赋值为 B.prev 来修复，当然这个过程稍稍有些复杂，有兴趣的同学也可以参考 <code>LockFreeLinkedListNode</code> 在 Jvm 上的实现。</p><p>而对于数组版本，<code>ArrayChannel</code> 就相对粗暴了，内部就是一个数组：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓冲区大小大于 8，会先分配大小为 8 的数组，在后续进行扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> buffer: Array&lt;Any?&gt; = arrayOfNulls&lt;Any?&gt;(min(capacity, <span class="number">8</span>))</span><br></pre></td></tr></table></figure><p>对这个数组读写时则直接用了一个 <code>ReentrantLock</code> 进行加锁。</p><p>这里是不是有优化的空间呢？其实对于数组的元素，我们同样可以进行 CAS 读写，如果大家有兴趣，可以参考下 <code>ConcurrentHashMap</code> 的实现，JDK 7 的实现中对于段数组的读写采用了 <code>UnSafe</code> 的 CAS 读写，JDK 1.8 直接干掉了分段，对于桶的读写也采用了 <code>UnSafe</code> 的 CAS。</p><blockquote><p>协程在 Js 和 Native 上的实现就要简单得多，因为它们的协程都只是在单线程上运行，基本不需要处理并发问题。</p></blockquote><h2 id="9-小结"><a href="#9-小结" class="headerlink" title="9. 小结"></a>9. 小结</h2><p><code>Channel</code> 的出现，应该说为协程注入了灵魂。每一个独立的协程不再是孤独的个体，<code>Channel</code> 可以让他们更加方便的协作起来。实际上 <code>Channel</code> 的概念并不是 Kotlin 原创的，且不说 Golang 里面的 <code>channel</code>，就说 Java NIO 当中也存在 <code>Channel</code> 这样的概念，其实这时候大家很容易就应该想到多路复用，多路复用的时候我们还能像前面那样简单的挂起吗？或者不挂起我们该怎么办呢？且看下回分解。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;code&gt;Channel&lt;/code&gt; 实际上就是协程在生产消费者模型上的应用，把过去你用 &lt;code&gt;BlockingQueue&lt;/code&gt; 实现的功能替换成 &lt;code&gt;Channel&lt;/code&gt;，也许会有新的发现~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(8) - Android 篇</title>
    <link href="https://www.bennyhuo.com/2019/05/27/coroutine-android/"/>
    <id>https://www.bennyhuo.com/2019/05/27/coroutine-android/</id>
    <published>2019-05-26T16:00:00.000Z</published>
    <updated>2020-11-07T02:28:44.214Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~</p></blockquote><a id="more"></a><p>本文涉及的 MainScope 以及 AutoDispose 源码：<a href="https://github.com/enbandari/kotlin-coroutines-android" target="_blank" rel="noopener">kotlin-coroutines-android</a></p><h2 id="1-配置依赖"><a href="#1-配置依赖" class="headerlink" title="1. 配置依赖"></a>1. 配置依赖</h2><p>我们曾经提到过，如果在 Android 上做开发，那么我们需要引入</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutine_version'</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这个框架里面包含了 Android 专属的 `Dispatcher`，我们可以通过 `Dispatchers.Main` 来拿到这个实例；也包含了 `MainScope`，用于与 Android 作用域相结合。</span><br><span class="line"></span><br><span class="line">~~Anko 也提供了一些比较方便的方法，例如 `onClick` 等等，如果需要，也可以引入它的依赖：~~（Anko 已经停止维护）</span><br><span class="line"></span><br><span class="line">```gradle</span><br><span class="line"><span class="comment">//提供 onClick 类似的便捷的 listener，接收 suspend Lambda 表达式</span></span><br><span class="line">implementation <span class="string">"org.jetbrains.anko:anko-sdk27-coroutines:$anko_version"</span></span><br><span class="line"><span class="comment">//提供 bg 、asReference，未跟进 kotlin 1.3 的正式版协程，不过代码比较简单，如果需要可以自己改造</span></span><br><span class="line">implementation <span class="string">"org.jetbrains.anko:anko-coroutines:$anko_version"</span></span><br></pre></td></tr></table></figure><p>简单来说：</p><ul><li>kotlinx-coroutines-android 这个框架是必选项，主要提供了专属调度器</li><li><del>anko-sdk27-coroutines 是可选项，提供了一些 UI 组件更为简洁的扩展，例如 onClick，但它也有自己的问题，我们后面详细探讨</del></li><li><del>anko-coroutines 仅供参考，未跟进 1.3 正式版协程，因此在 1.3 之后的版本中尽量不要使用，提供的两个方法都比较简单，如果需要，可自行改造使用。</del></li></ul><p>协程的原理和用法我们已经探讨了很多了，关于 Android 上面的协程使用，我们就只给出几点实践的建议。</p><h2 id="2-UI-生命周期作用域"><a href="#2-UI-生命周期作用域" class="headerlink" title="2. UI 生命周期作用域"></a>2. UI 生命周期作用域</h2><p>Android 开发经常想到的一点就是让发出去的请求能够在当前 UI 或者 Activity 退出或者销毁的时候能够自动取消，我们在用 RxJava 的时候也有过各种各样的方案来解决这个问题。</p><h3 id="2-1-使用-MainScope"><a href="#2-1-使用-MainScope" class="headerlink" title="2.1 使用 MainScope"></a>2.1 使用 MainScope</h3><p>协程有一个很天然的特性能刚够支持这一点，那就是作用域。官方也提供了 <code>MainScope</code> 这个函数，我们具体看下它的使用方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line">launchButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        textView.text = async(Dispatchers.IO) &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">3</span>)</span><br><span class="line">            <span class="string">"Hello1111"</span></span><br><span class="line">        &#125;.await()</span><br><span class="line">        log(<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现它其实与其他的 <code>CoroutineScope</code> 用起来没什么不一样的地方，通过同一个叫 <code>mainScope</code> 的实例启动的协程，都会遵循它的作用域定义，那么 <code>MainScope</code> 的定义时怎样的呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">MainScope</span><span class="params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)</span><br></pre></td></tr></table></figure><p>原来就是 <code>SupervisorJob</code> 整合了 <code>Dispatchers.Main</code> 而已，它的异常传播是自上而下的，这一点与 <code>supervisorScope</code> 的行为一致，此外，作用域内的调度是基于 Android 主线程的调度器的，因此作用域内除非明确声明调度器，协程体都调度在主线程执行。因此上述示例的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-04-29 06:51:00.657 D: [main] 1</span><br><span class="line">2019-04-29 06:51:00.659 D: [DefaultDispatcher-worker-1] 2</span><br><span class="line">2019-04-29 06:51:01.662 D: [DefaultDispatcher-worker-2] 3</span><br><span class="line">2019-04-29 06:51:01.664 D: [main] 4</span><br></pre></td></tr></table></figure><p>如果我们在触发前面的操作之后立即在其他位置触发作用域的取消，那么该作用域内的协程将不再继续执行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line"></span><br><span class="line">launchButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cancelButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.cancel()</span><br><span class="line">    log(<span class="string">"MainScope is cancelled."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们快速依次点击上面的两个按钮，结果就显而易见了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-04-29 07:12:20.625 D: [main] 1</span><br><span class="line">2019-04-29 07:12:20.629 D: [DefaultDispatcher-worker-2] 2</span><br><span class="line">2019-04-29 07:12:21.046 D: [main] MainScope is cancelled.</span><br></pre></td></tr></table></figure><h3 id="2-2-构造带有作用域的抽象-Activity"><a href="#2-2-构造带有作用域的抽象-Activity" class="headerlink" title="2.2 构造带有作用域的抽象 Activity"></a>2.2 构造带有作用域的抽象 Activity</h3><p>尽管我们前面体验了 <code>MainScope</code> 发现它可以很方便的控制所有它范围内的协程的取消，以及能够无缝将异步任务切回主线程，这都是我们想要的特性，不过写法上还是不够美观。</p><p>官方推荐我们定义一个抽象的 <code>Activity</code>，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopedActivity</span>: <span class="type">Activity</span></span>(), CoroutineScope <span class="keyword">by</span> MainScope()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在 <code>Activity</code> 退出的时候，对应的作用域就会被取消，所有在该 <code>Activity</code> 中发起的请求都会被取消掉。使用时，只需要继承这个抽象类即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineActivity</span> : <span class="type">ScopedActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_coroutine)</span><br><span class="line">        launchButton.setOnClickListener &#123;</span><br><span class="line">            launch &#123; <span class="comment">// 直接调用 ScopedActivity 也就是 MainScope 的方法</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">anotherOps</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了在当前 <code>Activity</code> 内部获得 <code>MainScope</code> 的能力外，还可以将这个 Scope 实例传递给其他需要的模块，例如 <code>Presenter</code> 通常也需要与 <code>Activity</code> 保持同样的生命周期，因此必要时也可以将该作用域传递过去：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutinePresenter</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> scope: CoroutineScope): CoroutineScope <span class="keyword">by</span> scope&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        launch &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多数情况下，<code>Presenter</code> 的方法也会被 <code>Activity</code> 直接调用，因此也可以将 <code>Presenter</code> 的方法生命成 <code>suspend</code> 方法，然后用 <code>coroutineScope</code> 嵌套作用域，这样 <code>MainScope</code> 被取消后，嵌套的子作用域一样也会被取消，进而达到取消全部子协程的目的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutinePresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">        launch &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-更友好地为-Activity-提供作用域"><a href="#2-3-更友好地为-Activity-提供作用域" class="headerlink" title="2.3 更友好地为 Activity 提供作用域"></a>2.3 更友好地为 Activity 提供作用域</h3><p>抽象类很多时候会打破我们的继承体系，这对于开发体验的伤害还是很大的，因此我们是不是可以考虑构造一个接口，只要 <code>Activity</code> 实现这个接口就可以拥有作用域以及自动取消的能力呢？</p><p>首先我们定义一个接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ScopedActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> scope: CoroutineScope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个朴实的愿望就是希望实现这个接口就可以自动获得作用域，不过问题来了，这个 <code>scope</code> 成员要怎么实现呢？留给接口实现方的话显然不是很理想，自己实现吧，又碍于自己是个接口，因此我们只能这样处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> scopeMap = IdentityHashMap&lt;MainScoped, MainScope&gt;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> mainScope: CoroutineScope</span><br><span class="line">        <span class="keyword">get</span>() = scopeMap[<span class="keyword">this</span> <span class="keyword">as</span> Activity]!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的事情就是在合适的实际去创建和取消对应的作用域了，我们接着定义两个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createScope</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//或者改为 lazy 实现，即用到时再创建</span></span><br><span class="line">        <span class="keyword">val</span> activity = <span class="keyword">this</span> <span class="keyword">as</span> Activity</span><br><span class="line">        scopeMap[activity] ?: MainScope().also &#123; scopeMap[activity] = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroyScope</span><span class="params">()</span></span>&#123;</span><br><span class="line">        scopeMap.remove(<span class="keyword">this</span> <span class="keyword">as</span> Activity)?.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们需要 <code>Activity</code> 去实现这个接口，因此直接强转即可，当然如果考虑健壮性，可以做一些异常处理，这里作为示例仅提供核心实现。</p><p>接下来就是考虑在哪儿完成创建和取消呢？显然这件事儿用 <code>Application.ActivityLifecycleCallbacks</code> 最合适不过了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityLifecycleCallbackImpl</span>: <span class="type">Application.ActivityLifecycleCallbacks &#123;</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(activity: <span class="type">Activity</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        (activity <span class="keyword">as</span>? MainScoped)?.createScope()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        (activity <span class="keyword">as</span>? MainScoped)?.destroyScope()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是在 <code>Application</code> 里面注册一下这个监听了，这个大家都会，我就不给出代码了。</p><p>我们看下如何使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineActivity</span> : <span class="type">Activity</span></span>(), MainScoped &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        launchButton.setOnClickListener &#123;            </span><br><span class="line">            scope.launch &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以增加一些有用的方法来简化这个操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">withScope</span><span class="params">(block: <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>)</span></span> = with(scope, block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在 <code>Activity</code> 当中还可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">withScope &#123;</span><br><span class="line">    launch &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，示例当中用到了 <code>IdentityHashMap</code>，这表明对于 scope 的读写是非线程安全的，因此不要在其他线程试图去获取它的值，除非你引入第三方或者自己实现一个 <code>IdentityConcurrentHashMap</code>，即便如此，从设计上 <code>scope</code> 也不太应该在其他线程访问。</p></blockquote><p>按照这个思路，我提供了一套更加完善的方案，不仅支持 <code>Activity</code> 还支持 support-fragment 版本在 25.1.0 以上的版本的 <code>Fragment</code>，并且类似于 Anko 提供了一些有用的基于 <code>MainScope</code> 的 listener 扩展，引入这个框架即可使用：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api <span class="string">'com.bennyhuo.kotlin:coroutines-android-mainscope:1.0'</span></span><br></pre></td></tr></table></figure><h3 id="2-4-Androidx-的协程支持"><a href="#2-4-Androidx-的协程支持" class="headerlink" title="2.4 Androidx 的协程支持"></a>2.4 Androidx 的协程支持</h3><p>Android 官方对于协程的支持也是非常积极的。</p><p>KTX 为 Jetpack 的 Lifecycle 相关的组件都提供了已经绑定了生命周期的作用域供我们直接使用，添加 Lifecycle 相应的基础组件之后，再添加以下组件即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-runtime-ktx:<span class="variable">$ktx_version</span>"</span></span><br></pre></td></tr></table></figure><p><code>lifecycle-runtime-ktx</code> 提供了 <code>LifecycleCoroutineScope</code> 类以及其获得方式，例如我们可以直接在 <code>MainActivity</code> 中使用 <code>lifecycleScope</code> 来获取这个实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            lifecycleScope.launch &#123;</span><br><span class="line">                ...<span class="comment">// 执行协程体</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这当然是因为 <code>MainActivity</code> 的父类实现了 <code>LifecycleOwner</code> 这个接口，而 <code>lifecycleScope</code> 则正是它的扩展成员。</p><p>如果想要在 <code>ViewModel</code> 当中使用作用域，我们需要再添加以下依赖：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-ktx:<span class="variable">$ktx_version</span>"</span></span><br></pre></td></tr></table></figure><p>使用方法类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            ... <span class="comment">// 执行协程体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewModel</code> 的作用域会在它的 <code>clear</code> 函数调用时取消。</p><h2 id="3-谨慎使用-GlobalScope"><a href="#3-谨慎使用-GlobalScope" class="headerlink" title="3. 谨慎使用 GlobalScope"></a>3. 谨慎使用 GlobalScope</h2><h3 id="3-1-GlobalScope-存在什么问题"><a href="#3-1-GlobalScope-存在什么问题" class="headerlink" title="3.1 GlobalScope 存在什么问题"></a>3.1 GlobalScope 存在什么问题</h3><p>我们之前做例子经常使用 <code>GlobalScope</code>，但 <code>GlobalScope</code> 不会继承外部作用域，因此大家使用时一定要注意，如果在使用了绑定生命周期的 <code>MainScope</code> 之后，内部再使用 <code>GlobalScope</code> 启动协程，意味着 <code>MainScope</code> 就不会起到应有的作用。</p><p>这里需要小心的是如果使用了一些没有依赖作用域的构造器，那么一定要小心。例如 Anko 当中的 <code>onClick</code> 扩展：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClick</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许我们也就是图个方便，毕竟 <code>onClick</code> 写起来可比 <code>setOnClickListener</code> 要少很多字符，同时名称上看也更加有事件机制的味道，但隐藏的风险就是通过 <code>onClick</code> 启动的协程并不会随着 <code>Activity</code> 的销毁而被取消，其中的风险需要自己思考清楚。</p><p>当然，Anko 会这么做的根本原因在于 <code>OnClickListener</code> 根本拿不到有生命周期加持的作用域。不用 <code>GlobalScope</code> 就无法启动协程，怎么办？结合我们前面给出的例子，其实这个事儿完全有别的解法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> View.<span class="title">onClickSuspend</span><span class="params">(handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        setOnClickListener &#123; v -&gt;</span><br><span class="line">            scope.launch &#123;   handler(v)   &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在前面定义的 <code>MainScoped</code> 接口中，可以通过 <code>scope</code> 拿到有生命周期加持的 <code>MainScope</code> 实例，那么直接用它启动协程来运行 <code>OnClickListener</code> 问题不就解决了嘛。所以这里的关键点在于如何拿到作用域。</p><p>这样的 listener 我已经为大家在框架中定义好啦，请参见 2.3。</p><p>当然，如果项目已经集成了 AndroidX，还是更加推荐大家直接使用官方的作用域扩展。另外需要注意的是，Anko 已经停止维护，不再建议使用了。</p><h3 id="3-2-协程版-AutoDisposable"><a href="#3-2-协程版-AutoDisposable" class="headerlink" title="3.2 协程版 AutoDisposable"></a>3.2 协程版 AutoDisposable</h3><p>当然除了直接使用一个合适的作用域来启动协程之外，我们还有别的办法来确保协程及时被取消。</p><p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p><p>因此大家一定会用到 Uber 的开源框架 <a href="https://github.com/uber/AutoDispose" target="_blank" rel="noopener">AutoDispose</a>。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">extends</span> <span class="title">MainThreadDisposable</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnAttachStateChangeListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View view;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CompletableObserver observer;</span><br><span class="line"></span><br><span class="line">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.view = view;</span><br><span class="line">    <span class="keyword">this</span>.observer = observer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">    <span class="comment">//看到没看到没看到没？</span></span><br><span class="line">      observer.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    view.removeOnAttachStateChangeListener(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到前面提到的 Anko 扩展 <code>onClick</code> 无法取消协程的问题，我们也可以搞一个 <code>onClickAutoDisposable</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClickAutoDisposable</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;.asAutoDisposable(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 <code>launch</code> 会启动一个 <code>Job</code>，因此我们可以通过 <code>asAutoDisposable</code> 来将其转换成支持自动取消的类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Job.<span class="title">asAutoDisposable</span><span class="params">(view: <span class="type">View</span>)</span></span> = AutoDisposableJob(view, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>那么 <code>AutoDisposableJob</code> 的实现只要参考 AutoDisposable 的实现依样画葫芦就好了 ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoDisposableJob</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View, <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Job)</span><br><span class="line">    <span class="comment">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class="line">     : Job <span class="keyword">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> = <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//当 View 被移除的时候，取消协程</span></span><br><span class="line">        cancel()</span><br><span class="line">        view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isViewAttached</span><span class="params">()</span></span> =</span><br><span class="line">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isViewAttached()) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class="line">        invokeOnCompletion() &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就可以使用这个扩展了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.onClickAutoDisposable&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令，尽管这种情况下协程的执行不会跟随 <code>Activity</code> 的 <code>onDestroy</code> 而取消，但它与 <code>View</code> 的点击事件紧密结合，即便 <code>Activity</code> 没有被销毁，<code>View</code> 本身被移除时也会直接将监听中的协程取消掉。</p><p>如果大家想要用这个扩展，我已经帮大家放到 jcenter 啦，直接使用：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api <span class="string">"com.bennyhuo.kotlin:coroutines-android-autodisposable:1.0"</span></span><br></pre></td></tr></table></figure><p>添加到依赖当中即可使用。</p><h2 id="4-合理使用调度器"><a href="#4-合理使用调度器" class="headerlink" title="4. 合理使用调度器"></a>4. 合理使用调度器</h2><p>在 Android 上使用协程，更多的就是简化异步逻辑的写法，使用场景更多与 RxJava 类似。在使用 RxJava 的时候，我就发现有不少开发者仅仅用到了它的切线程的功能，而且由于本身 RxJava 切线程 API 简单易用，还会造成很多无脑线程切换的操作，这样实际上是不好的。那么使用协程就更要注意这个问题了，因为协程切换线程的方式被 RxJava 更简洁，更透明，本来这是好事情，就怕被滥用。</p><p>比较推荐的写法是，绝大多数 UI 逻辑在 UI 线程中处理，即使在 UI 中用 <code>Dispatchers.Main</code> 来启动协程，如果涉及到一些 io 操作，使用 <code>async</code> 将其调度到 <code>Dispatchers.IO</code> 上，结果返回时协程会帮我们切回到主线程——这非常类似 Nodejs 这样的单线程的工作模式。</p><p>对于一些 UI 不相关的逻辑，例如批量离线数据下载任务，通常默认的调度器就足够使用了。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>这一篇文章，主要是基于我们前面讲了的理论知识，进一步往 Android 的具体实战角度迁移，相比其他类型的应用，Android 作为 UI 程序最大的特点就是异步要协调好 UI 的生命周期，协程也不例外。一旦我们把协程的作用域规则以及协程与 UI 生命周期的关系熟稔于心，那么相信大家使用协程时一定会得心应手的。</p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html" target="_blank" rel="noopener">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png" alt=""></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
      <category term="android" scheme="https://www.bennyhuo.com/tags/android/"/>
    
  </entry>
  
</feed>
