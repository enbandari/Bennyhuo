<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bennyhuo</title>
  
  <subtitle>编程、教学 &amp; Kotlin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.bennyhuo.com/"/>
  <updated>2021-02-09T03:29:15.428Z</updated>
  <id>https://www.bennyhuo.com/</id>
  
  <author>
    <name>Bennyhuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《深入理解 Kotlin 协程》这书该怎么读？</title>
    <link href="https://www.bennyhuo.com/2021/01/31/how-to-read-the-book-of-coroutines/"/>
    <id>https://www.bennyhuo.com/2021/01/31/how-to-read-the-book-of-coroutines/</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-02-09T03:29:15.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>趁着面试官还没看，赶紧深入了解一下~~ </p></blockquote><a id="more"></a><p>朋友们好呀~ </p><p>鼠年进入了尾声，想想过去的这一年还是发生了很多事情：终于有了回家的高铁，可刚回家没几天就又匆匆踏上了返京的旅途；写了一本书；做了一次线下的大会分享；做了两次线上的分享；上线了一套课程；买了 * * *；在公司也终于起了一个跨平台（Android + Linux）的项目，体验了一把 Kotlin MPP 等等，话说我司今年的阳光有点儿刺眼啊 ：）。想了想，这一年也过得挺充实。</p><p>不过，也有些地方做的不好，例如书出版之后就没怎么管过了，就感觉这本书不是我写的一样。最近终于得空，为了了解一下读者遇到的问题，就去京东上刷了一下本书的评论，发现其中的内容非常有趣。在对这些评论做出回应的同时，我也希望能够对大家阅读本书提供一些帮助。</p><h2 id="本书收到的评论"><a href="#本书收到的评论" class="headerlink" title="本书收到的评论"></a>本书收到的评论</h2><p>以下来自京东自营商品的商品评价，用户关键信息已打码。</p><h3 id="负面评论"><a href="#负面评论" class="headerlink" title="负面评论"></a>负面评论</h3><p><strong>差评一：完全没干货</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-55.png"></p><p><strong>不正经的回应</strong>：我都惊呆了，居然说我的书没干货！你知道吗，以前大家可都是吐槽我写的东西干货太多了呢 ψ(*｀ー´)ψ。至于说“一会儿就翻完了”这事儿，200 多页如果只是翻的话，确实很快 (｀・ω・´)。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-30-13.png"></p><p><strong>正经的回应</strong>：想要了解 Kotlin 协程的底层原理，请参见：本书第 3 ~ 5 章，其中第 3 章重要从底层的标准库 API 讲起，对挂起函数的本质、协程上下文、拦截器等概念做了深入的讲解；第 4 章主要是对第 3 章知识的应用；第 5 章则是对官方协程框架内核的剖析，剖析的方法就是我们一步一步地实现了一套精简版的协程框架 CoroutineLite。</p><p><strong>差评二：一上来就讲原理，压根接受不了</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-24.png"></p><p><strong>不正经的回应</strong>：我没有，我不是，别瞎说啊 ┗( ▔, ▔ )┛</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-34-00.png"></p><p><strong>正经的回应</strong>：实际上本书的开篇并没有讲原理，而是讲概念。我们必须先统一对概念的理解和认识，才能够在后续的深入理解上畅通无阻。因此，第 1 章是对整体异步程序的概念做了剖析，这是整个协程概念的基础；第 2 章剖析协程的概念，光讲概念太抽象，于是我还结合了常见的协程实现做了阐述。</p><p><strong>中评一：代码贴得多，理论分析少；内容不深刻，停留在基础阶段</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-58-00.png"></p><p><strong>不正经的回应</strong>：额，你可能不知道，我的书刚出版的时候，群里的小伙伴们看了之后都在说比某某源码**强太多了，是我听错了么 (；´д｀)ゞ</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-37-20.png"></p><p><strong>正经的回应</strong>：两个问题：</p><ol><li>代码贴得多不多这个问题，技术书籍难免需要贴代码。到底什么是多，每个人的看法不一样，我只给出统计数据（基于本书底稿，与最终排版结果可能有稍许出入）（￣︶￣）↗：本书纯文字部分约 6000 行；插图共计 67 幅；代码部分约 3350 行，其中 Kotlin 约 3200 行，Java 62 行，JavaScript 41 行，Python 27 行，Lua 25 行，C 11 行。插图排版之后平均约占 10 行的篇幅，由此估计本书文字部分占比约 60%，插图部分占比约 7%，代码部分占比约 33%。</li><li>内容不深刻，停留在基础阶段。不错，我确实是花了三分之一的篇幅讲基础，也花了三分之一的篇幅讲进阶，还花了三分之一的篇幅讲实战，你不妨看完第一章第一节之后再往后看一看(Θ０Θ●)？</li></ol><p><strong>中评二：缺乏系统性介绍；代码格式很??（目测是很乱的意思）</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-44-01.png"></p><p><strong>不正经的回应</strong>：你是不喜欢 JetBrains Mono 吗？难道你的代码用的是微软雅黑？╮(╯﹏╰）╭</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-41-05.png"></p><p><strong>正经的回应</strong>：也是两个问题：</p><ol><li>缺乏系统性介绍这个问题，可能真的不存在。我也做过反思，这本书可能最大的问题是没有迎合多数开发者“速成 Kotlin 协程”的想法，也就是说我可能就是因为讲的太系统了 (๑╹◡╹)ﾉ”””  —— 但饭要一口一口吃嘛，速成的东西又有什么价值呢？</li><li>至于代码格式，审美这个东西也是因人而异。还是老规矩，我只列出我做过的一些努力：为了防止被动折行的产生，我将缩进调成了 2 个空格；本书终稿我把所有被动折行的部分全部通过手动重排以使代码看起来更加清晰，也就是说你看到的书上应该很少有代码单行字符数超过 80 的情况；另外，本书代码全部采用 JetBrains Mono 字体。如果你觉得这样不好，也可以评论告诉我具体怎么样是好的。</li></ol><p><strong>中评三：篇幅太小，一笔带过，算不上深入理解</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-54-14.png"></p><p><strong>不正经的回应</strong>：啊，我懂了！作为优秀的打工人，我猜你一定喜欢1000多页的大砖头！ヽ(ﾟ∀ﾟ)ﾒ(ﾟ∀ﾟ)ﾉ </p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-43-40.png"></p><p><strong>正经的回应</strong>：其实吧，对于本书的评价，负面的主要是两种声音：一种是太深了，读不懂；另一种是算不上深入理解。ε=(´ο｀*)))唉，我好难。你好歹看一看书的内容再来喷也不迟啊。</p><h3 id="正面评论"><a href="#正面评论" class="headerlink" title="正面评论"></a>正面评论</h3><p>整体上正面评论更多一些，我就挑了两个列出来：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-09-04-25.png"></p><p><strong>不正经的回应</strong>：我没啥好说的，我也是这么想的(✪ω✪)！</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D2C7B5.gif" alt="img"></p><p><strong>正经的回应</strong>：这种时候根本正经不起来好吧！</p><h2 id="本书的阅读建议"><a href="#本书的阅读建议" class="headerlink" title="本书的阅读建议"></a>本书的阅读建议</h2><p>咳咳，严肃点儿哈。实际上之所以有差评，就是因为有误会。毕竟大家的知识背景有差异，而一本书想要填平这差异显然是不现实的。当然不排除有人恶意评价，但相信这种情况应该占少数。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-47-18.png"></p><p>而我本人呢，在出版这本书之后几乎没有再对它做过任何补充和说明，甚至连协程的文章都没有再写了，想来也有点儿没道理。有朋友说我简直佛系到家了。(〃’▽’〃)</p><p>所以接下来我提供一些我对阅读本书的看法，看看能不能帮助大家更好的阅读这本书。</p><h3 id="本书的内容来源"><a href="#本书的内容来源" class="headerlink" title="本书的内容来源"></a>本书的内容来源</h3><p>要搞清楚怎么阅读本书，先来看看本书的内容到底是怎么来的。</p><p>书中的内容是从我这几年的公众号文章、视频课程以及项目实践当中逐渐积累下来的：</p><ul><li><p>看过我的“<a href="https://coding.imooc.com/class/398.html">新版Kotlin从入门到精通</a>”视频课程第11-13章大概 10 个小时的协程内容的朋友可能会对本书的第3-5章比较熟悉，我在这部分内容主要系统的给出了协程的概念，以及框架封装的思路和方法。<br>  <img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-03-07.png"></p><p>  <strong>“新版Kotlin从入门到精通” 协程相关章节</strong></p></li><li><p>看过我在公众号之前发布的将近 20 篇文章的朋友，可能会对第 6 章以及第 7 章的很小的一部分内容感到熟悉。<br>  <img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-07-16.png"></p><p>  <strong>协程相关历史文章：关注公众号 Kotlin 回复 “协程” 获取</strong></p></li></ul><p>那么我写这本书是不是在重复消费以前的内容呢？</p><p>熟悉我的朋友可能会知道，我可从来不做这样的事儿。因为我也有学习的诉求，我也需要在讲给大家听的过程中保证自己也能学到东西。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-48-56.png"></p><p>而这次编纂成册，其实主要完成了以下两项目标：</p><ol><li><p>概念的清晰化。</p><p> 这一点其实也是为了应对协程概念混乱的现状的。大家讨论来讨论去，还是搞不明白究竟什么是协程，好用不容易从理论的角度摸着点儿门道，一看 Kotlin 代码里面既有 startCoroutine ，也有 launch，于是就又蒙了：它们到底哪个启动的才是协程？</p><p> 为了解决这个问题，我在本书的前几章给协程在不同应用层面的 API 下了个定义，前面的叫简单协程，后面的叫复合协程，方便我们在行文和讨论过程中区分开来；也总结了协程框架封装的套路，一方面希望大家看到官方框架时不要感到害怕，另一方面也能够在实践中令读者有能力自己做一些扩展。</p></li><li><p>知识的体系化。</p><p> 除了搞不清楚什么是协程之外，大家最爱问题的问题就是协程有什么用，而且很多时候一些已经对协程掌握得还不错的开发者，当你问到他协程什么情况下能解决异步问题，或者为什么有时候协程并不轻量这些问题的时候，一样大概率讲不清楚。原因在哪儿？多数是因为对于某些问题的应用场景不熟悉，既没有搞清楚问题本身，也没有搞清楚问题的解决方案。</p><p> 为了解决这个问题，我在本书的第 7、8 两章当中从问题本身出发，对比多年的解决方案的演进过程，进而阐述 Kotlin 协程的作用。搞清楚来龙去脉，自然很多问题也就迎刃而解了。</p></li></ol><h3 id="本书的目标读者"><a href="#本书的目标读者" class="headerlink" title="本书的目标读者"></a>本书的目标读者</h3><p>本书的目标读者是真正希望能深入理解 Kotlin 协程的开发者。如果你只是想要速成，那本书真的会让你失望。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D20B1C.gif" alt="img"></p><p>话说到这儿，可能多数开发者阅读本书的想法都是要速成 Kotlin 协程，那我应该照着这个思路去安排书的内容。没错，从商业化的角度，是应该这样，我又何尝不想写一本爆款，好好搏一把名声呢？</p><p>但事儿可以这么想，但却不能这么做。我们要尊重客观事实，速成 Kotlin 协程这件事儿，真的不靠谱，因为你可能搞不清楚挂起函数到底是怎么挂起的，你也搞不清楚调度器到底是怎么调度协程的，你甚至还会在协程内部随意访问外部变量，以至于出了问题也根本不知道如何下手去解决。</p><p>而这些问题的细节，只有我们试图“深入理解 Kotlin 协程”时，才能彻底明白。</p><p>至于只是希望把协程当做切换线程的工具的朋友，你确实没必要阅读本书。非要跟我杠协程只是一个线程框架或者协程只是线程的封装的朋友，建议你把我拉黑。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D4A08C.gif" alt="img"></p><p>另外，由于 Kotlin 协程算是 Kotlin 的高级特性了，对于 Kotlin 的基础语法要求比较高，这其中对于 Kotlin 的函数基础的要求尤为突出，因此读者需要有扎实的 Kotlin 语言基础。</p><h3 id="本书的内容安排"><a href="#本书的内容安排" class="headerlink" title="本书的内容安排"></a>本书的内容安排</h3><h4 id="第一章：搞清楚异步程序设计"><a href="#第一章：搞清楚异步程序设计" class="headerlink" title="第一章：搞清楚异步程序设计"></a>第一章：搞清楚异步程序设计</h4><ul><li>内容难度：※</li><li>阅读方式：掌握</li></ul><p>想要搞清楚协程，必须先搞清楚异步。</p><p>之前有人在我的博客下跟我争论什么是异步，提到异步必然切线程的事儿，这恐怕也是令大多数开发者感到困惑的地方。</p><p>不切线程怎么实现异步？不理解这一点，说到底，还是对于程序设计了解得太少了。如果跳出我们平常习惯的领域，多看一看其他领域的程序设计，其实很容易想到：写 JavaScript 程序的开发者可能都没怎么接触过线程，但这也不妨碍人家使用异步 API。再说一个大家熟悉的，基于 Android Handler 的 post 方法，需要切线程吗？</p><p>本书的开篇就在讲什么是异步，想要搞清楚异步程序设计，先仔细阅读这一章。这一章提到的异步程序设计思路，也正与后面第五章剖析官方协程框架设计思路相对应。</p><h4 id="第二章：搞清楚协程的概念"><a href="#第二章：搞清楚协程的概念" class="headerlink" title="第二章：搞清楚协程的概念"></a>第二章：搞清楚协程的概念</h4><ul><li>内容难度：※※</li><li>阅读方式：了解</li></ul><p>网上关于协程的讨论是非常多的。我们在试图搞清楚 Kotlin 协程是什么的时候也难免会看到有人在讨论 Lua 协程是什么，async/await 是什么，Go routine 又是什么。大家都不一样，怎么都叫协程？这就是第二章讲的内容。</p><p>这块儿有人也提出质疑：我只想学 Kotlin 协程，你为什么让我看什么 Lua、JavaScript？</p><p>实际上，这一章的内容不需要读者对其他语言有深入的了解，我把它们的例子写出来也只是为了让大家找一下协程的感觉，仅此而已。当然，作为开发者，适当的多了解一些编程语言，对于深入认识自己所专注的领域是有帮助的。</p><h4 id="第三、四章：搞清楚-Kotlin-协程的基础"><a href="#第三、四章：搞清楚-Kotlin-协程的基础" class="headerlink" title="第三、四章：搞清楚 Kotlin 协程的基础"></a>第三、四章：搞清楚 Kotlin 协程的基础</h4><ul><li>内容难度：第三章 ※※※ 第四章 ※※※※</li><li>阅读方式：第三章的内容需要理解，第四章仅供参考可跳过</li></ul><p>Kotlin 协程难就难在它的各种细节都被暴露了出来。相比之下无论是 Go routine、还是 JavaScript 的 async/await，内部实现细节都没有暴露，对于这些语言的协程设计，开发者确实可以实现“速成”。</p><p>那这么说 Kotlin 协程的设计很失败啊。</p><p>其实不然。</p><p>协程的设计实现往往需要运行时的支持，也正是如此，Go routine 不需要暴露它的调度细节，这些工作全部由 Go 运行时来搞定；JavaScript 的 async/await 也不用，因为 JavaScript 的环境绝大多数都是单线程的，运行时也提供了足够多的异步 API 供我们调用，开发者根本不用关心什么线程调度，什么异常处理的细节。</p><p>Kotlin 为什么不能在运行时提供此类支持呢？因为多数情况下，Kotlin 没有自己的运行时。Kotlin/JVM 运行在 JVM 上（或者 Android VM 上），Kotlin/JS 运行在 JavaScript 的环境当中（可能是浏览器，也可能是 Node.js 等等），没有自己的运行时的结果就是 Kotlin 协程只能在编译时加入“魔法”。它不能保证运行时能够自动处理调度；也不能保证运行时就只有一个线程；面对 JVM，它还必须能够灵活的切换线程； JVM 上的 API 多数都是阻塞的，它还要能够方便的实现阻塞与非阻塞的转换。所以它能简单吗？它不能。</p><p>还有一个原因，Kotlin 要面向多平台来实现自己的协程。当它运行在 JVM 上时，Java 开发者可能用它来做高并发的服务，类似于 Go routine 那样的“轻量级线程”的使用场景更多；Android 开发者可能用它来做异步 UI，类似于 JavaScript 的 async/await 的场景更多。当它运行在 JavaScript 环境中时，还有能与 JavaScript 基于 Promise 的 async/await 无缝衔接。而当它运行在 Native 环境中时，Kotlin 官方现在似乎还没有完全确定最终能够实现成什么样。</p><p>没有自己的运行时，还有面对这么多的目标场景，Kotlin 协程的设计能够设计成这样，也实属不易。每次想起这个事儿我都不得不感叹现在身为 Kotlin Leader 的 Roman 在设计协程时面临了怎样的挑战，不过大佬毕竟是大佬：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-10-11-39.png"></p><p>讲到这儿，我想说的是，一定要踏踏实实地搞清楚第三章的内容，这是整个 Kotlin 协程的基础。第四章是运用第三章的知识在落地实践，我在这一章也会摸索出一套构建协程框架的思路，这个思路将在第五章得到进一步实践。</p><p>对了，稍微提一句的是，我在 Kotlin 教学过程中发现多数开发者搞不清楚 Receiver，对于 Kotlin 的函数的认知也比较浅，这会成为 Kotlin 协程学习的严重阻碍。再次强调，想要学好 Kotlin 协程，Kotlin 的基本功要扎实。</p><h4 id="第五、六章：搞清楚官方的协程框架"><a href="#第五、六章：搞清楚官方的协程框架" class="headerlink" title="第五、六章：搞清楚官方的协程框架"></a>第五、六章：搞清楚官方的协程框架</h4><ul><li>内容难度：第五章 ※※※※※ 第六章 ※※※</li><li>阅读方式：第五章配合源码了解即可，第六章掌握框架的使用方法</li></ul><p>官方的协程框架实际上也是分了两个层次的。核心层就是我在第五章手把手带着大家实现的 <a href="https://github.com/enbandari/CoroutineLite">CoroutineLite</a> 所涉及的部分，包括调度器、异常处理、取消响应、作用域等内容，这部分内容官方没有特别多的文档，有些地方的设计也比较反直觉，所以如果搞不清楚其本质，很难在实际应用中做到心中有数。</p><p>我也是在对官方框架不断地调试过程中逐渐分析总结，才形成了第五章的内容基础。为了降低对官方框架的理解难度，我从零开始一步一步介绍了 <a href="https://github.com/enbandari/CoroutineLite">CoroutineLite</a> 的设计和实现过程，框架代码整体也就几百行，稍微花点儿时间就能够达到掌握官方框架实现细节的水平，可以算是一条捷径了。</p><p>当然，第五章真的是难，但难点本质上并不是协程的设计思路本身，而是对很多 Kotlin 基础语法特别是函数特性的综合运用，以及 对 Java 并发包当中的原子类型的运用，读者需要有扎实的 Kotlin 语言功底和 Java 并发编程基础才能很好的理解这一章。</p><p>那么问题来了，这一章算是劝退吗？</p><p>显然不是，知识本来就是递进的，基础不牢地动山摇，该补充什么背景知识，那就抓紧时间去补充。我已经知道有不少读者把这一章吃透了，甚至有朋友看过之后直呼过瘾，这说明只要有一定的基础，这一章就不是那么的难。</p><p>第六章就比较中规中矩了，是对官方协程框架的应用层做的一些介绍，以用法为主，因此难度相对低一些。稍微提一句，协程框架的应用层（包括 Channel、Flow 等等）还在不断演进，因此本书的部分内容（例如 Flow，本书编写时还在实验阶段）可能与最新版本有些许出入，但这并不会影响你掌握官方的协程框架，因为前面的内容已经足够支撑你通过阅读官方 API 来了解其用法了。</p><h4 id="第七、八章：搞清楚协程的使用场景"><a href="#第七、八章：搞清楚协程的使用场景" class="headerlink" title="第七、八章：搞清楚协程的使用场景"></a>第七、八章：搞清楚协程的使用场景</h4><ul><li>内容难度：※※※</li><li>阅读方式：Android 开发者重点看第七章，Java 开发者重点看第八章</li></ul><p>这部分内容主要就 Android 应用开发和 Java Web 服务应用开发过程当中遇到的异步和并发问题展开介绍。通过对比以往的 API 和协程风格的 API 之间的使用差异，以使读者充分了解协程的应用场景。</p><p>实际上，这部分内容也对于协程在什么情况下表现得“轻量”以及怎么解决异步问题结合实际问题给出了答案，是理论联系实际的一部分内容。</p><h4 id="第九章：搞清楚协程对多平台的支持情况"><a href="#第九章：搞清楚协程对多平台的支持情况" class="headerlink" title="第九章：搞清楚协程对多平台的支持情况"></a>第九章：搞清楚协程对多平台的支持情况</h4><ul><li>内容难度：※※※※</li><li>阅读方式：了解即可</li></ul><p>多平台作为 Kotlin 重要特性，Kotlin 协程对多平台的支持自然是对 Kotlin 协程进行系统化剖析时不可或缺的组成部分。但由于多平台特性仍处于快速演进的阶段，因此这部分内容很可能会在不久的将来“过时”。不过这并不影响大家通过阅读本章来理解 Kotlin 协程在多平台支持过程中的努力和方向。</p><p>当然，这部分内容主要面向有跨平台需要的开发者，暂时没有多平台应用需要的读者，可以跳过或者简单浏览本章的内容。</p><h2 id="本书的一些资源"><a href="#本书的一些资源" class="headerlink" title="本书的一些资源"></a>本书的一些资源</h2><h3 id="本书勘误"><a href="#本书勘误" class="headerlink" title="本书勘误"></a>本书勘误</h3><p>从书出版的一开始，我一直在维护勘误表，也不能算是对这本书不管不顾吧。(▼ヘ▼#)</p><p>这本书是在 2020 年 6 月出版的。截止目前经读者反馈，第一版有共计 9 处问题，还好，问题不大，很容易就能看出来：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-29-07-19-23.png"></p><p><strong>《深入理解 Kotlin 协程》勘误表</strong></p><p>这里也要感谢为本书勘误的读者。大家看，9 个问题有 7 个是一位 ID 叫 <strong>llt</strong> 的兄弟提出来的，他现在也是我们下面提到的 QQ 群里面目前为止唯一的管理员。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D8426B.gif" alt="img"></p><p>本书的勘误我一直在<a href="https://www.bennyhuo.com/project/kotlin-coroutines.html">我的博客当中关于本书的页面</a>上有更新。</p><p>哦对了，这些问题在 2020 年 10 月印刷的版本里面已经看不到了，所以如果你发现书上的内容居然是对的，也不要感觉惊讶。(^_−)☆</p><h3 id="本书交流"><a href="#本书交流" class="headerlink" title="本书交流"></a>本书交流</h3><p>我专门建了个 QQ 群用来方便大家交流，目前已经有一些读者加了进来，群号：612797230。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-15-45.png"></p><p><strong>使用手机 QQ 扫描加群</strong></p><p>读书的目的是学到东西，与其在线上发泄情绪，不如跟我说说你到底遇到了什么问题。</p><p>另外，没有微信群，因为微信群的二维码只有7天有效期，管理起来太麻烦。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/06188B73.png" alt="img"></p><h3 id="本书源码"><a href="#本书源码" class="headerlink" title="本书源码"></a>本书源码</h3><p>本书源码在 GitHub 上完整的给了出来：<a href="https://github.com/enbandari/DiveIntoKotlinCoroutines-Sources">DiveIntoKotlinCoroutines-Sources</a>（没想到已经 100 多个小星星了(～￣▽￣)～ ）</p><p>实际上如果你基础不错，自己研究一下 <a href="https://github.com/enbandari/CoroutineLite">CoroutineLite</a> 这个项目一样可以对协程有深入的了解。之前看到有群友说这本书最有价值的部分应该就是 CoroutineLite 这个框架了 —— 是不是最有价值，不同人有不同的看法，但目前还没有看到第二个有类似功能的框架供大家参考。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>感谢每一位支持和帮助我的朋友，也希望《深入理解 Kotlin 协程》这本书能够帮助到大家。</p><p>最后，祝大家春节快乐~</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;趁着面试官还没看，赶紧深入了解一下~~ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="协程" scheme="https://www.bennyhuo.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 1.4.30-RC 密封接口来啦！</title>
    <link href="https://www.bennyhuo.com/2021/01/23/kotlin-sealed-interface/"/>
    <id>https://www.bennyhuo.com/2021/01/23/kotlin-sealed-interface/</id>
    <published>2021-01-22T16:00:00.000Z</published>
    <updated>2021-01-25T13:07:27.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>密封类是 Kotlin 的老成员了，现在也可以有密封接口了。 </p></blockquote><a id="more"></a><p>前两天看到 Kotlin 1.4.30-RC 的邮件，主要添加了对 Java 15 的支持，也支持了密封接口。要知道，Java 15 当中就有个重要的特性叫密封接口，这会难道是 Kotlin 被 Java 倒逼着出了个新特性？</p><h3 id="Java-的密封接口"><a href="#Java-的密封接口" class="headerlink" title="Java 的密封接口"></a>Java 的密封接口</h3><p>我们先来看看 Java 的密封接口是怎么回事吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sealed <span class="class"><span class="keyword">interface</span> <span class="title">PlayerState</span> <span class="title">permits</span> <span class="title">Idle</span>, <span class="title">Playing</span>, <span class="title">Error</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Idle</span> <span class="keyword">implements</span> <span class="title">PlayerState</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Playing</span> <span class="keyword">implements</span> <span class="title">PlayerState</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span> <span class="keyword">implements</span> <span class="title">PlayerState</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>功能上，与 Kotlin 的密封类类似，都是限制子类个数的，所以这一点儿不应当有什么理解上的困难。</p><p>语法上，Java 秉持着它一贯的“啰嗦”的特点，在密封接口定义时，还要明确写出 <code>permits</code>，告诉大家这个接口只能够被以下几个类实现。你会不会感觉很奇怪，看一下后面这几行不就知道了，为什么还有加一个 permits？因为我们编写 Java 代码的时候，通常一个类就是一个文件，因此 Java 的密封接口不会去限制只能在文件内部定义实现类（就像 Kotlin 那样），因此 permits 是必须的。</p><p>我们还注意到，PlayerState 的子类前面都加了个 final 关键字，意思就是不能被继承。这一点与 Kotlin 的密封类语法类似，Kotlin 当中类型默认就是 final 的，大家可能都没有注意过这个限制。</p><p>说到这里，如果大家想要体验 Java 的密封接口的特性，需要给编译器添加 <code>--enable-preview</code> 参数，具体在 Gradle 当中可参考以下配置：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compileJava &#123;</span><br><span class="line">    it.<span class="keyword">options</span>.compilerArgs.add(<span class="string">&#x27;--enable-preview&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 Kotlin 与 Java 15 互调用，在 Kotlin 1.4.30-RC 版本当中需要添加下面的参数：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compileKotlin &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        languageVersion = <span class="string">&quot;1.5&quot;</span> <span class="comment">// Kotlin 1.5 experimental</span></span><br><span class="line">        freeCompilerArgs += <span class="string">&quot;-Xjvm-enable-preview&quot;</span> <span class="comment">// for java preview </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="密封类型子类的子类"><a href="#密封类型子类的子类" class="headerlink" title="密封类型子类的子类"></a>密封类型子类的子类</h3><p>那么灵魂拷问来了，不加 final 行不行？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-09-51-41.png"></p><p>三选一，</p><p>第一种：sealed，就是你自己也称为密封类，这样子类还是受限制的</p><p>第二种： non-sealed，就是明确告诉大家，你不是密封类，而且不是 final，这意味着 Playing 这个类型是可以被其他类型继承的。</p><p>啊？？那这样子类不就不受限制了吗？</p><p>对呀，子类是不受限制了，但直接子类的个数还是有限的。也就是说密封类实际上限制的是直接子类的个数，这一点之前我们很少提到。</p><p>第三种，final，这就比较好理解了，直接把子类的路堵死完事儿。</p><p>这么看来，Java 除了支持密封接口以外，也是直接密封类的，而且还能允许密封接口或者密封类的 non-sealed 子类有其他子类，看上去是不是比 Kotlin 高级？</p><p>非也非也！</p><p>Kotlin 的密封类的子类，也可以有子类的！列位请看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Song</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Options</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerState</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(<span class="keyword">val</span> t: Throwable): PlayerState()</span><br><span class="line">    <span class="keyword">object</span> Idle: PlayerState()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Playing</span></span>(<span class="keyword">val</span> song: Song): PlayerState()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PlayingWithOptions</span></span>(song: Song, <span class="keyword">val</span> options: Options): Playing(song)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Playing 居然可以有个子类，叫做 PlayingWithOptions！这样搞，是不是密封类的特性就被破坏了呀？</p><p>当然不是，密封类的子类除了 Error、Idle 以外，仍然只有一种可能，那就是 Playing。这很好理解，对吧。</p><h3 id="Kotlin-的密封接口"><a href="#Kotlin-的密封接口" class="headerlink" title="Kotlin 的密封接口"></a>Kotlin 的密封接口</h3><p>好了，接下来我们终于要抬出 1.4.30-RC 当中新增的 Kotlin 的密封接口了，前面的 PlayerState 里面什么都没有，显然我们把它定义成接口更好：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlayerState</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(<span class="keyword">val</span> t: Throwable): PlayerState</span><br><span class="line">    <span class="keyword">object</span> Idle: PlayerState</span><br><span class="line">    <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Playing</span></span>(<span class="keyword">val</span> song: Song): PlayerState</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PlayingWithOptions</span></span>(song: Song, <span class="keyword">val</span> options: Options): Playing(song)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了配合密封接口的新特性，IDE 在创建 Kotlin 类型的时候也多了个选择：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-10-12-23.png"></p><p>而且你会神奇的发现，内联类跟密封接口可以一起使用了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlayerState</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意这里！</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(<span class="keyword">val</span> t: Throwable): PlayerState</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在上一篇文章里面刚刚说到这事儿，虽然可以这么写，这样做意义并不大。因为密封类的子类在使用的过程中总是会声明成父类，这个过程总是会出现装箱：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> playerState: PlayerState = Idle</span><br><span class="line">...</span><br><span class="line">playerState = Error(...) <span class="comment">// 装箱</span></span><br></pre></td></tr></table></figure><p>所以，我们几乎可以认为，内联类在密封类当中使用基本上都是错误的用法。</p><p>稍微提一句，官方在 <a href="https://youtrack.jetbrains.com/issue/KT-42434">KT-42434 Release inline classes as Stable, secure Valhalla compatibility</a> 当中明确了 inline class 将在 1.4.30 进入 Beta 阶段，在 1.5.0 进入稳定状态；不仅如此，为了配合 <a href="https://openjdk.java.net/projects/valhalla/">Valhalla</a> 的 Value Type 特性，后续内联类计划被改名叫做 value class，这当然都是后面的事儿了，我们后面有机会再聊。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;密封类是 Kotlin 的老成员了，现在也可以有密封接口了。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="news" scheme="https://www.bennyhuo.com/tags/news/"/>
    
      <category term="sealed interface" scheme="https://www.bennyhuo.com/tags/sealed-interface/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 1.4.30-M1 增强的内联类是个什么东西？</title>
    <link href="https://www.bennyhuo.com/2021/01/18/kotlin-inline-class-improvements/"/>
    <id>https://www.bennyhuo.com/2021/01/18/kotlin-inline-class-improvements/</id>
    <published>2021-01-17T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.997Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>内联类从 1.3 推出，一直处于实验状态。 </p></blockquote><a id="more"></a><p>内联类 inline class，是从 Kotlin 1.3 开始加入的实验特性，计划 1.4.30 进入 Beta 状态（看来 1.5.0 要转正了？）。</p><p>内联类要解决的问题呢，其实也与以往我们接触到的内联函数类似，大体思路就是提供某种语法，提升代码编写体验和效率，同时又借助编译器的优化手段来减少这样做的成本。</p><h2 id="1-从内联函数说起"><a href="#1-从内联函数说起" class="headerlink" title="1. 从内联函数说起"></a>1. 从内联函数说起</h2><p>我们先以各类编程语言当中广泛存在的内联函数为例来说明内联的作用。</p><p>函数调用时有成本的，这涉及到参数的传递，结果的返回，调用栈的维护等一系列工作。因此，对于一些比较小的函数，可以在编译时使用函数的内容替换函数的调用，以减少函数的调用层次，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span>(a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(max(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main 函数当中调用 max 函数，从代码编写的角度来看，使用函数 max 让我们的代码意图更加明显，也使得求最大值的逻辑更容易复用，因此在日常的开发当中我们也一直鼓励大家这样做。</p><p>不过，这样的结果就是一个简单的比较大小的事儿变成了一次函数的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function"> L0</span></span><br><span class="line"><span class="function">  LINENUMBER 6 L0</span></span><br><span class="line"><span class="function">  ICONST_1</span></span><br><span class="line"><span class="function">  ICONST_2</span></span><br><span class="line"><span class="function">  INVOKESTATIC com/bennyhuo/kotlin/InlineFunctionKt.<span class="title">max</span> <span class="params">(II)</span>I</span></span><br><span class="line"><span class="function">  INVOKESTATIC kotlin/io/ConsoleKt.<span class="title">println</span> <span class="params">(I)</span>V</span></span><br></pre></td></tr></table></figure><p>如果我们把 max 声明成内联函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span>(a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>结果就不一样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function"> L0</span></span><br><span class="line"><span class="function">  LINENUMBER 6 L0</span></span><br><span class="line"><span class="function">  ICONST_1</span></span><br><span class="line"><span class="function">  ISTORE 0</span></span><br><span class="line"><span class="function">  ICONST_2</span></span><br><span class="line"><span class="function">  ISTORE 1</span></span><br><span class="line"><span class="function"> L1</span></span><br><span class="line"><span class="function">  ICONST_0</span></span><br><span class="line"><span class="function">  ISTORE 2</span></span><br><span class="line"><span class="function"> L2</span></span><br><span class="line"><span class="function">  LINENUMBER 8 L2</span></span><br><span class="line"><span class="function"> L3</span></span><br><span class="line"><span class="function">  ILOAD 1</span></span><br><span class="line"><span class="function"> L4</span></span><br><span class="line"><span class="function"> L5</span></span><br><span class="line"><span class="function">  ISTORE 0</span></span><br><span class="line"><span class="function"> L6</span></span><br><span class="line"><span class="function">  LINENUMBER 6 L6</span></span><br><span class="line"><span class="function"> L7</span></span><br><span class="line"><span class="function">  ICONST_0</span></span><br><span class="line"><span class="function">  ISTORE 1</span></span><br><span class="line"><span class="function"> L8</span></span><br><span class="line"><span class="function">  GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class="line">  ILOAD <span class="number">0</span></span><br><span class="line">  INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br></pre></td></tr></table></figure><p>这样我们就已经看不到 max 函数的调用了。</p><p>当然，对于这样的小函数，编译器和运行时已经足够聪明到可以自己自动做优化了，内联函数在 Kotlin 当中最大的作用其实是高阶函数的内联，我们就以最为常见的 forEach 为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;out T&gt;</span>.<span class="title">forEach</span><span class="params">(action: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) action(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forEach 函数被声明为 inline，这说明它是一个内联函数。按照我们的前面对内联函数的理解，下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).forEach &#123;</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后大致相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (element <span class="keyword">in</span> arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) &#123;</span><br><span class="line">    &#123; it: <span class="built_in">Int</span> -&gt; println(it) &#125;(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 forEach 自身的调用就被消除掉了。不过，这还不够，因为我们看到 <code>&#123; it: Int -&gt; println(it) &#125;(element)</code> 其实就是前面 forEach 定义当中的 <code>action(element)</code>，这也是一个函数调用，也是有成本的。更为甚者，每一次循环当中都会创建一个函数对象（Lambda）并且调用它，这样一来，还会有频繁创建对象的开销。</p><p>所以，Kotlin 当中的内联函数也会同时对函数类型的参数进行内联，因此前面的调用编译之后实际上相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (element <span class="keyword">in</span> arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) &#123;</span><br><span class="line">    println(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且这样也更符合我们的直觉。</p><p>总结一下，内联函数可以减少函数对象的创建和函数调用的次数。</p><blockquote><p>提问：所以你知道为什么 IDE 会对 max 这样的非高阶函数的内联发出警告了吗？</p></blockquote><h2 id="2-什么是内联类"><a href="#2-什么是内联类" class="headerlink" title="2. 什么是内联类"></a>2. 什么是内联类</h2><p>内联函数可以减少对象的创建，内联类实际上也是如此。</p><p>内联类实际上就是对其他类型的一个包装，就像内联函数其实是对一段代码的包装一样，在编译的时候对于内联类对象的访问都会被编译器拆掉包装而得到内部真实的类型。因此，内联类一定有且只有一个属性，而且这个属性还不能被修改。</p><p>内联类的语法其实也简单，与 Kotlin 当中其他的枚举类、密封类、数据类的定义方式类似，在 class 前面加一个 inline 即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerState</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>使用时大多数情况下就像普通类型那样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> idleState = PlayerState(<span class="number">0</span>)</span><br><span class="line">println(idleState.value)</span><br></pre></td></tr></table></figure><p>虽然这里创建了一个 PlayerState 的实例 idleState，我们也对这个实例的成员 value 进行了访问，但编译完之后这段代码大致相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> value = <span class="number">0</span></span><br><span class="line">println(value)</span><br></pre></td></tr></table></figure><p>因为 PlayerState 这个类型的实例被内联，结果就剩下 value 本身了。</p><p>我们当然也可以给内联类定义其他成员，这其中包括无状态的属性（没有 backing field）和函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerState</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isIdle</span><br><span class="line">        <span class="keyword">get</span>() = value == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isPlaying</span><span class="params">()</span></span> = value == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问这些成员的时候，编译器也并不会将内联类的实例创建出来，而是转换成静态方法调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> idleState = PlayerState(<span class="number">0</span>)</span><br><span class="line">println(idleState.isIdle)</span><br><span class="line">println(idleState.isPlaying())</span><br></pre></td></tr></table></figure><p>因而就相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> value = <span class="number">0</span></span><br><span class="line">println(PlayerState.isIdle-impl(value))</span><br><span class="line">println(PlayerState.isPlaying-impl(value))</span><br></pre></td></tr></table></figure><p><code>isIdle-impl</code> 和 <code>isPlaying-impl</code> 这两个函数是编译器自动为 PlayerState 生成的静态方法，它们的方法名中加了 <code>-</code> 这样的非法字符，这意味着这些方法对于 Java 来讲是不友好的，换句话讲，内联类不能与 Java 的语法兼容。</p><p>我们再看一个稍微复杂的情形：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> idleState = PlayerState(<span class="number">0</span>)</span><br><span class="line">println(idleState)</span><br></pre></td></tr></table></figure><p>我们直接将这个内联类的实例传给 println，这下编译器会怎么办呢？编译器只会在尽可能需要的情况下完成内联，但对于这种强制需要内联类实例的情况，也是无法绕过的，因此在这里会发生一次“装箱”操作，把内联类实例真正创建出来，大致相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> value = <span class="number">0</span></span><br><span class="line">println(PlayerState(value))</span><br></pre></td></tr></table></figure><p>简单总结一下就是：</p><ol><li>在一定范围内，内联类可以像普通类那样使用。言外之意，其实内联类也有挺多限制的，这个我们待会儿再聊。</li><li>编译之后，编译器会尽可能地将内联类的实例替换成其成员，减少对象的创建。</li></ol><h2 id="3-内联类有什么限制？"><a href="#3-内联类有什么限制？" class="headerlink" title="3. 内联类有什么限制？"></a>3. 内联类有什么限制？</h2><p>通过前面对于内联类概念的讨论，我们已经知道内联类</p><ol><li>有且仅有一个不可变的属性</li><li>可以定义其他属性，但不能有状态</li></ol><p>实际上，由于内联类存在状态限制，因此内联类也不能继承其他类型，但这不会影响它实现接口，例如标准库当中的无符号整型 UInt 定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">UInt</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(<span class="keyword">internal</span> <span class="keyword">val</span> <span class="keyword">data</span>: <span class="built_in">Int</span>) : Comparable&lt;UInt&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">UInt</span>)</span></span>: <span class="built_in">Int</span> = uintCompare(<span class="keyword">this</span>.<span class="keyword">data</span>, other.<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子里面其实还有惊喜，那就是 UInt 的构造器是 internal 的，如果你想要一样画葫芦在自己的代码当中这样写，怕是要看一下编译器的脸色了：</p><p><strong>以下为 Kotlin 1.4.20 当中的效果</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-21-50.png"></p><p>在 Kotlin 1.4.30 以前，内联类的构造器必须是 public 的，这意味着在过去我们不能通过内联类来完成对某一种特定类型的部分值的包装：因为外部一样可以创造出来新的内联类实例。</p><p>不过，1.4.30-M1 当中已经解除了这一限制，详情参见：<strong>KT-28056 Consider supporting non-public primary constructors for inline classes</strong>(<a href="https://youtrack.jetbrains.com/issue/KT-28056)%EF%BC%8C%E5%9B%A0%E8%80%8C%E6%88%91%E4%BB%AC%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%86%85%E8%81%94%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%A3%B0%E6%98%8E%E4%B8%BA">https://youtrack.jetbrains.com/issue/KT-28056)，因而我们现在可以将内联类的构造器声明为</a> internal 或者 private，以防止外部随意创建新实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerState</span></span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> error = PlayerState(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> idle = PlayerState(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> playing = PlayerState(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，PlayerState 的实例就仅限于 error、idle、playing 这几个了。</p><p>除了前面限制实例的场景，有些情况下我们其实只是希望通过内联类提供一些运行时的校验，这就需要我们在 init 块当中来完成这样的工作了，但内联类的 init 块在 1.4.30 以前也是禁止的：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-43-05.png"></p><p>1.4.30-M1 开始解除了这一限制，详情参见：<strong>KT-28055 Consider supporting init blocks inside inline classes</strong>(<a href="https://youtrack.jetbrains.com/issue/KT-28055)%E3%80%82%E4%B8%8D%E8%BF%87%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8C%E8%99%BD%E7%84%B6">https://youtrack.jetbrains.com/issue/KT-28055)。不过需要注意的是，虽然</a> init 块当中的逻辑只在运行时有效，但这样的特性可以让被包装类型的值与它的条件在代码当中紧密结合起来，提供更良好的一致性。</p><h2 id="4-内联类有什么应用场景？"><a href="#4-内联类有什么应用场景？" class="headerlink" title="4. 内联类有什么应用场景？"></a>4. 内联类有什么应用场景？</h2><p>前面在讨论内联类的概念和限制时，我们已经给出了一些示例，大家也大概能够想到内联类的具体作用。接下来我们再整体梳理一下内联类的应用场景。</p><h3 id="4-1-加强版的类型别名"><a href="#4-1-加强版的类型别名" class="headerlink" title="4.1 加强版的类型别名"></a>4.1 加强版的类型别名</h3><p>内联类最一开始给人的感觉就是“类型别名 Plus”，因为内联类在运行时会被尽可能替换成被包装的类型，这与类型别名看上去很接近。不过，类型别名本质上就是一个别名，它不会导致新类型的产生，而内联类是确实会产生新类型的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">Flag0</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">typealias</span> Flag1 = <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(Flag0::<span class="class"><span class="keyword">class</span> == <span class="title">Int</span>:<span class="type">:class) // false</span></span></span><br><span class="line">    println(Flag1::<span class="class"><span class="keyword">class</span> == <span class="title">Int</span>:<span class="type">:class) // true</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> flag0 = Flag0(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> flag1 = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-替代枚举类"><a href="#4-2-替代枚举类" class="headerlink" title="4.2 替代枚举类"></a>4.2 替代枚举类</h3><p>内联类在 1.4.30 之后可以通过私有化构造函数来限制实例个数，这样也可以达到枚举的目的，我们前面已经给出过例子：</p><p><strong>内联类的写法</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerState</span></span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> error = PlayerState(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> idle = PlayerState(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> playing = PlayerState(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举类的写法</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerState</span> </span>&#123;</span><br><span class="line">    error, idle, playing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以为内联类添加各种函数来增强它的功能，这些函数最终都会被编译成静态方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerState</span></span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> error = PlayerState(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> idle = PlayerState(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> playing = PlayerState(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">values</span><span class="params">()</span></span> = arrayOf(error, idle, playing)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isIdle</span><span class="params">()</span></span> = <span class="keyword">this</span> == idle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然内联类似乎写起来稍微啰嗦了一些，但在内存上却跟直接使用整型几乎是一样的效果。</p><p>话说到这儿，不知道大家是不是能想起 Android 当中的注解 IntDef，结果上都是使用整型来替代枚举，但内联类显然更安全，IntDef 只是一种提示而已。不仅如此，内联类也可以用来包装字符串等其他类型，无疑将是一种更加灵活的手段。</p><p>当然，使用的内联类相较于枚举类有一点点小缺点，那就是使用 when 表达式时必须添加 else 分支：</p><p><strong>使用内联类</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = <span class="keyword">when</span>(state) &#123;</span><br><span class="line">  PlayerState.error -&gt; &#123; ... &#125;</span><br><span class="line">  PlayerState.idle -&gt; &#123; ... &#125;</span><br><span class="line">  PlayerState.playing -&gt; &#123; ... &#125;</span><br><span class="line">  <span class="keyword">else</span> -&gt; &#123; ... &#125; <span class="comment">// 必须，因为编译器无法推断出前面的条件是完备的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而由于编译器能够确定枚举类的实例可数的，因此 else 不再需要了：</p><p><strong>使用枚举类</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = <span class="keyword">when</span>(state) &#123;</span><br><span class="line">  PlayerState.error -&gt; &#123; ... &#125;</span><br><span class="line">  PlayerState.idle -&gt; &#123; ... &#125;</span><br><span class="line">  PlayerState.playing -&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-替代密封类"><a href="#4-3-替代密封类" class="headerlink" title="4.3 替代密封类"></a>4.3 替代密封类</h3><p>密封类用于子类可数的场景，枚举类则用于实例可数的场景。</p><p>我们前面给出的 PlayerState 其实不够完善，例如状态为 error 时，也应该同时附带错误信息；状态为 playing 时也应该同时有歌曲信息。显然当前一个简单的整型是做不到这一点的，因此我们很容易能想到用密封类替代枚举：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Song</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerState</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(<span class="keyword">val</span> t: Throwable): PlayerState()</span><br><span class="line"><span class="keyword">object</span> Idle: PlayerState()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Playing</span></span>(<span class="keyword">val</span> song: Song): PlayerState()</span><br></pre></td></tr></table></figure><p>如果应用场景对于内存不敏感，这样写实际上一点儿问题都没有，而且代码的可读性和可维护性都会比状态值与其相对应的异常和播放信息独立存储要强得多。</p><p>这里的 Error、Playing 这两个类型其实就是包装了另外的两个类型 Throwable 和 Song 而已，是不是我们可以把它们定义为内联类呢？直接定义肯定是不行的，因为 PlayerState 是个密封类，密封类本质上也是一个类，我们前面提到过内联类有不能继承类型的限制，当时给出的理由是内联类不能包含其他状态。这样看来，如果父类当中足够简单，不包含状态，是不是将来有希望支持继承呢？</p><p>其实问题不只是状态那么简单，还有多态引发的装箱和拆箱的问题。因为一旦涉及到父类，内联类很多时候都无法实现内联，我们假定下面的写法是合法的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerState</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(<span class="keyword">val</span> t: Throwable): PlayerState()</span><br><span class="line"><span class="keyword">object</span> Idle: PlayerState()</span><br><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">Playing</span></span>(<span class="keyword">val</span> song: Song): PlayerState()</span><br></pre></td></tr></table></figure><p>那么：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> state: PlayerState = Idle</span><br><span class="line">...</span><br><span class="line">state = Error(IOExeption(<span class="string">&quot;...&quot;</span>)) <span class="comment">// 必须装箱，无法内联</span></span><br><span class="line">...</span><br><span class="line">state = Playing(Song(...)) <span class="comment">// 必须装箱，无法内联</span></span><br></pre></td></tr></table></figure><p>这里内联机制就失效了，因为我们无法将 Song 的实例直接赋值给 state，IOException 的实例也是如此。</p><p>不过，作为变通，其实我们也可以这样改写上面的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerState</span></span>(<span class="keyword">val</span> state: Any?) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        require(state == <span class="literal">null</span> || state <span class="keyword">is</span> Throwable || state <span class="keyword">is</span> Song)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isIdle</span><span class="params">()</span></span> = state == <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isError</span><span class="params">()</span></span> = state <span class="keyword">is</span> Throwable</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isPlaying</span><span class="params">()</span></span> = state <span class="keyword">is</span> Song</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写就与标准库当中大名鼎鼎的 Result 类有异曲同工之妙了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="type">out T</span>&gt; <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> value: Any?</span><br><span class="line">) : Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> isSuccess: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = value !<span class="keyword">is</span> Failure</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> isFailure: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = value <span class="keyword">is</span> Failure</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本文我们简单介绍了一下内联类的作用，实现细节，以及使用场景。简单总结如下：</p><ol><li>内联类是对其他类实例的包装</li><li>内联类在编译时会尽可能地将实例替换成被包装的对象</li><li>内联类的函数（包括无状态属性）都将被编译成静态函数</li><li>内联类在内存敏感的场景下可以一定程度上替代枚举类、密封类的使用</li><li>内联类不能与 Java 兼容</li></ol><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;内联类从 1.3 推出，一直处于实验状态。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="news" scheme="https://www.bennyhuo.com/tags/news/"/>
    
      <category term="inline class" scheme="https://www.bennyhuo.com/tags/inline-class/"/>
    
  </entry>
  
  <entry>
    <title>要再见了吗，Kotlin Android Extension</title>
    <link href="https://www.bennyhuo.com/2020/11/07/deprecated-kotlin-android-extensions/"/>
    <id>https://www.bennyhuo.com/2020/11/07/deprecated-kotlin-android-extensions/</id>
    <published>2020-11-06T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.984Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>伴随了我们这么多年的 KAE，就这么要离开我们了？ </p></blockquote><a id="more"></a><blockquote><p>本文假定大家了解 KAE（Kotlin Android Extensions）。</p></blockquote><p>前几天看到邮件说 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.4.20-M2">Kotlin 1.4.20-M2</a> 发布了，于是打开看了看更新，发现有个新的用于 Parcelize 的插件。要知道这个功能一直都是集成在 KAE 当中的，那 KAE 呢？</p><p>紧接着我们就可以看到一行：<a href="https://youtrack.jetbrains.com/issue/KT-42121">Deprecate Kotlin Android Extensions compiler plugin</a>。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-05-15-18-42.png"></p><p>说实话，直接废弃，我还是有些意外的。毕竟这个插件在早期为 Kotlin 攻城略地快速吸引 Android 开发者立下了汗马功劳，多年来虽然几乎没有功能更新，但直到现在仍然能够胜任绝大多数场景。</p><p>非要说废弃的理由，确实也能罗列几个出来。为了方便，我们把以 layout 当中 View 的 id 为名而合成的属性简称<strong>合成的属性</strong>。</p><h2 id="销毁之后的空指针"><a href="#销毁之后的空指针" class="headerlink" title="销毁之后的空指针"></a>销毁之后的空指针</h2><p>KAE 是通过在字节码层面添加合成属性来解决 findViewById 的问题的，对于 Activity 和 Fragment 而言，合成的属性背后其实就是一个缓存，这个缓存会在 Activity 的 onDestroy、Fragment 的 onDestroyView 的时候清空。所以每次访问合成的属性，其实只有第一次是调用 findViewById，之后就是一个查缓存的过程。</p><p>这个设计很合理，不过也不免有些危险存在。主要是在 Fragment 当中，如果不小心在 onDestroyView 调用之后访问了这些合成的属性，就会抛一个空指针异常，因为此时缓存已经被清空，而 Fragment 的 View 也被置为 null 了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line"></span><br><span class="line">        textView.text = <span class="string">&quot;Crash!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须说明的一点是，这里抛空指针是合理的，毕竟 Fragment 的 View 的生命周期已经结束了，不过生产实践当中很多时候不是一句“合理”就能解决问题的，我们要的更多的是给老板减少损失。这里如果 textView 仍然可以访问，它不过是修改了一下文字而已，不会有其他副作用，但恰恰因为 KAE 这里严格的遵守了生命周期的变化清空了缓存，却又没有办法阻止开发者继续访问这个合成属性而导致空指针。对比而言，如果我们直接使用 findViewById，情况可能是下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> textView: TextView</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">    textView = view.findViewById(R.id.textView)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroyView()</span><br><span class="line"></span><br><span class="line">    textView.text = <span class="string">&quot;Nothing happened.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码虽然看上去不怎么高明，但它至少不会 Crash。</p><p>Kotlin 一向追求代码的安全性，而且希望在编译时就把代码运行时可能产生的问题尽可能地暴露出来。在很多场景下 Kotlin 确实做得很好，然而 KAE 并没有做到这一点。</p><p>就这个具体的问题而言，倒也很容易解决，现在 Android 当中已经有了足够多的生命周期管理工具，我们能够很好的避免在 Fragment 或者 Activity 的生命周期结束之后还要执行一些相关的操作。例如使用 <code>lifecycleScope.launchWhenResumed&#123; ... &#125;</code> 就能很好的解决这个问题。</p><p>这么看来，这一点似乎不算是 KAE 本身的缺陷。难道是我们要求太高了？不，降低标准的事儿我们是绝不会做的，Kotlin 官方这么多年都没有解决这个问题，快出来挨打 （╬￣皿￣）＝○＃（￣＃）３￣） 。</p><h2 id="张冠李戴"><a href="#张冠李戴" class="headerlink" title="张冠李戴"></a>张冠李戴</h2><p>由于合成的属性只能从 Receiver 的类型上做限制，无法确定对应的 View、Activity、Fragment 当中是否真实存在这个合成的属性对应 id 的 View，因此也存在访问安全性上的隐患。</p><p>例如我当前的 Activity 的 layout 是 activity_main.xml，其中并未定义 id 为 textView 的 View，然而下面的写法却不会在编译时报错：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.fragment_main.*</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">textView.text = <span class="string">&quot;MainActivity&quot;</span></span><br></pre></td></tr></table></figure><p>编译时高高兴兴，运行时就要垂头丧气了，因为 findViewById 一定会返回 null，而合成的属性又不是可空类型。</p><p>这个问题从现有的 KAE 的思路上来看，确实不太好解决，不过从多年的实践来看，这也许都算不上是一个问题，至少我用了快 5 年 KAE，只有偶尔几次写错 id 以外，多数情况下不会出现此类问题。这个问题确实算是一个缺陷，但它的影响实在是有限。</p><h2 id="冲突的-ID"><a href="#冲突的-ID" class="headerlink" title="冲突的 ID"></a>冲突的 ID</h2><p>还有一个问题就是命名空间的问题。合成的属性从导包的形式上来看，像是以 layout 的文件名加上固定的前缀合成的包下的顶级属性，一旦这个包被导入，当前的整个文件当中都可以使用 View、Activity、Fragment 来访问这些合成的属性，这就及其容易导致命名空间冲突的问题。</p><p>为了说明问题，我们创建两个完全相同的 layout，分别命名为 view_tips.xml 和 view_warning.xml，里面只是简单的包含一个 id 为 textView 的 TextView</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &lt;TextView</span><br><span class="line">    android:id=&quot;@+id/textView&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 Activity 或者 Fragment 当中加载这两个 layout：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tipsView = View.inflate(view.context, R.layout.view_tips, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">val</span> warningView = View.inflate(view.context, R.layout.view_warning, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">tipsView.textView.text = <span class="string">&quot;Tips&quot;</span></span><br><span class="line">warningView.textView.text = <span class="string">&quot;Warning&quot;</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">// 添加到对应的父 View 当中</span></span><br></pre></td></tr></table></figure><p>那么这时候我们就要面临一个导包的问题，tipsView 和 warningView 访问的合成属性可能来自于以下两个包：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kotlinx.android.synthetic.main.view_tips.view.*</span><br><span class="line">kotlinx.android.synthetic.main.view_warning.view.*</span><br></pre></td></tr></table></figure><p>我们当然可以把二者一并导入，但问题在于二者即便如此，合成的属性在编译时静态绑定也只能绑定到一个包下面的合成属性下，这样的结果就是我们在 Android Studio 当中点击 warningView.textView 可能会跳转到 view_tips 这个 layout 当中。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20201107095613833.png" alt="image-20201107095613833"></p><p>运行时会不会有问题呢？那倒不至于，因为你始终记住合成属性在运行时会替换成 findViewById 就可以了，只要 findViewById 不出问题，那合成属性自然也不存在问题。从生成的字节码来看，<code>warningView.textView</code> 其实就等价于 <code>warningView.findViewById(R.id.textView)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALOAD 4</span><br><span class="line">DUP</span><br><span class="line">LDC &quot;warningView&quot;</span><br><span class="line">GETSTATIC com&#x2F;bennyhuo&#x2F;helloandroid&#x2F;R$id.textView : I</span><br><span class="line">INVOKEVIRTUAL android&#x2F;view&#x2F;View.findViewById (I)Landroid&#x2F;view&#x2F;View;</span><br><span class="line">CHECKCAST android&#x2F;widget&#x2F;TextView</span><br></pre></td></tr></table></figure><p>所以这个问题本质上影响的是开发体验。出现冲突，一方面可能是类文件太大，包含的 UI 逻辑过多，导致引入过多的 layout，从而产生冲突；另一方面也可能是布局上拆分得太小，一个视图的逻辑类当中不得不引入大量的 layout 导致冲突。通过合理的设计 UI 相关的类，这个问题本身也可以很好的规避。</p><p>另外，如果语言本身支持把包名作为命名空间，在代码访问时直接予以限定，一样可以达到目的。按照现有的语法特性，如果合成的属性是在一个 object 当中定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ViewTipsLayout &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> View.textView: TextView</span><br><span class="line">    <span class="keyword">get</span>() = findViewById(R.id.textView)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> ViewWarningLayout &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> View.textView: TextView</span><br><span class="line">    <span class="keyword">get</span>() = findViewById(R.id.textView)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用的时候如果产生 id 冲突，就可以这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with(ViewTipsLayout) &#123;</span><br><span class="line">  tipsView.textView.text = <span class="string">&quot;Tips&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">with(ViewWarningLayout) &#123;</span><br><span class="line">  warningView.textView.text = <span class="string">&quot;Warning&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这只是我们的设想了。毕竟都要废弃了。</p><h2 id="不支持-Compose"><a href="#不支持-Compose" class="headerlink" title="不支持 Compose"></a>不支持 Compose</h2><p>去年的时候 Anko 就被废弃了，这么想来，KAE 能苟活这么久大概是因为根本不怎么需要维护吧？在这里提 Anko 到不是为了嘲讽，Anko 虽然离开了我们，可 Anko 所倡导的 DSL 布局的精神却留了下来，也就是 Jetpack 当中仍然处于 Alpha 状态（怎么都是 Alpha，难道这么久了还不配有个 Beta 吗）的 Compose 了。</p><p>Anko Layout 不算成功，主要原因还是开发成本的问题。预览要等编译，编译又要很久，这简直了，谁用谁知道。隔壁家的 SwiftUI 就做得很好，说明鱼和熊掌还是可以兼得的，所以我看好 Compose，就看 Android 还能活几年，能不能等到那个时候了（哈哈哈，开玩笑）。</p><p>Kotlin 最近一直在推 KMM，大家都在猜 Kotlin 官方会不会搞一个 React Kotlin Native 或者 Klutter 出来，结果最近我们就看到 JetBrains 的 GitHub 下一个叫 <a href="https://github.com/JetBrains/skiko">skiko</a> 的框架非常活跃，它是基于 Kotlin 多平台特性封装的 Skia 的 API（Flutter：喵喵喵？？）。还有一个就是 <a href="https://github.com/JetBrains/compose-jb">compose-jb</a> 了，我粗略看了下，目前已经把 Compose 移植到了桌面上，支持了 Windows、Linux、macOS，也不知道 iOS 被安排了没有（真实司马昭之心啊）。所以 Compose 已经不再是 Android 的了，它是大家的。</p><p>对于 Compose 而言，KAE 一点儿用都没有，因为人家根本不需要做 View 绑定好不好。</p><blockquote><p>KAE：我这么优秀！</p><p>Compose：你给我让开！</p></blockquote><h2 id="使用-ViewBinding-作为替代方案"><a href="#使用-ViewBinding-作为替代方案" class="headerlink" title="使用 ViewBinding 作为替代方案"></a>使用 ViewBinding 作为替代方案</h2><p>那么问题来了，KAE 废弃之后会怎么样呢？按照链接当中的说明来看，废弃之后仍然可以使用，但会有一个警告；当然，出现问题官方也不会再修复了，更不会有新功能。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-01-08-16-09.png"></p><p>Kotlin 官方建议开发者使用 Android 的 <a href="https://developer.android.com/topic/libraries/view-binding">View Binding</a> 来解决此类场景的问题。客观的讲 View Binding 确实能解决前面提到的几个 KAE 存在的问题，但 View Binding 的写法上也会略显啰嗦：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _binding: ResultProfileBinding? = <span class="literal">null</span></span><br><span class="line"><span class="comment">// This property is only valid between onCreateView and</span></span><br><span class="line"><span class="comment">// onDestroyView.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">    savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: View? &#123;</span><br><span class="line">    _binding = ResultProfileBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">val</span> view = binding.root</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">    _binding = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 View 时：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binding.name.text = viewModel.name</span><br><span class="line">binding.button.setOnClickListener &#123; viewModel.userClicked() &#125;</span><br></pre></td></tr></table></figure><p>相比之下，KAE 解决了 findViewById 的类型安全和访问繁琐的问题；而 View Binding 则在此基础上又解决了空安全的问题。</p><p>我看到在废弃 KAE 的讨论中，大家还是觉得废弃有些难以理解，毕竟之前你也没怎么管这个插件啊，这么多年了除了加了个 Parcelize 的功能以外，也没怎么着啊。不过历史的车轮总是在往前滚（(ノ｀Д)ノ）的嘛，Kotlin 官方这么急着废弃 KAE，也许就是要为 View Binding 让路，JetBrains 现在和 Google 穿一条裤子，谁知道他们是不是有什么对未来的美（si）好（xia）规（jiao）划（yi）呢？哈哈，玩笑啦。</p><p>其实 View Binding 除了写起来多了几行代码以外，别的倒也没什么大毛病。而写法复杂这个嘛，其实说来也简单，我们稍微封装一下不就行了么？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBindingFragment</span>&lt;<span class="type">T: ViewBinding</span>&gt;: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _binding: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> binding: T</span><br><span class="line">        <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateBinding</span><span class="params">(inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 savedInstanceState: <span class="type">Bundle</span>?)</span></span>: T</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> T.<span class="title">onViewCreated</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">return</span> onCreateBinding(inflater, container, savedInstanceState).also &#123;</span><br><span class="line">            _binding = it</span><br><span class="line">        &#125;.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        binding.onViewCreated()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">        _binding = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样用的时候直接继承这个类就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainFragment</span> : <span class="type">ViewBindingFragment</span>&lt;<span class="type">FragmentMainBinding</span>&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateBinding</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: FragmentMainBinding &#123;</span><br><span class="line">        <span class="keyword">return</span> FragmentMainBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> FragmentMainBinding.<span class="title">onViewCreated</span><span class="params">()</span></span> &#123;</span><br><span class="line">        textView.text = <span class="string">&quot;MainFragment&quot;</span></span><br><span class="line">        textView.setOnClickListener &#123;</span><br><span class="line">            Toast.makeText(requireContext(), <span class="string">&quot;Clicked.&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也就是我随手那么一写，肯定算不上完美，但至少说明 View Binding 的写法一样可以做到很简洁。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>KAE 本质上就是通过编译期生成字节码的方式为 Activity、Fragment、View 提供了以 xml 布局中的 id 为名的合成属性，从而简化使用 findViewById 来实现 View 绑定的一个插件。</p><p>相比之下，KAE 比 findViewById 本身提供了更简便的 View 绑定方式，也保证了 View 的类型安全，但却无法保证 View 的空安全 —— 而这些问题都在 ViewBinding 当中得到了解决。</p><p>不管怎样，KAE 被废弃是没什么悬念了，它曾经一度填补了 Android 开发体验上的空缺，也曾经一度受到追捧和质疑，更曾是 Kotlin 早期吸引 Android 开发者的一把利器，现在终于完成了它自己的历史任务。</p><p>再见，KAE。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;伴随了我们这么多年的 KAE，就这么要离开我们了？ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="news" scheme="https://www.bennyhuo.com/tags/news/"/>
    
      <category term="android" scheme="https://www.bennyhuo.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>说说最近官方公布的 Kotlin 的动态</title>
    <link href="https://www.bennyhuo.com/2020/10/19/kotlin-news-202010/"/>
    <id>https://www.bennyhuo.com/2020/10/19/kotlin-news-202010/</id>
    <published>2020-10-18T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.990Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 的发展可以认为是正式进入了下一个阶段。 </p></blockquote><a id="more"></a><p>有段时间没有写文章了。</p><p>今年年底还有些事情要做，所幸大多数都与 Kotlin 有关系，不算耽搁太多。加上现阶段大家有相对充足的资料学习 Kotlin，尽管协程之前的资料相对匮乏，我也在年中出版了一本书暂时补齐了这块儿缺漏，因此我就这么安慰自己不要压力太大，以免腰更加突出，哈哈。</p><p>不过，官方最近有些消息放出来让我有些坐不住了。</p><h2 id="1-Kotlin-的发版节奏"><a href="#1-Kotlin-的发版节奏" class="headerlink" title="1. Kotlin 的发版节奏"></a>1. Kotlin 的发版节奏</h2><p>过去 Kotlin 的版本节奏一直比较佛系，从 1.0 到 1.1 花了一年多，到 1.2 才半年，到 1.3 又近一年，1.4 却花了将近两年。为什么会这样呢？因为越往后，Kotlin 自身的体系越庞大，想要做点儿什么的复杂度可想而知的变高，自然版本节奏就没那么好把控了。</p><p>功能优先还是版本优先？</p><p>显然这个问题在不同的发展阶段是有不同的答案的。项目刚开始，自然需要稳扎稳打，做一个功能就是一个功能，因此可以说 1.4 及以前的所有版本的迭代计划都是按照这个思路展开的，功能啥时候做好啥时候上，做不好就 delay。</p><p>而现如今，</p><p>Kotlin 经过 1.0 正式发布</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-00-49.png"></p><p>1.1 正式支持 JavaScript 并开始试验协程</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-08.png"></p><p>1.2 开始试验多平台</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-29.png"></p><p>1.3 正式支持协程并开始了 Native 的 beta，多平台的生态随之也开始逐渐展开</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-48.png"></p><p>1.4 有做了一系列整体的性能优化和提升，编译器重构也基本完成</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-02-06.png"></p><p>可以说 Kotlin 现阶段的基本盘已经形成，当前版本足以长期支撑开发者完成开发工作了。</p><p>接下来的工作重点我们在之前的文章当中就曾经谈到，其实就是应用场景的挖掘，开发体验的优化和提升，以及多平台的完善和生态的建设。这些大都不算是巨大的语言特性，因此 Kotlin Team 宣布后面发版半年一次，这意味着 Kotlin 1.5 将在明年春天发布，规划的特性实行班车机制，赶得上版本就发布，赶不上就下一趟。</p><p>这样做好处也是很明显的，版本的节奏感会给开发者带来期待，我们不再需要猜下一个版本什么时候来，以及下一个版本会有什么，因为这些都会很早就公布；一些细节的改进我们也不需要苦等很久才能体验到，因为版本节奏快了，一些小的改进会更快的被呈现在开发者面前。</p><h2 id="2-Kotlin-的-Roadmap"><a href="#2-Kotlin-的-Roadmap" class="headerlink" title="2. Kotlin 的 Roadmap"></a>2. Kotlin 的 Roadmap</h2><p>我过去想要提前了解 Kotlin 下一步的动态，主要去 Kotlin 的 GitHub 的仓库和 YouTrack 当中去爬 issue，看大家的讨论，这个过程会比较有趣，因为大佬们经常吵架。如果只是想要消遣，这个方式跟刷知乎也没什么两样，不过如果是去获取信息，那就需要自己认认真真的瞎猜了。</p><p>再往前的时候，Kotlin Team 还会维护一下 Kotlin 在 GitHub 上开的 Keep 仓库，不过这个仓库现在已经是一副年久失修的感觉了。说来还真是要好好提一下，Kotlin 协程的设计文档就在 Keep 仓库当中，虽然感觉比较久远了，但还是很值得一读的。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-27-41.png"></p><p>现在好了，官方直接公布了 Roadmap，这一招配合 Kotlin 的发版节奏的改变，极大的方便了我们这些吃瓜群众。不是想知道 Kotlin 啥时候实现自举吗？Kotlin Team 已经在解决这个问题了，不信看这里：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-54-22.png"></p><p>顺便我们也看到了 Kotlin 编译器插件的 API 现在还没有排到最高优先级，所以等等吧。</p><p>这次 Roadmap 的公布，还是有一些比较有趣的点的，例如：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-57-40.png"></p><p>多个 receiver 的函数，可能有些朋友还没有用到过。其实这个特性现在也有办法来模拟，就是通过隐式 receiver 的方式来实现，但如果能够有专门的语法来支持的，应该还会有更会玩的用法出现。</p><p>Kotlin 近期公布的 Roadmap 见：<a href="https://kotlinlang.org/roadmap.html">Kotlin Roadmap</a>，大家可以自己看看有没有自己感兴趣的内容。</p><h2 id="3-KMM-插件"><a href="#3-KMM-插件" class="headerlink" title="3. KMM 插件"></a>3. KMM 插件</h2><p>KMM 算是 Kotlin Team 为多平台这个重磅特性挖掘的一个重要的应用场景。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-28-19.png"></p><p>毕竟 Kotlin 的用户大多是 Android 开发，Android 开发者的老板们有迫切的希望他手底下的 Android 开发能拿一份工资干两人的活，对吧。不仅如此，Android 开发也希望自己在市场上更有竞争力，如果 Kotlin 适用场景变多了，那么自己岂不是就像买了股票一样跑赢大盘？所以 KMM 简直就是众望所归。</p><p>KMM 运行在 iOS 上的实际上就是 Kotlin Native 的代码，通过 Kotlin MPP 与运行在 Android 上的 Kotlin Jvm 代码来共享逻辑。最近随着 Kotlin 1.4 发布推出的 KMM 插件也支持了在 Android Studio 上直接运行 iOS 应用，启动 iOS 模拟器，甚至单步调试运行在 iOS 上的 Kotlin Native 代码的能力。</p><p>不过，如果想要将 KMM 直接应用于移动端跨平台上上，还是有些问题需要解决的，这主要就是 Kotlin Native 对于 iOS 的支持的问题，例如：</p><ol><li>Kotlin Native 的并发模型比较严格，也正是如此，Kotlin 协程的 Kotlin Native 版本迟迟没有正式推出多线程版本，在 iOS 上使用 Kotlin 协程目前还受制于所调用的 API 是否本身已经自己支持了异步以及回调的线程切换。</li><li>Kotlin 目前尚不能像在 Android 上那样全面替代 Java，从目前以导出 Framework 的方式引入 iOS 工程的做法来看，Swift 和 Objective-C 暂时还是无法完全干掉的。</li><li>Kotlin Native 可用的框架目前仍然比较少，如果想要编写 Kotlin 多平台的代码，也需要我们引入的框架支持 Kotlin 多平台，例如序列化框架可选的目前主要就是官方的 kotlinx-serialization，时间框架主要也是官方提供的 kotlinx-datetime 等等。</li></ol><p>不过这倒也不算什么大问题，毕竟才刚刚开始，Kotlin Native 的并发模型的问题以及 Kotlin Native 开发 iOS 的支持问题都在逐渐优化。</p><p>至于依赖框架的问题，这恰恰也是 Kotlin 的生存哲学之一，Kotlin 游走与各个平台上，一向是以充分利用所在平台的优势为基础的。我们且等它把这些平台的基础 API 进行统一封装，以方便我们实现逻辑层的一致性。</p><p>再稍微提一下，KMM 插件尽管支持了很多功能，但对于 iOS 工程却仍然不能有效支持，这主要体现在对于 Swift、Objective-C 的代码无法高亮、调试等问题上，如果需要编辑 SwiftUI 或者其他使用 Swift 编写的代码模块，还是需要在 Xcode 当中完成。至于将来会不会支持，这一点目前还没有确切的消息。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>Kotlin 1.4 发布了两个月，整体反应来看，大家还是比较平静的，因为这次确实出了 SAM 转换让人期待已久以外，别的都不是很以外。不过，从最近发生的这些变化来看，Kotlin 的将来还是值得期待一下的，至少，它已经找到了自己的路，并开始一步一步走下去了。</p><hr><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-34-14.png"></p><p>最后再提一句，国外疫情肆虐，KotlinConf 今年没法线下开展，这不，也改成线上了。大家可以在 <a href="https://kotlinlang.org/lp/event-14/">Kotlin 1.4 Online Event</a> 这个地址找到所有的视频，内容还是值得了解一下的。</p><p>当然，视频直接收看可能需要一些操作，后面的话我看看能不能跟官方的小伙伴商量下尽快搬到国内的视频平台上。此外，我们目前也在准备后面结合这次 Kotlin 的 Event 在国内做一些分享，届时也会通过公众号发布具体的安排，请大家留意~</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Kotlin 的发展可以认为是正式进入了下一个阶段。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="news" scheme="https://www.bennyhuo.com/tags/news/"/>
    
  </entry>
  
  <entry>
    <title>闲聊 Kotlin-Native (0) - 我们为什么应该关注一下 Kotlin Native？</title>
    <link href="https://www.bennyhuo.com/2020/07/15/kotlin-native-introduction/"/>
    <id>https://www.bennyhuo.com/2020/07/15/kotlin-native-introduction/</id>
    <published>2020-07-14T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.982Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直想写点儿 Kotlin-Native 相关的话题，今天开始~ </p></blockquote><a id="more"></a><h2 id="尴尬的-Kotlin-Native"><a href="#尴尬的-Kotlin-Native" class="headerlink" title="尴尬的 Kotlin-Native"></a>尴尬的 Kotlin-Native</h2><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-41-58.png"></p><p><strong><center>官方题图：Kotlin-Native 的世界</center></strong></p><p>Kotlin-Native 的定位略显尴尬，为什么这么说呢？ 因为现在的编程语言实在太多了，新语言出来必然要解决现有某个语言的痛点，这样才能快速切入该语言所覆盖的领域。Kotlin 也是这样在当年崭露头角的，要不是 Android 上没有很好的替代语言，估计 Kotlin 也不会这么快进入大家的视野。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-44-05.png"></p><p><strong><center>2017 年 Google IO 大会宣布 Kotlin 称为 Android 一级开发语言</center></strong></p><p>说到这里问题就来了， Kotlin-Native 的目标用户到底是谁呢？</p><p> 编译成机器码可以直接在原生环境中运行，我首先能想到的自然是 C 语言。可真的是要去替代 C 吗？显然不可能，毕竟没有 Go 跑得快，用 Go 来替代 C 语言似乎更说得过去。</p><p> 当然有专家尝试用 Go 写了个操作系统发现 Go 的 GC 时间的不确定性会给系统的运行带来一些问题。那没关系啊，对于实时性要求高的场景可以换 Rust 嘛，至少微软已经决定要这么做了，Rust 可以精准控制内存的管理，这一点到现在可能还真没有哪一门语言与之媲美，也难怪它最近几年这么火。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-17-42-11.png"></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-47-36.png"></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-48-03.png"></p><p><strong><center>2020.07 TIOBE 编程语言排名：C:1，Go:12，Rust:18，Kotlin:27</center></strong></p><p>就算将来 Kotlin-Native 在性能上也优化到 Go 和 Rust 的水平，考虑到它的 Java 背景， C 和 C++ 的程序员可能也不太愿意接受这样一个“外来户”。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-49-01.png"></p><p><strong><center>Java 跟 C++ 的火拼现场，PHP 或成最大受害者</center></strong></p><p>那 Kotlin-Native 就这么凉了？</p><p>据我观察它的目标用户群体至少应该不是 Java 开发者，因为 Java 开发者只有在写 JNI 的时候才会有 Native 代码开发的需要，而 Kotlin-Native 做了 C-interop 就去做 Objective-C 的 interop，很多人开 issue 问官方要不要搞一个简化 JNI 调用的功能，官方的答复竟然是“为啥不直接在 Java 虚拟机上写 Kotlin 呢？” 。</p><p>不过说到这儿似乎官方的意图很明显了，就是要去拉拢 iOS 的开发了，但高傲的 iOS 开发者们会这么轻易被收买吗？Hmmm，我突然想到了之前跟某位大哥聊天，他说搞 Flutter 的基本上都是 Android 转的，所以。。Kotlin-Native 的实际目标用户群体还是 Android 开发者，只不过是在他们的老板裁掉同组的 iOS 开发之后或者。。。（啊，我是不是说太多了！）</p><p>这么说来接下来我写的这系列 Kotlin-Native 的文章的目标用户还是 Android 开发者为主的 Kotlin 开发者。</p><p>当我跟几个小伙伴说了我的下一步的想法，《Kotlin 编程实践》的译者禹昂就打趣到：“你的协程书还没看完呢，跟不上了啊。” 没事儿没事儿，Kotlin 的版本更新已经算是很慢的了，我也会尽量让自己的文章更新的慢一点儿（似乎找到了一个很好的拖更的理由！）。</p><h2 id="为什么我们需要了解下-Kotlin-Native"><a href="#为什么我们需要了解下-Kotlin-Native" class="headerlink" title="为什么我们需要了解下 Kotlin-Native"></a>为什么我们需要了解下 Kotlin-Native</h2><h3 id="零成本多平台抽象"><a href="#零成本多平台抽象" class="headerlink" title="零成本多平台抽象"></a>零成本多平台抽象</h3><p>前面我们的分析大致可以得出结论：Kotlin-Native 似乎也就是在 iOS 上有些前途。然而现实可能更残酷，因为可能大多数 App 根本没有什么逻辑，用 Flutter 跨平台岂不是更好，为什么还要搞 Kotlin-Native 呢？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-15-10-16-22.png"></p><p>原因也很简单，与 Flutter 的定位不同，Kotlin-Native 给予了我们开发者更多的可能。Kotlin 的设计思路其实一直都是这样，给开发者或者社区留足发挥的空间，做好语言应该做的事儿。类似的还有协程的设计，语言层面打好基础你就可以在框架层面造出各种飞机大炮。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-53-40.png"></p><p><strong><center>Kotlin 在 Android &amp; iOS 上共享逻辑</center></strong></p><p>用 Kotlin 的多平台特性，其实我们完全可以抽象出一套 UI 框架，用相同的 API 在不同的平台上使用各自的 UI 控件。这似乎有点儿像 React Native？对，思路完全一样，不同之处在于 Kotlin 没有额外的开销，Android 上 Kotlin 代码就是原生的代码，iOS 上 Kotlin-Native 与 Swift 编译出来的机器码没有任何实质上的区别。实际上已经有牛人开发了这样一个框架了，有兴趣的同学可以了解下：<a href="https://github.com/icerockdev/moko-widgets">moko-widgets</a>。</p><p>官方在这方面也是非常努力的，从 1.4 预览版就开始都支持 Swift 调用 suspend 函数了，我倒是很期待 Android Studio 直接开发 iOS 的事儿。这也真不是我瞎说，Kotlin 之父在 Kotlin Conf 上自己说的，1.4 官宣发布的时候又再次提到了这一点，而且 JetBrains 全家桶里面本来就有 AppCode 用来开发 Apple 体系下的应用，整合一下应该不是什么难事，工作量问题吧。</p><p>你可以在不同的平台上做抽象，而这根本没有什么成本，不仅仅在 Android 与 iOS 上。我注意到最近关于 Rust 写前端的文章尤其多，其实就是因为 Rust 支持编译成 WASM 跑在支持它的浏览器上，Kotlin-Native 又何尝不可呢。</p><p>不仅如此，Kotlin-Native 现在的开发体验已经比以前强太多了，标准库虽然还比较小，不过至少基本的集合框架类都是有的，字符串之类的支持也都是有的。没有的我们自己用 C 接口包装一下也不是什么事儿对吧，照着 JDK 的 API，用 MPP 的特性自己实现其他平台的，似乎也不是什么不可能的事儿。还真有人在尝试这么干，不信大家瞧瞧这里：<a href="https://github.com/caffeine-mgn/pw.binom.io">pw.binom.io</a>，使用这个框架可以在它支持的所有平台上写出下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = <span class="string">&quot;Simple Text&quot;</span>.asUTF8ByteArray()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> file = File(<span class="string">&quot;Simple File&quot;</span>)</span><br><span class="line">    FileOutputStream(file, <span class="literal">false</span>).use &#123;</span><br><span class="line">        it.write(<span class="keyword">data</span>, <span class="number">0</span>, <span class="keyword">data</span>.size)</span><br><span class="line">        it.flush()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Write data: \&quot;<span class="subst">$&#123;data.asUTF8String()&#125;</span>\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">out</span> = ByteArrayOutputStream()</span><br><span class="line">    FileInputStream(file).use &#123;</span><br><span class="line">        it.copyTo(<span class="keyword">out</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Read data: \&quot;<span class="subst">$&#123;out.toByteArray().asUTF8String()&#125;</span>\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子告诉我们 Kotlin 的这个特性为我们提供了把任意它支持的平台当做我们最熟悉的那个平台来开发的机会。</p><h3 id="多平台特性的持续优化"><a href="#多平台特性的持续优化" class="headerlink" title="多平台特性的持续优化"></a>多平台特性的持续优化</h3><p>1.4-M2 开始支持结构化多平台特性，也就是大佬们经常提到的 HMPP。</p><p>多平台代码之间之前只有 common 部分是可以共享的，但这显然不够，例如 Linux 的各种衍生版本之间还可以共享一部分代码，之前不能，现在终于可以了。</p><p>这个特性咱们普通开发者可能感受不是特别明显，不过你很难想想框架开发的大佬期待这个特性期待了多久，协程框架马上就用这个特性把多线程的能力做了抽象，等后面达到一个相对稳定的状态之后也许你就会发现 Jvm 和 Native 上的多线程抽象居然用的是同一套代码，不同的就是各自的线程的具体 API 的使用。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-07-51-38.png"></p><p><strong><center>结构化多平台特性示意图</center></strong></p><p>1.4 发布之后，多平台特性官宣进入 alpha 阶段，尽管还不是 release 的状态，但也是 release 倒计时了。客观的讲，多平台相关的绝大多数 API 经过几轮大规模迭代，已经进入较为稳定的状态，之所以还称为 alpha，估计是部分平台的周边支持例如 kotlin-js 的 dukat 还在快速迭代当中。</p><p>多平台的重大意义在于 Kotlin 生态的建立。一旦这个特性扶正了，那 Kotlin 跨平台的框架生态发展可以直接得到提速，框架的开发者可以花更低的成本开发全平台适用的 Kotlin 框架，生态好才是王道。</p><h3 id="“新基建”的时代背景"><a href="#“新基建”的时代背景" class="headerlink" title="“新基建”的时代背景"></a>“新基建”的时代背景</h3><p>前面我们已经看到 C 语言又力压 Java Python 夺得榜首，因为物联网？因为 5G？因为新基建？反正这几年公司项目的原因接触了不少智能硬件相关的团队和公司，虽然 Android 开始逐渐进入大家的视野，但厉害点儿的硬件还是用 Linux 直接开发。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-22-06-10.png"></p><p><strong><center>4G 时代为消费互联网的繁荣提供了土壤，而 5G 时代下的赢家又是谁？</center></strong></p><p>过去的十年迅猛发展的手机性能极大的改善了我们的生活，而现在手机的发展似乎除了大屏和高性能已经没有什么新意了，互联网的浪潮也早已没有了昔日的疯狂。</p><p>说到这儿，想起一个有趣的故事。我曾听曾经在 3W 咖啡馆工作的师兄讲那会儿有人在大冬天极冷的条件下坐在外面干活，想要以此证明他顽强的毅力来吸引投资人的注意。现在想想真是不可思议。那个年代只要会写 APP 就能进大公司，现在遍地都是会写 APP 的，你的竞争力体现在哪里呢？</p><p>现在很多时候我们要解决的需求大不再是简单的写个 APP 那么简单，搭配硬件已经是常规操作。IoT 在 5G 背景下可以实现高速率、低延时的远程控制和更多设备的接入，专业领域的小系统在这方面有着天然的优势。</p><p>而硬件厂商通常有着多年的 Linux 系统开发的经验积累，同时又对 Android 系统在此类场景下的稳定性表现出了极大的不信任。开发者在这个时代背景下想要脱颖而出，C 语言功底总要有吧？了解下 Kotlin-Native 还能顺带提高一下 C 的水平，与自己现有技术栈也能充分结合起来，甚至还可以把以前运行在其他平台的逻辑轻松地移植过来，何乐而不为呢。</p><h2 id="我们该怎么学习-Kotlin-Native-呢？"><a href="#我们该怎么学习-Kotlin-Native-呢？" class="headerlink" title="我们该怎么学习 Kotlin-Native 呢？"></a>我们该怎么学习 Kotlin-Native 呢？</h2><p>先了解下 Kotlin-Native 需要的背景知识。</p><ol><li>扎实的 Kotlin 语法基础。这一点只要是习惯了使用 Kotlin 开发 Android 应用的开发者，一般来讲问题不大。语法上 Kotlin 不管是在哪个平台，包括 Kotlin-js，差异几乎可以忽略。</li><li>C 语言背景。学习 Kotlin-Native 之前掌握 C 语言是必要的，这与我们开发 Kotlin-Jvm 程序需要先了解 Java 及其生态是一样的道理。</li></ol><p>有了这两点基础，在学习的过程中就基本上不会有太大的障碍了。</p><p>接下来就是搞清楚自己的需求。学习 Kotlin-Native 的目的是什么呢？如果是开发一款与 Android 共享部分代码的 iOS 应用来实践 Kotlin 跨平台的特性，那么你还需要对 Objective-C 或者 Swift 有一定的了解。</p><p>或者你想要了解一下 Kotlin-Native 的垃圾回收机制，对比下与 C++ 的智能指针、Rust 的内存管理甚至与 JVM 的内存垃圾回收机制的区别，那你就要去啃一下 Kotlin-Native 的源码了。</p><p>说了这么多，我后面的文章大概会写点儿什么内容呢？</p><ol><li>Kotlin-Native 编译逻辑以及工程的搭建。这个是必不可少的，而且这块儿还稍微有点儿复杂。幸运的是 Gradle 也支持 Kotlin 脚本，所以我们不必再忍受 Groovy 的动态特性的摧残。</li><li>Kotlin-Native 组件的发布逻辑。也许我们将来会考虑自己发一款跨平台的框架来取悦自己，所以这个也是很重要的。</li><li>Kotlin-Native 与其他语言的互调用，主要是 C 和 Objective-C（Swift）。当然，我们也可以尝试通过 C 接口调用一下 Python 或者 Lua，甚至是 JNI。</li><li>研究一下 Kotlin-Native 的运行机制，目前能想到的主要就是内存管理吧。</li><li>协程在 Kotlin-Native 上对于并发的支持。</li><li>Ktor 上 CIO 对 Kotlin-Native 的支持。目前这个特性还在开发中，CIO 已经对 JVM 做了支持，我也在《深入理解 Kotlin 协程》当中稍微做了介绍，不过跨平台版本应该很值得期待。</li></ol><p>其他。。。我还没有想到，先挖这么多坑吧，后面慢慢填。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章算是这一系列的先导篇吧，谢谢大家的关注，咱们下一篇再见。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一直想写点儿 Kotlin-Native 相关的话题，今天开始~ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="native" scheme="https://www.bennyhuo.com/tags/native/"/>
    
  </entry>
  
  <entry>
    <title>我写了一本书，《深入理解 Kotlin 协程》</title>
    <link href="https://www.bennyhuo.com/2020/06/23/understanding-kotlin-coroutines/"/>
    <id>https://www.bennyhuo.com/2020/06/23/understanding-kotlin-coroutines/</id>
    <published>2020-06-22T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.994Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没想到 Kotlin 的协程居然会成为一个有争议的话题，谁让官方材料太少呢。 </p></blockquote><a id="more"></a><p>Kotlin 从 1.1 开始推出协程特性，当时还是实验性质的特性。</p><p>我研究 Kotlin 协程的过程其实主要分了三个阶段。</p><p><strong>第一个阶段，深入理解 Kotlin 协程的三篇文章</strong>。翻了翻过去的文章记录，我在 2017 年 1 月当时 Kotlin 1.1-beta 刚刚发布之时就发布了第一篇介绍协程的文章<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483875&idx=1&sn=b1b565f651ee1221d4bda19ab12009ce&chksm=e8a05ededfd7d7c878c1c483c577ec53bcf42ee4cb0fe5d13f29d12ff62a1e335c4afa616ffa&token=10610078&lang=zh_CN#rd">深入理解 Kotlin Coroutine （一）</a>，主要介绍了协程的标准库的 API，以及简单的协程封装思路。随后在那年的春节发了第二篇<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483878&idx=1&sn=710189e6e22a13fc7d1ea67bc2dd9270&chksm=e8a05edbdfd7d7cd163ee1a2d5769fc2bf003e2d5a6d3f9c6382531b7efc22a6ab75300bb906&token=10610078&lang=zh_CN#rd">深入理解 Kotlin Coroutine (二）</a>，介绍协程的框架 kotlinx.coroutines 的一些功能，当时这个框架还非常的小，源码很容易就能够通读完，与现在简直不可同日而语了。期间也搞了一些线下的活动来分享协程的用法和作用，在 1.1 正式发布不久之后又写了一篇介绍协程的使用场景的文章<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484000&idx=1&sn=12f6a010c6fb554b94f68fd5ab6f941e&chksm=e8a05d5ddfd7d44b66c354041fd5f330a297c42b8d451f0b1f38676e83018263b2200c60be57&token=10610078&lang=zh_CN#rd">深入理解 Kotlin Coroutine（三）</a>。</p><p>**第二个阶段，<a href="https://github.com/enbandari/CoroutineLite">CoroutineLite</a>**。这是我仿照官方协程框架 kotlinx.coroutines 的 API 自己实现的一套协程框架，目的主要是为了教学和研究，因此代码编写时主要考虑的目标是可读性，与官方框架追求性能的实现有着本质的不同。当然，这个框架的实现只包括了最基本的内容，像 Channel、Flow 这样更上层的组件便没有提供了。这个框架最初是在我在制作<a href="https://coding.imooc.com/class/232.html">基于GitHub App业务 深度讲解 Kotlin高级特性与框架设计</a> 这门视频课程时开发的，由于当时 Kotlin 的版本是 1.2，因此视频当中提及的 CoroutineLite 还是一个雏形，直到我去年重制<a href="https://coding.imooc.com/class/398.html">Kotlin从入门到精通</a>和编写<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>时，才为它添加了作用域、取消支持等功能，并进一步的完善很多细节上的设计。这个框架目前已经开源，希望它能够帮助各位读者更好的了解 Kotlin 协程的内部运行机制，这是必要的，也是必须的。</p><p><strong>第三个阶段，破解 Kotlin 协程系列文章</strong>。这几年在帮助大家学习 Kotlin 的过程中，我发现大家对于协程逐渐产生不解、害怕甚至是不屑等各种各样的情绪，一方面是因为 Kotlin 的大部分受众源自于 Android 开发者群体，Android 开发者群体如果从一开始就在这个小圈子内成长的话，确实没有什么机会接触到协程。我自己也是 Android 开发，能够深刻的体会到 Android 技术圈子的局限性，只不过我有幸有机会多接触了几门语言和应用领域。这一系列文章就是想直接基于 Kotlin 1.3 以来已经成熟的生态和框架来介绍 Kotlin 协程，一写就是十几篇，我制作了一个文章合集，有兴趣的朋友可以参阅：<a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTYzOTYzNA==&hid=4&sn=eb02d1dc6f5d92096f214688c6f87196">Kotlin 协程文集</a>。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-50-26.png"></p><p><strong><center>视频课程“Kotlin从入门到精通”中对协程的剖析</center></strong></p><p>现在，我把前面的这些积累以及在于大家交流过程中发现的问题进行了分析和整理，参考了各家语言对于协程的实现，系统地剖析了 Kotlin 协程的方方面面，编撰成了这样一本《深入理解 Kotlin 协程》的书籍。</p><p>这本书主要回答了以下几个常见的问题：</p><ol><li>协程是什么？Kotlin 协程又是什么？</li><li>Kotlin 协程的工作机制是怎样的？</li><li>如何将 Kotlin 协程投入生产实践当中？</li></ol><p>不仅如此，本书还致力于让大家能够自己尝试动手实现自己的协程框架，成为深谙 Kotlin 协程之道的高手，这样才配得上“深入理解”这个标题。</p><p>还有一个小细节。本书印刷版中所有的代码都采用了 JetBrains Mono 这个字体，插图的文字也是如此。另外，本书代码缩进采用了 2 个空格的样式，目的也是为了减少折行，提高版面的空间利用率，进而提升阅读体验。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-06-10-23-25.png"></p><p><strong><center>使用 JetBrains Mono 排版的代码效果</center></strong></p><p>书的编写过程也比较有意思。我是用 VSCode + Pandoc + graphviz + mermaid.js + plantUML + rx-marbles 等工具来编写的。其中，使用 VSCode 处理文字内容；使用 Pandoc 将 md 文件编译成 docx 文件；使用后面的四个工具来绘制插图 —— 它们实际上是将源码编译成图片的处理工具。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-39-57.png"></p><p><strong><center>《深入理解 Kotlin 协程》的插图制作</center></strong></p><p>环境的配置，以及对这些工具的定制花去了我将近两个月的业余时间。除了使用 Haskell 编写的 Pandoc 的插件 cross-ref 我实在无法快速上手以外，我学习到了如何使用 Python 和 Lua 编写用来在编译过程中处理图片生成逻辑和文字预处理的 Pandoc 过滤器，以及如何通过修改源码解决 plantUML、mermaid.js、rx-marbles 的样式定制和字体的支持的问题，最后还借机学会了如何制作 docker 镜像。</p><p>当然，我在本书写作过半之时，突发奇想开始学习双拼输入法，刚开始的那一段时间曾一度因为不知道如何打字而憋得着急上火，不过那时的感觉像极了十几年前在大学里刚买电脑之后连 QQ 都聊不明白的光景，自己似乎又年轻了一回。</p><p>可以说，这一本书的编写过程，除了促使我对 Kotlin 协程有了一个更加宏观的概念把控之外，我还学到了非常多有意思的东西。</p><p>当然，除了有意思之外，在写作的过程中我也确实无数次感觉到了对文字细节的疲惫，但一次次的修改和校对之后又觉得非常值得。</p><p>感谢这样的一个机会，在这不平凡的 2020 年里，我写了一本书 ：）</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;没想到 Kotlin 的协程居然会成为一个有争议的话题，谁让官方材料太少呢。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>C 语言版的 println？</title>
    <link href="https://www.bennyhuo.com/2020/06/14/c-println/"/>
    <id>https://www.bennyhuo.com/2020/06/14/c-println/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.987Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 当中的 println 非常好用，可是 C 当中我们常用的 printf 却总是需要格式化字符，并且需要手动提供换行符。 </p></blockquote><a id="more"></a><p>我们在 Kotlin 当中想要输出一个变量，直接调用 println 即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;bennyhuo&quot;</span></span><br><span class="line">println(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> age = <span class="number">30</span></span><br><span class="line">println(age)</span><br></pre></td></tr></table></figure><p>不管什么变量类型，println 一律照单全收，是不是很方便？</p><p>而我们的 C 语言呢，想要打印个变量可就没那么轻松了，不仅如此，换行符都得我们手动输入，如果能同时打印出对应的代码文件和行号查问题就更方便了。</p><p>有没有什么办法解决这些问题呢？</p><h2 id="问题一：自动换行"><a href="#问题一：自动换行" class="headerlink" title="问题一：自动换行"></a>问题一：自动换行</h2><p>printf 是不会自动换行的，因此每次我们都需要在格式化字符串当中加一个 <code>\n</code>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, age);</span><br></pre></td></tr></table></figure><p>解决换行的问题很简单，我们只需要定义一个函数 printlnf，在打印了需要打印的内容之后跟一个换行符的输出即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlnf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    <span class="built_in">vprintf</span>(format, args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里打印换行符比较容易理解，不过对于变长参数的处理就有点儿晦涩了，至少不像我们在 Kotlin 当中可以直接拿到一个数组来处理变长参数。</p><p>在 C 当中，我们无法知道有多少个变长参数，通常支持变长参数的函数需要通过前面的固定的参数来携带这个信息，例如 printf 可以通过格式化字符串 format 当中的格式符来判定后面有多少个参数。好在我们在这个场景下只要能把 println 的变长参数透传给 printf 就行了（当然我们实际上是透传给了 vprintf），多少个其实我们可以不关心。按照 C 标准的提供的方法，我们可以使用 <code>va_list</code> 来承载变长参数的值，使用 <code>va_start</code> 和 <code>va_end</code> 来获取和清除变长参数，vprintf 实际上就是 printf 的一个变种，它可以直接接受 <code>va_list</code> 类型的参数做为后面需要被格式化的参数。</p><p>用法起来嘛，还是可以的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printlnf(<span class="string">&quot;%d&quot;</span>, <span class="number">5</span>); <span class="comment">// 5\n</span></span><br></pre></td></tr></table></figure><p>不过实话这个函数定义并不是很美，看着太长了。</p><p>在 C 语言当中，还有一套强大的预处理机制，如果我们用宏来实现 printlnf，效果会怎样呢？（我似乎想到了 rust 的 println!）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printlnf(format, ...) printf(format<span class="meta-string">&quot;\n&quot;</span>, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><p>额，用宏实现就这么简单？</p><p>首先我们注意一下 <code>format&quot;\n&quot;</code>，这个语法特别有意思，在 C 当中我们可以直接拼接字符串字面量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot;benny&quot;</span><span class="string">&quot;huo&quot;</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot;bennyhuo&quot;</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>1 和 2 是等价的，字面量连接在一起可以直接实现拼接的效果。那么我们定义的宏当中 format 如果是一个字符串字面量的话，自然就能实现拼接效果了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printlnf(<span class="string">&quot;Hello %s&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure><p>经过编译器预处理之后展开宏得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello %s&quot;</span><span class="string">&quot;\n&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure><p>所以换行的问题就解决了。当然，宏的这个实现方案有个缺点，format 必须是字符串字面量，下面的用法是错误的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *format = <span class="string">&quot;Hello %s&quot;</span>;</span><br><span class="line">printlnf(format, <span class="string">&quot;C&quot;</span>); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>因为宏展开以后得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *format = <span class="string">&quot;Hello %s&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(format<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;C&quot;</span>); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>不管怎样，我们总是可以在一定的场景下通过上面的实现来解决为 printf 自动追加一个换行符的问题。</p><h2 id="问题二：支持非字符串类型直接打印"><a href="#问题二：支持非字符串类型直接打印" class="headerlink" title="问题二：支持非字符串类型直接打印"></a>问题二：支持非字符串类型直接打印</h2><p>C 毕竟不是面向对象的语言，我们也很难说有一个统一的办法把所有的结构体转成字符串（字符数组），因此我们的要求也不高，对于基本类型，可以实现类似下面的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>这要是在 C++ 当中，我们直接重载一下这个函数即可，但 C 语言不支持啊（实际上 C++ 的重载会用参数类型去修饰函数名来生成最终的函数符号），不过 C11 新增了一个特性 <code>_Generic</code>，可以支持泛型！</p><p>妈呀，C 语言居然也有泛型，惊喜不惊喜！让我们来看看它的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = _Generic(x,</span><br><span class="line">        <span class="keyword">int</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="keyword">double</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="keyword">char</span> * : <span class="number">4</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们可以把它当做一个特殊的函数，第一个参数 x 是需要提取类型的变量，第二个参数则是一个类似于 switch case 的分支语句，如果 x 是 int 类型，那么返回值就是 2，如果是 double 类型，那么返回 3，等等。</p><p>不得不说，这语法中透露着年代感。但不管怎样，总算能用。</p><p>我们来试着考虑实现一个 println 的函数或者宏，不过很快我们就会发现函数是无法实现的，只能使用宏。为什么呢？因为这里的参数 x 的类型是需要在编译的时候确定的，如果我们试图实现 println 函数的话，那么参数的类型要怎么定义呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(??? format, ...)</span> </span>&#123;</span><br><span class="line">  _Generic(format, ...);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设将 format 定义为 <code>char*</code> 类型，那么泛型的判断豪无意义，因为 <code>_Generic</code> 永远会选择 <code>char*</code> 分支的返回值。</p><p>既然如此， format 就不能有类型咯。谁的参数可以没有（或者不能有）类型？宏呗。所以我们只好实现一个宏版本的 println 了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println(X) _Generic((X),  \</span></span><br><span class="line">    <span class="keyword">int</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, X), \</span><br><span class="line">    <span class="keyword">float</span>: <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, X), \</span><br><span class="line">    <span class="keyword">char</span> *: <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, X), \</span><br><span class="line">    <span class="keyword">double</span> : <span class="built_in">printf</span>(<span class="string">&quot;%0.4f\n&quot;</span>, X) \</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>这当中可以支持更多的类型，我们就举上面的几个为例。具体用法呢：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">println(<span class="number">3</span>);</span><br><span class="line">println(<span class="number">0.3</span>);</span><br><span class="line">println(<span class="number">34.0f</span>);</span><br></pre></td></tr></table></figure><h2 id="问题三：打印文件名和行号"><a href="#问题三：打印文件名和行号" class="headerlink" title="问题三：打印文件名和行号"></a>问题三：打印文件名和行号</h2><p>C 当中提供了两个宏：</p><ul><li><code>__FILE__</code>：展开之后就是文件的全路径（具体结果当然也跟编译器实现和参数有关系）。</li><li><code>__LINE__</code>：展开之后就是所在的源代码文件行的行号，是个整型。</li></ul><p>有了这两个宏，那么实现这个功能也就不难做到了。</p><p>首先需要考虑的就是用函数实现还是用宏实现的问题。由于需要打印调用点的位置，而函数的实现会影响调用栈，因此这里使用只能宏来实现。宏调用会直接展开在调用处，因此行号和文件名都是正确的结果，实现方式也比较简单，我们给出 printlnf  的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printlnf(format, ...) printf(<span class="meta-string">&quot;(%s:%d) &quot;</span>format<span class="meta-string">&quot;\n&quot;</span>, __FILE__, __LINE__, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><p>使用效果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printlnf(<span class="string">&quot;%d&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(C:\Users\bennyhuo\WorkSpace\Demos\HelloCInClion\main.c:48) 30</span><br></pre></td></tr></table></figure><p>如果大家使用 CLion 开发，可以直接点击输出的文件和行号跳转到对应的源码位置，方便吧。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们通过改造 printf，得到了两套实现，其中：</p><ol><li>在原有 printf 上增加换行，其他功能不变，得到 printlnf 函数和宏实现；</li><li>支持直接打印常见类型，得到 println 的宏实现。</li></ol><p>二者也都可以根据需要添加对文件名和行号的输出支持。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Kotlin 当中的 println 非常好用，可是 C 当中我们常用的 printf 却总是需要格式化字符，并且需要手动提供换行符。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="c" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="macro" scheme="https://www.bennyhuo.com/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 为 Map 提供的那些默认值相关的扩展，你用过吗？</title>
    <link href="https://www.bennyhuo.com/2020/06/09/kotlin-map-default/"/>
    <id>https://www.bennyhuo.com/2020/06/09/kotlin-map-default/</id>
    <published>2020-06-08T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.985Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Map 的 Value 类型是一个可空类型，Kotlin 早就想好了怎么帮你优雅地面对它。 </p></blockquote><a id="more"></a><p>Map 是我们经常用到的集合框架的一种，Java 标准库当中提供的 Map 的实现也是比较好用的。不过 Kotlin 为 Map 提供了几处默认值相关的扩展，让 Map 的使用变得更加轻松，不知道大家有没有注意到呢？</p><h3 id="1-getOrElse"><a href="#1-getOrElse" class="headerlink" title="1. getOrElse"></a>1. getOrElse</h3><p>这个比较简单，我们先来看下它的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;K, V&gt;</span>.<span class="title">getOrElse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="type">K</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">  defaultValue: () -&gt; <span class="type">V</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: V = <span class="keyword">get</span>(key) ?: defaultValue()</span><br></pre></td></tr></table></figure><p>如果没有元素 key，那么就返回默认值，默认值通过对参数中的 defaultValue 进行求值得到。当然，如果不需要默认值，那么这个求值过程也是不会发生的。</p><p>这种情况比较适合空值的语义与默认值相同的情况，例如我用 Map 中的值做为某种配置：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = HashMap&lt;String, <span class="built_in">Boolean</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> isEnabled = config.getOrElse(<span class="string">&quot;isEnabled&quot;</span>, &#123; <span class="literal">false</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="2-getOrPut"><a href="#2-getOrPut" class="headerlink" title="2. getOrPut"></a>2. getOrPut</h3><p>需要注意的是，getOrElse 的调用过程中 Map 没有被修改，即默认值并没有真正成为 Map 的元素。如果我们有下面的需求，那就要考虑使用 getOrPut 了：</p><p>我们有一个事件回调接口，不同事件用 eventId 来区分：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnEventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onEvent</span><span class="params">(eventId: <span class="type">String</span>, <span class="keyword">data</span>: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要提供对事件回调注册的能力：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> eventListeners = HashMap&lt;String, ArrayList&lt;OnEventListener&gt;&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addOnEventListener</span><span class="params">(eventId: <span class="type">String</span>, listener: <span class="type">OnEventListener</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 listener 的思路也很简单，先看看 eventListeners 当中有没有对应的 eventId 的事件回调 list，如果有，直接添加；如果没有，先构造一个 list 实例，然后再添加。所以最为朴素的实现就是下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addOnEventListener</span><span class="params">(eventId: <span class="type">String</span>, listener: <span class="type">OnEventListener</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> listenerList = eventListeners[eventId]</span><br><span class="line">    <span class="keyword">if</span> (listenerList == <span class="literal">null</span>) &#123;</span><br><span class="line">        listenerList = ArrayList()</span><br><span class="line">        eventListeners[eventId] = listenerList</span><br><span class="line">    &#125;</span><br><span class="line">    listenerList.add(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这个也太不 Kotlin 了。</p><p>好在我们有 getOrPut，它提供了在 Map 中不存在对应的 Key 时返回默认值并将默认值添加到 Map 中的能力，它的实现非常直接：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> MutableMap<span class="type">&lt;K, V&gt;</span>.<span class="title">getOrPut</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="type">K</span>, defaultValue: () -&gt; <span class="type">V</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: V &#123;</span><br><span class="line">    <span class="keyword">val</span> value = <span class="keyword">get</span>(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> answer = defaultValue()</span><br><span class="line">        put(key, answer)</span><br><span class="line">        answer</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然如此，我们就可以简化 addOnEventListener 的实现了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addOnEventListener</span><span class="params">(eventId: <span class="type">String</span>, listener: <span class="type">OnEventListener</span>)</span></span> &#123;</span><br><span class="line">    eventListeners.getOrPut(eventId, defaultCreator).add(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-隐式默认值"><a href="#3-隐式默认值" class="headerlink" title="3. 隐式默认值"></a>3. 隐式默认值</h3><p>除了在获取时才能确定的默认值以外，还有一个在 Map 定义的时候就可以指定的方式，即：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = HashMap&lt;String, <span class="built_in">Boolean</span>&gt;().withDefault &#123; <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure><p>这个也被称为隐式默认值，它的效果与 getOrElse 一致，在获取某一个不存在的 Key 时，直接返回默认值表达式的求值结果，在上面的例子当中就是 <code>&#123; false &#125;</code> 的求值结果了。</p><p>不过如果大家用过这个功能的话，应该一开始都会感到比较疑惑，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEnabled = config[<span class="string">&quot;isEnabled&quot;</span>] <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>用于此时我们的 config 只是一个空 Map，因此不存在 <code>isEnabled</code> 这个 Key，按照我们的直觉，这时应该触发默认值的求值过程并返回 false 对吧？但实际上不是这样的，标准库 API 的设计者为了确保对应的实现复合 Map 的接口定义，在我们调用 Map 接口的方法时，行为与普通的 Map 保持一致，因此 <code>config[&quot;isEnabled&quot;]</code> 或者说等价的 <code>config.get(&quot;isEnabled&quot;)</code> 调用并不会触发默认值的求值。</p><p>那我想要获得默认值要怎么做呢？</p><p>调用另外的一个扩展方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEnabled = config.getValue(<span class="string">&quot;isEnabled&quot;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="4-默认值的提供方式"><a href="#4-默认值的提供方式" class="headerlink" title="4. 默认值的提供方式"></a>4. 默认值的提供方式</h3><p>前面提到的三种方式中，默认值都是通过一个函数提供的，这样做有什么好处呢？</p><p>其实如果 Map 的 Value 类型是不可变的数据类型，那么直接使用一个默认值即可，例如 Boolean、String 这样的基本类型。但对于可变的类型，例如前面例子中的 ArrayList，提供统一的默认值显然是行不通的，对象被不同的 Key 共享必然会造成逻辑的混乱。</p><p>还有一个原因，函数可以共享，只需要创建一个统一的对象，每次使用的时候复用即可，默认值本身并不总是需要，自然也并不总是需要创建出来，因此这里采用延迟计算还可以减少对象创建的成本。</p><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><p>好啦，这一篇文章没有什么有难度的地方，源码大家一看就明白，使用时只要注意其中的细节即可。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Map 的 Value 类型是一个可空类型，Kotlin 早就想好了怎么帮你优雅地面对它。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="map" scheme="https://www.bennyhuo.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin、Swift、Scala 的延迟求值</title>
    <link href="https://www.bennyhuo.com/2020/05/23/lazy-evaluation/"/>
    <id>https://www.bennyhuo.com/2020/05/23/lazy-evaluation/</id>
    <published>2020-05-22T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.986Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“懒”是程序员最优秀的品质之一，程序也是如此。 </p></blockquote><a id="more"></a><p>Kotlin 当中的 Lazy 想必大家都已经非常熟悉了，它其实承载的功能就是变量的延迟求值。今天我们同样来对比一下其他语言对于类似功能的实现。</p><blockquote><p>最近在探索相同特性在不同语言中实现的对比的文章写作思路，如果大家觉得有收获，别忘了点个赞让我感受一下；如果觉得这思路有问题，欢迎评论留言提建议 ~~</p></blockquote><h2 id="Kotlin-的延迟求值"><a href="#Kotlin-的延迟求值" class="headerlink" title="Kotlin 的延迟求值"></a>Kotlin 的延迟求值</h2><p>Kotlin 最初亮相的时候，基于属性代理实现的 Lazy 就是最吸引人的特性之一。只有使用时才会初始化，这个看上去简单的逻辑，通常我们在 Java 当中会写出来非常啰嗦，延迟初始化也经常因为各种原因变成“忘了”初始化，导致程序出现错误。</p><p>这一切在 Kotlin 当中变得非常简单。Kotlin 的 Lazy 通过属性代理来实现，并没有引入额外的关键字，这一点似乎非常符合 Kotlin 的设计哲学（就像其他语言的协程都喜欢 async/await 关键字，而 Kotlin 只有一个 suspend 关键字就承载了及其复杂的逻辑一样）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lazyValue <span class="keyword">by</span> lazy &#123; </span><br><span class="line">    complicatedComputing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了可以用于变量声明，Lazy 也同样适用于函数传参，这一点非常重要，我们来看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">assertAllTrue</span><span class="params">(<span class="keyword">vararg</span> conditions: <span class="type">Lazy</span>&lt;<span class="type">Boolean</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> conditions.all &#123; it.value &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assertAllTrue 这个函数的目的是判断所有参数的条件都为真，因此如果其中有一个为假，那么后面的条件就不用计算了，这个逻辑类似于我们常见的 <code>&amp;&amp;</code> 运算中的逻辑短路。代码中，it.value 的 it 是 <code>Lazy&lt;Boolean&gt;</code> 类型，value 是 Lazy 的属性，我们可以通过这个属性来触发 Lazy 逻辑的运算，并且返回这个结果 —— Lazy 用作属性代理时逻辑也是如此。</p><p>接下来我们做下实验，首先定义两个函数用于提供条件值并通过打印输出来判断其是否被执行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">returnFalse</span><span class="params">()</span></span> = <span class="literal">false</span>.also &#123; println(<span class="string">&quot;returnFalse called.&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">returnTrue</span><span class="params">()</span></span> = <span class="literal">true</span>.also &#123; println(<span class="string">&quot;returnTrue called.&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>接下来我们调用 assertAllTrue 来看看会发生什么：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertAllTrue(lazy &#123; returnFalse() &#125;, lazy &#123; returnTrue() &#125;)</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">returnFalse called.</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>不意外吧？我们还可以模拟 <code>||</code> 再实现一个类似的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">assertAnyTrue</span><span class="params">(<span class="keyword">vararg</span> conditions: <span class="type">Lazy</span>&lt;<span class="type">Boolean</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> conditions.any &#123; it.value &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要有一个为真就立即返回 true，后面的条件就不再计算了。大家可以自己试试给它传几个参数之后看看能得到什么结果。</p><p>简单来说，Kotlin 的 Lazy 是一个很普通的类，它可以承载 Kotlin 当中各种对于延迟计算的需求的实现，用在属性定义上时借用了属性代理的语法，用作函数参数时就使用高阶函数 lazy 来构造或者直接传入函数作为参数即可。</p><p>除了使用 Lazy 包装真实的值来实现延迟求值，我们当然也可以使用函数来做到这一点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">assertAllTrue</span><span class="params">(<span class="keyword">vararg</span> conditions: () -&gt; <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> conditions.all &#123; it.invoke() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，我们传入的参数就是一个函数，延迟计算的意图也更加明显：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertAllTrue(&#123; returnFalse() &#125;, ::returnTrue, ::returnFalse)</span><br></pre></td></tr></table></figure><p>对于符合参数类型要求的 returnTrue 和 returnFalse 这两个函数，我们既可以直接传入函数引用，也可以构造一个 Lambda 表达式来包装对它们的调用。传入函数作为参数来实现延迟计算是最基本的手段，其他语言的处理也无非就是在此基础上增加一些友好的语法，后面我们在 Scala 和 Swift 部分就可以看到。</p><h2 id="Scala-的延迟求值"><a href="#Scala-的延迟求值" class="headerlink" title="Scala 的延迟求值"></a>Scala 的延迟求值</h2><p>在 Scala 当中 lazy 是个关键字。而相比之下，在 Kotlin 当中我们提到 Lazy 是指类型，提到 lazy，则是指构造 Lazy 对象的高阶函数。</p><p>Kotlin 当中的 Lazy 用在定义属性时，只支持只读属性或变量上（也就是 val 修饰的属性或变量），这一点 Scala 的用法比较类似，下面是一个比较无聊的例子，不过倒是能说明问题：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeConsumingWork</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> stopTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"><span class="keyword">val</span> startTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">timeConsumingWork()</span><br><span class="line">println(stopTime - startTime)</span><br></pre></td></tr></table></figure><p>我们想要统计下 timeConsumingWork 这个函数的调用耗时，stopTime 虽然先调用，但因为有 lazy 修饰，实际上等号右面的表达式 <code>System.currentTimeMillis()</code> 并没有立即执行，反而是后定义的 startTime 因为没有被 lazy 修饰而立即计算出值。所以这个程序还真能基本正确地输出 timeConsumingWork 函数执行的耗时。</p><p>哇，这样看起来 Scala 使用 lazy 关键字定义属性的语法比起 Kotlin 要简单多了哎！不过换个角度，乍一看明明有一行代码放在前面却没有立即执行是不是会很怪呢？如果一时间没有注意到 lazy 关键字，代码阅读起来还真是有点儿令人迷惑呢。</p><p>我们接着看看函数参数延迟求值的情况。在 Scala 当中同样存在高阶函数，因此我们几乎可以依样画葫芦写出 assertAllTrue 的 Scala 实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertAllTrue</span></span>(conditions: (() =&gt; <span class="type">Boolean</span>)*): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    conditions.forall(_.apply())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>() =&gt; Boolean</code> 就是 Scala 中返回值为 Boolean 类型的函数类型，后面的 * 表示这是个变长参数；函数体当中我们对所有的条件进行遍历，并在 forall 当中调用 apply 来求出对应 condition 的值，这里的 forall 相当于 Kotlin 当中的 all，apply 相当于 Kotlin 当中函数的 invoke。</p><p>用法如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertAllTrue(returnFalse, returnTrue, () =&gt; returnFalse())</span><br></pre></td></tr></table></figure><p>注意到我们既可以直接把函数名作为值传入，这类似于 Kotlin 当中传入函数引用的做法，最后一个参数 <code>() =&gt; returnFalse()</code> 则是定义了一个 Lambda 表达式来包装到 returnFalse 函数的调用。</p><p>Hmmm，这么看起来跟 Kotlin 真是一模一样啊。</p><p>非也非也。Scala 的函数参数除了可以传递值以外，还有一种叫做传名参数，即仅在使用时才会触发求值的参数。我们还是以前面的 assertAllTrue 为例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertBothTrue</span></span>(left: =&gt; <span class="type">Boolean</span>, right: =&gt; <span class="type">Boolean</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    left &amp;&amp; right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可惜的是，Scala 的传名参数不支持变长参数，所以例子有点儿缩水，不过不影响说明问题。</p><p>函数体内的最后一行就是函数的返回值，所以 <code>left &amp;&amp; right</code> 的值就是 assertBothTrue 的返回值了；而 left 和 right 的参数类型长得有点儿奇怪，如果说它是 Boolean 吧，可它的类型前面还有个 <code>=&gt;</code>，说它是函数类型吧， <code>=&gt;</code> 前面也没有参数呀，而且用起来跟 Boolean 类型的变量看起来也没什么两样 —— 对喽，这就是传名参数，只有访问时才会计算参数的值，访问的方式与普通的变量没有什么区别，不过每次访问都会重新计算它的值，这一点又与函数的行为相同。</p><p>接下来我们看下怎么使用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertBothTrue(returnFalse(), returnTrue())</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><p>我们看到传参时也没什么特别之处，直接传就好了，与我们通常的认知的不同之处在于，assertBothTrue 调用时不会立即对它的参数求值，所以其实这样看起来确实不太直观（这大概是 Kotlin 设计者最不喜欢 Scala 的地方了。。）。</p><p>整体比较起来，Scala 对延迟求值做了语言级别的正式支持，因此语法上更省事儿，有些情况下代码显得也更自然。</p><p>哦，对了，例子缩水的问题其实也是有办法解决的，哪有 Scala 解决不了的问题呢。。。：）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanByName</span>(<span class="params">value: =&gt; <span class="type">Boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valueByName</span></span>: <span class="type">Boolean</span> = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertAllTrue</span></span>(conditions: <span class="type">BooleanByName</span>*): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    conditions.forall(_.valueByName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路也简单，既然 Scala 不支持把传名参数声明为变长参数，那么我们就换个其他类型，巧就巧在 Scala 还支持类型隐式转换，所以定义一个 BooleanByName 即可，这样我们调用 assertAllTrue 传的参数就可以是 Boolean 类型的表达式，编译器会帮我们自动转换为 BooleanByName 类型丢给 assertAllTrue 函数。BooleanByName 中的 valueByName 是一个函数，Scala 当中对于不修改类内部状态的无参函数通常声明成没有括号的样子，这样的函数调用时如同访问属性一样（ 如代码中的 <code>_.valueByName</code>），这在 Kotlin 当中的等价写法就是一个没有 backingfield 的只读属性的 getter。</p><h2 id="Swift-的延迟求值"><a href="#Swift-的延迟求值" class="headerlink" title="Swift 的延迟求值"></a>Swift 的延迟求值</h2><p>最近比较喜欢 Swift，因为跟 Kotlin 长得像啊。不过随着了解的深入，发现二者虽然看起来很像，但用起来差异太大了，至少在延迟求值这个语法特性的设计上，Swift 形式上更像 Scala。</p><p>Swift 的 lazy 也是一个关键字，可以修饰类的属性，不过它不支持修饰局部变量，因此我们只能：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> value <span class="operator">=</span> complicatedComputing()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">complicatedComputing</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="operator">...</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难想到，只要第一次访问 value 时，complicatedComputing 才会被调用。从延迟求值的角度来讲与 Scala 是没什么差别的，不过大家仔细看会发现我们声明属性时用的是 var，也就是说 value 是可变的，这与 Scala、Kotlin 都不一样。更有趣的是，如果我们希望 value 是只读的，将它的声明改为 <code>lazy let value = ...</code>，Swift 编译器会抱怨说 lazy 只能修饰 var。</p><p>纳尼？你们这些语言的设计者是怎么回事，意见居然这么不统一？</p><p>其实 Swift 当中对于变量的读写有更严格的设计，这一点从 struct 与 class 的差异就可见一斑。而 lazy 之所以只能修饰 var，原因也很简单，声明的时候 value 虽然还没有初始化，但在后续访问的时候会触发求值，因此存在声明之后再赋值的逻辑。Hmmm，这个赋值行为从语言运行的角度来讲确实如此，可是这个逻辑不应该对开发者是透明的么，为什么要让开发者操心这么多？</p><p>当然，如果想要保护 lazy 修饰的属性的写权限，可以考虑私有化 setter：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">private(set)</span> <span class="keyword">lazy</span> <span class="keyword">var</span> value <span class="operator">=</span> <span class="operator">...</span></span><br></pre></td></tr></table></figure><p>但类内部仍然可以修改 value 的值，所以这个方法的作用也很有限。</p><p>接下来看下 Swift 当中函数参数的延迟求值。不难想到，我们将函数作为参数传入就可以实现这一点：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertAllTrue</span><span class="params">(<span class="keyword">_</span> conditions: <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span> <span class="operator">...</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    conditions.allSatisfy &#123; condition <span class="keyword">in</span> condition() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体上写法与 Kotlin 类似，不过有几个细节我们来解释下。</p><ul><li>参数 conditions 前面的下划线，一般语言的参数都只有参数名，也就是 conditions，Swift 还有一个参数标签的概念，用于函数调用时指定（其实我们在 Kotlin 当中调用函数时也可以在参数前加参数名，但作为位置参数时不强制），用下划线可以省略掉这个标签。</li><li><code>() -&gt; Bool</code> 表示 Swift 当中的函数类型，这与 Kotlin 的写法基本一致，后面的 … 则表示这个参数为变长参数。</li><li><code>&#123; condition in condition() &#125;</code> 是 Swift 当中的 Lambda （在 Swift 当中称为 Closure，其实是一个东西），完整的写法是 <code>&#123; (condition: () -&gt; Bool) in condition() &#125;</code>，不难看出，in 是用来分隔参数列表和表达式体的，condition 是参数，它的类型是 <code>() -&gt; Bool</code>。</li></ul><p>好，那我们下面调用一下这个函数试试看：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> assertAllTrue(&#123; returnFalse() &#125;, returnTrue, returnFalse)</span><br></pre></td></tr></table></figure><p>第一个参数使用 Lambda 表达式包装对 returnFalse 函数的调用；后面的两个参数直接使用函数名传入，这类似于 Kotlin 当中的函数引用的用法。结果不言而喻。</p><p>这么看来 Swift 也可以通过传入函数来实现延迟求值。有了前面 Scala 的经验，我们就不免要想，函数参数延迟求值的写法上能否进一步简化呢？答案是能，通过 @autoclosure 来实现。不过不巧的是 @autoclosure 也不支持变长参数（嗯？？这句话好像在哪儿听到过？），所以我们的例子就又缩水成了下面这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertBothTrue</span><span class="params">(<span class="keyword">_</span> left: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>, <span class="keyword">_</span> right: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    left() <span class="operator">&amp;&amp;</span> right()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那调用时有什么不一样呢？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> assertBothTrue(returnFalse(), returnTrue())</span><br></pre></td></tr></table></figure><p>我们直接传入表达式，Swift 会帮我们用 <code>&#123;&#125;</code> 把它包装起来，换句话说，参数里面的 returnFalse 和 returnTrue 这两个函数只有用到的时候才会被调用。</p><p>简单总结一下，Swift 通过 lazy 关键字来实现类属性的延迟求值，这一点写法上虽然与 Scala 很像，但只能修饰类或结构体的成员，而且是可读写的成员；Swift 同样可以通过传入函数的形式来支持函数参数的延迟求值，可以通过 @autoclosure 来简化调用过程中参数的写法，这一点其实从形式上与 Scala 的传名参数类似。</p><h2 id="再来一个有趣的例子"><a href="#再来一个有趣的例子" class="headerlink" title="再来一个有趣的例子"></a>再来一个有趣的例子</h2><p>当语言设计地足够灵活，基于已有的语法经常也能造出“新特性”，接下来我们就造一个。</p><p>常见的语言当中都有 <code>while</code> 循环，为什么没有 <code>whileNot</code> 呢？聪明的我们想到了这一点，于是就开始造语法了。先来看看 Kotlin 怎么实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">whileNot</span><span class="params">(condition: () -&gt; <span class="type">Boolean</span>, action: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!condition()) &#123;</span><br><span class="line">        action()</span><br><span class="line">        whileNot(condition, action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">whileNot(&#123; i &lt; <span class="number">0</span> &#125;)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出就是 10 9 … 0</p><p>Scala 呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whileNot</span></span>(condition: =&gt; <span class="type">Boolean</span>)(action: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition) &#123;</span><br><span class="line">        action</span><br><span class="line">        whileNot(condition)(action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能让第二个参数用 <code>&#123; ... &#125;</code> 以类似于 Kotlin 的方式传入，我们用柯里化的方式声明了这个函数，来瞧瞧用法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">whileNot(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>矮？是不是有那味了？这看着跟 while 已经没差了。</p><p>下面是 Swift 的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whileNot</span><span class="params">(<span class="keyword">_</span> condition: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>, <span class="keyword">_</span> action: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="operator">!</span>condition() &#123;</span><br><span class="line">        action()</span><br><span class="line">        whileNot(condition(), action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我似乎已经感觉到了那味儿~</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">whileNot(i <span class="operator">&lt;</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么样，Swift 造出来的 whileNot 也几乎可以以假乱真了。</p><p>看来真的只有你家 Kotlin “稍逊一筹” 啊，条件那里还必须加个 <code>&#123;&#125;</code>，没有语法糖可以将这个去掉。不过，（咳咳，官方口吻）Kotlin 一向不喜欢偷偷摸摸的，我们必须要保留 <code>&#123;&#125;</code> 让你一眼就能看出来那是个函数，而不像某些语言搞得那么暧昧。</p><p>其实吧，单从这个例子的角度来讲，函数的参数类型声明还是挺清楚的，现在 IDE 这么牛逼，所以支持一下这样的特性算不算违反 Kotlin 的设计原则其实也不一定，不过目前看来这种不痛不痒的小特性还是算了吧，跨平台才是最牛逼的，加油 Kotlin，我等着 Android Studio 5.0 写 iOS 呢（zZZ）。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下：</p><ol><li>Kotlin 没有 lazy 关键字，通过属性代理实现只读属性的延迟求值，而 Scala 和 Swift 则通过 lazy 关键字来做到这一点</li><li>Kotlin 和 Scala 对于属性的延迟求值只支持只读属性，Swift 只支持可变属性</li><li>Kotlin 和 Scala 的延迟求值还支持局部变量，Swift 不支持。</li><li>他们仨都支持通过传入函数的方式来实现函数参数的延迟求值。</li><li>Scala 和 Swift 对函数参数延迟求值在语法上有更友好的支持，前者通过传名参数，后者通过 @autoclosure。</li><li>Kotlin 是唯一一个通过其他特性顺带支持了一下延迟求值的，这很符合 Kotlin 设计者的一贯做法（(⊙o⊙)…）。</li></ol><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“懒”是程序员最优秀的品质之一，程序也是如此。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="scala" scheme="https://www.bennyhuo.com/tags/scala/"/>
    
      <category term="lazy" scheme="https://www.bennyhuo.com/tags/lazy/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 的 Property Delegate 与 Swift 的 Property Wrapper</title>
    <link href="https://www.bennyhuo.com/2020/05/08/kotlin-swift-property-delegate/"/>
    <id>https://www.bennyhuo.com/2020/05/08/kotlin-swift-property-delegate/</id>
    <published>2020-05-07T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.993Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Swift 的属性代理，见识一下 </p></blockquote><a id="more"></a><p>Swift 想必大家都已经非常熟悉了，它是苹果公司推出的一门开源语言。Swift 与 Kotlin 几乎是同一段时间开始研发，也是前后呈现在公众面前。二者语法设计上有诸多相似之处，它们的关系让我甚至想到了当年的 Java 和 C#。更神奇的是，Kotlin-Native 居然支持了与 Objective-C 的互调用，进而也就相当于某种意义上支持了与 Swift 的互调用，这下它们就更亲密了。</p><blockquote><p>Swift：我不是我没有别瞎说。</p></blockquote><p>本文我们来聊聊二者的属性代理的设计和使用。通过对比，我们能够更加清楚的认识到属性代理的设计意图，以及其优势和不足，此外我们还能够了解更多属性代理这一语法特性的使用场景。</p><h2 id="Kotlin-的属性代理（Property-Delegate）"><a href="#Kotlin-的属性代理（Property-Delegate）" class="headerlink" title="Kotlin 的属性代理（Property Delegate）"></a>Kotlin 的属性代理（Property Delegate）</h2><p>我们先来简单回顾下 Kotlin 的属性代理的一些基础知识和应用场景。</p><h3 id="简化存储的读写"><a href="#简化存储的读写" class="headerlink" title="简化存储的读写"></a>简化存储的读写</h3><p>Kotlin 的属性代理算是大多数开发者在学习过程中会遇到的一个小难点。这其实让我一直都感到比较意外，因为属性代理本身应该是一个很自然的需求，例如我们经常在 Android 当中会读写 SharedPreference，一个 Key 对应于一个 Value，读写的过程高度相似且繁琐：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="comment">// write</span></span><br><span class="line"><span class="keyword">val</span> prefs = context.getSharedPreferences(prefName, Context.MODE_PRIVATE)</span><br><span class="line">prefs.putString(key, value)</span><br><span class="line">prefs.apply()</span><br><span class="line"></span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="keyword">val</span> value = prefs.getString(key, defaultValue)</span><br></pre></td></tr></table></figure><p>这当中还经常需要定义一堆常量作为 key 的值，无论从代码编写的舒适度上还是从代码的编写效率上来看都不是最理想的状态。</p><p>实际上，如果我们把 SharedPreference 看成是类似内存一样的存储空间，那么为什么我们不能像读写内存中的变量那样轻松自在呢？于是乎我们通过属性代理将 SharedPreference 的读写操作做一下封装，实现了使用对变量的读写方式来读写 SharedPreference 的效果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loginName <span class="keyword">by</span> pref(context, default = <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// save &quot;bennyhuo&quot; as key &quot;loginName&quot;</span></span><br><span class="line">loginName = <span class="string">&quot;bennyhuo&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// load key &quot;loginName&quot; from SharedPreferences</span></span><br><span class="line"><span class="keyword">val</span> currentLoginName = loginName </span><br></pre></td></tr></table></figure><p>请大家注意，<code>pref</code> 是一个函数，它有一个泛型参数可以通过第二个函数参数的类型推导出来。对 <code>loginName</code> 的读写等同于对 SharedPreferences 中的 “loginName” 这个 key 的读写，这个操作是不是非常方便？想要实现这样的功能也不需要太多的逻辑，我们以 <code>String</code> 为例给出实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Preference</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> context: Context, <span class="keyword">val</span> name: String, </span><br><span class="line">        <span class="keyword">val</span> default: T, <span class="keyword">val</span> prefName: String = <span class="string">&quot;default&quot;</span>) : ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> prefs <span class="keyword">by</span> lazy &#123; context.getSharedPreferences(prefName, Context.MODE_PRIVATE) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> findPreference(findProperName(property), default)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        putPreference(findProperName(property), value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findProperName</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;)</span></span> = <span class="keyword">if</span>(name.isEmpty()) property.name <span class="keyword">else</span> name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;U&gt;</span> <span class="title">findPreference</span><span class="params">(name: <span class="type">String</span>, default: <span class="type">U</span>)</span></span>: U = with(prefs) &#123;</span><br><span class="line">        <span class="keyword">val</span> res: Any = <span class="keyword">when</span> (default) &#123;</span><br><span class="line">            <span class="keyword">is</span> String -&gt; getString(name, default)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res <span class="keyword">as</span> U</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;U&gt;</span> <span class="title">putPreference</span><span class="params">(name: <span class="type">String</span>, value: <span class="type">U</span>)</span></span> = with(prefs.edit()) &#123;</span><br><span class="line">        <span class="keyword">when</span> (value) &#123;</span><br><span class="line">            <span class="keyword">is</span> String -&gt; putString(name, value)</span><br><span class="line">            ...</span><br><span class="line">        &#125;.apply()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他数据类型的支持大家可以根据需要自行扩展。</p><p>属性代理的本质就是 <code>getValue</code> 和 <code>setValue</code> 这两个方法，这里的代码实现了 <code>ReadWriteProperty</code> 这个接口，不过这不是必须的，我们当然也可以改成下面的样子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Preference</span>&lt;<span class="type">T</span>&gt;</span>(...) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> findPreference(findProperName(property), default)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        putPreference(findProperName(property), value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 <code>getValue</code> 和 <code>setValue</code> 还是运算符方法，其实这里我们甚至可以把它们定义成扩展方法，只要方法的类型符合要求就可以。</p><p>既然如此，那我们是不是还可以对 Java 的 <code>Properties</code> 文件提供类似的支持呢？当然。我们同样可以通过被代理的属性名来查询对应 key 在 <code>Properties</code> 文件中的值，这个逻辑与 SharedPreferences 如出一辙，大家有兴趣可以参考这里：<a href="https://github.com/enbandari/QCloudImageUploaderForMarkDown/blob/master/src/main/kotlin/com/bennyhuo/qcloud/prop/AbsProperties.kt">AbsProperties.kt</a>。</p><p>官网在介绍属性代理的时候还给出了 Map 作为属性代理的用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name : String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age  : <span class="built_in">Int</span>    <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在很早的时候还专门写过一篇文章来介绍这个用法：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484018&idx=1&sn=170499992c0f29d9304eeddc4379f34e&chksm=e8a05d4fdfd7d459d7e75fa987eda85b39d43ce9b2ea5c8d2b8c884efc7b0431ae39b3c9c22f&token=397611765&lang=zh_CN#rd">用 Map 为你的属性做代理</a>。其实 <code>Map</code> 也是一种存储的方式，这与前面提到的 SharedPreferences 又有什么区别呢？</p><p>这样的例子我们还能列举很多，如数据库读写、文件读写甚至网络读写等等。</p><h3 id="控制属性的生命周期"><a href="#控制属性的生命周期" class="headerlink" title="控制属性的生命周期"></a>控制属性的生命周期</h3><p>标准库中也提供了 Lazy、Observable 这样的属性代理实现，它们与前面的简化存储的写法不同，二者分别代表了控制、监听属性的读写的使用场景。Lazy 的例子想必大家已经见过很多了，我们可以通过 Lazy 代理属性的初始化逻辑，确保只有在第一次访问时才会对属性进行初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textView <span class="keyword">by</span> lazy &#123; rootView.findViewById(R.id.text) &#125;</span><br></pre></td></tr></table></figure><p>我们对属性进行延迟初始化的理由总是会有很多，例如初始化可能比较耗时，依赖的其他成员尚未初始化等等。</p><p>我们再来看个例子。</p><p>Kotlin 当中的变量类型分为可空和不可空，定义时必须明确其类型，例如下面例子中的 image：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> image: Bitmap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        image = <span class="literal">null</span> <span class="comment">// Error!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>image</code> 在定义时如果定义为 <code>Bitmap?</code>，那么在不需要的时候自然是可以置为 <code>null</code> 的，只不过用的时候每次都需要判空，感觉就很让人难受。而如果定义成 <code>Bitmap</code>，用的时候倒是省事儿了，可是最后我们又无法将其置为 <code>null</code>。怎么办？</p><p>有人说你这个是伪需求，不置为 <code>null</code> 也不会有内存泄露。不过，<code>Activity</code> 经常在 <code>onStop</code> 调用之后还会存续一段时间才会被销毁，对应的 <code>Bitmap</code> 对象也要晚一段时间才能被释放，不置为 <code>null</code> 似乎并不是一个最优的选择。不管怎样，如果我们就是想要把这个 <code>Bitmap</code> 对象（或者其他什么对象）置为空，又想不影响开发体验，似乎是不可行的。</p><p>但如果我们用属性代理来控制对象的内部逻辑呢：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> image <span class="keyword">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        <span class="comment">// release the Bitmap instance.</span></span><br><span class="line">        ::image.release() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过 <code>releasableNotNull</code> 函数来创建这样一个属性代理，这个属性代理的工作就是提供一个真正的属性存储，可读可写可释放，它的实现并不复杂：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">releasableNotNull</span><span class="params">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> value ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Not Initialized or released already.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span> = value != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isAccessible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">&quot;Delegate is null or is not an instance of ReleasableNotNull.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过对属性代理类 <code>ReleasableNotNull</code> 实现了对真正存储值的 <code>value</code> 的代理，前面对 <code>image</code> 的访问实际上就是对 <code>value</code> 的访问，而 <code>value</code> 的类型又是可空的，因此我们实现了既可将属性置为 <code>null</code> 又可将属性 <code>image</code> 声明为不可空的 <code>Bitmap</code> 类型的需求。</p><p>这个小功能已经开源并上传到 jcenter，大家可以通过配置依赖 <code>com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0</code> 来使用它，也可以直接到我的 GitHub 上查看它的源码：<a href="https://github.com/enbandari/ReleasableVar">ReleasableVar</a>，源码当中我也给出了不依赖 Kotlin 反射的实现方法。</p><blockquote><p>例子当中的 <code>KProperty0&lt;R&gt;.release</code> 扩展方法实际上是为被代理的属性的引用添加了一个扩展，其中使用反射可以获取到代理对象，这样我们就可以使用 <code>::image.release()</code> 来实现对 image 背后的值的置空。请大家留意我们获取属性代理对象的方式，这在 Kotlin 当中需要用到反射；后面我们会看到， Swift 则直接提供了更好的语法来支持这样的功能。</p></blockquote><h3 id="代理其他类属性或者方法"><a href="#代理其他类属性或者方法" class="headerlink" title="代理其他类属性或者方法"></a>代理其他类属性或者方法</h3><p>前面的例子都比较直观，我们再给大家看一个更复杂的用法。</p><p>假设我们现在有这么一类，它有一些方法和属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapped</span></span>(<span class="keyword">var</span> x: <span class="built_in">Boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> z = <span class="number">10L</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setY</span><span class="params">(y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getY</span><span class="params">()</span></span> = <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的实例会被包在另一个类当中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Boolean</span> = ...</span><br><span class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span> = ...</span><br><span class="line">    <span class="keyword">val</span> z: <span class="built_in">Long</span> = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>Wrapper</code> 类当中还想把 <code>Wrapped</code> 类的一些成员暴露给外部调用者，可能的实现就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = wrapped.x</span><br><span class="line">        <span class="keyword">set</span>(value) &#123; wrapped.x = value &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的写法并不是很简洁，我们可以通过属性代理实现这样的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">by</span> wrapped::x.delegator()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性代理本质上就是 <code>setValue</code> 和 <code>getValue</code>，所以代理 getter 和 setter <code>也是顺理成章。delegator</code> 函数是 <code>x</code> 的属性引用的扩展成员，定义也不复杂：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> KProperty0<span class="type">&lt;T&gt;</span>.<span class="title">delegator</span><span class="params">(initializedValue: <span class="type">T</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">    : ReadWriteProperty&lt;Any, T&gt;</span><br><span class="line">        = ObjectPropertyDelegate0(</span><br><span class="line">            propertyRef = <span class="keyword">this</span> <span class="keyword">as</span> PropertyReference, </span><br><span class="line">            initializedValue = initializedValue</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectPropertyDelegate0</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> getter: (() -&gt; T), </span><br><span class="line">        <span class="keyword">val</span> setter: ((T) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span>, </span><br><span class="line">        initializedValue: T? = <span class="literal">null</span>) : ReadWriteProperty&lt;Any, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        propertyRef: PropertyReference, </span><br><span class="line">        initializedValue: T? = <span class="literal">null</span></span><br><span class="line">        ): <span class="keyword">this</span>(</span><br><span class="line">            (propertyRef <span class="keyword">as</span> KProperty0&lt;T&gt;)::<span class="keyword">get</span>, </span><br><span class="line">            <span class="keyword">if</span> (propertyRef <span class="keyword">is</span> KMutableProperty0&lt;*&gt;) (propertyRef <span class="keyword">as</span> KMutableProperty0&lt;T&gt;)::<span class="keyword">set</span> <span class="keyword">else</span> <span class="literal">null</span>, initializedValue</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        initializedValue?.let &#123; setter?.invoke(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> getter.invoke()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        setter?.invoke(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有点儿像请求转发一样，对 <code>Wrapper</code> 的属性 <code>x</code> 的读写直接转发给了 <code>Wrapped</code> 的属性 <code>x</code> 。既然我们把属性拆解开看做是 getter 和 setter，那么所有符合此类特征的函数也是可以被代理的，因此对于 <code>Wrapped</code> 的 <code>getY</code> 也可以代理成一个只读属性，<code>setY</code> 也可以单独代理成一个可变属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> y <span class="keyword">by</span> wrapped::setY.delegator(defaultValue = <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> yGetter <span class="keyword">by</span> wrapped::getY.delegator()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>getY</code> 的代理比较容易理解。对于 <code>setY</code> 的代理就有些奇怪了，属性 <code>y</code> 只代理了 <code>wrapped::setY</code>，那读取 <code>y</code> 的值时从哪儿获取呢？这其实也不难做到，我们可以通过属性代理提供一个 backingfield 来保存这个值就可以了。其实对于 setter 的代理的场景还真有，例如对于 Android 中某些 <code>View</code> 的属性只有 setter 的方法，没有对应的 getter，如果我想要做一个属性动画，那么这样的属性代理就会比较有帮助。</p><p>当然，类似的扩展我们还可以做很多，甚至支持 lazy：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> delegateLazyOf(TextView::getText, TextView::setText) &#123; textView &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们前面的例子当中 <code>wrapped</code> 从一开始就被初始化了，而这个例子当中 <code>textView</code> 需要等到 <code>Activity</code> 的 <code>onCreate</code> 调用之后才会初始化，因此 <code>lazy</code> 就显得非常必要了。具体实现就不一一列举了，有兴趣的朋友可以参考我的 GitHub 项目：<a href="https://github.com/enbandari/ObjectPropertyDelegate">ObjectPropertyDelegate</a>，大家也可以通过引入 <code>com.bennyhuo.kotlin:delegates:1.0</code> 来直接使用它。</p><p>需要补充说明的一点是，根据 Kotlin 官方最新发布的博客来看，从 Kotlin 1.4-M2 开始会直接支持使用属性代理其他属性，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> newName: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">   <span class="meta">@Deprecated(<span class="meta-string">&quot;Use &#x27;newName&#x27; instead&quot;</span>, ReplaceWith(<span class="meta-string">&quot;newName&quot;</span>)</span>)</span><br><span class="line">   <span class="keyword">var</span> oldName: <span class="built_in">Int</span> <span class="keyword">by</span> <span class="keyword">this</span>::newName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上与我们前面使用属性代理其他属性问题的处理上如出一辙。其实这个写法只不过是为 <code>KProperty0&lt;R&gt;</code> 实现了 <code>getValue</code> 和 <code>setValue</code> 扩展，我们在 Kotlin 1.4 以前的版本自己就可以实现这样的效果，只需要添加以下扩展即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">get</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KMutableProperty0<span class="type">&lt;R&gt;</span>.<span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">R</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">set</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个用法实际上也进一步说明了 Kotlin 对属性代理类本身没有类型要求的好处，如果强制属性代理类实现某一个接口的话，那这个效果就只能通过修改 <code>KProperty0</code> 的继承结果来实现了。当然，官方给出的这个例子还直接展示了这个特性的一个使用场景，即属性重命名。</p><h2 id="Swift-的属性包装器（Property-Wrapper）"><a href="#Swift-的属性包装器（Property-Wrapper）" class="headerlink" title="Swift 的属性包装器（Property Wrapper）"></a>Swift 的属性包装器（Property Wrapper）</h2><p>Swift 的属性包装器其实就是属性代理，最早推出这个特性的时候实际上也叫做 Property Delegate，但设计者们觉得 Property Wrapper 更贴切它的实际用法和含义，加上 Delegate 这个词在 Swift 当中（或者说更早的 Objective-C 当中）已经有了非常确切的含义，因此改成了Property Wrapper。这个名字看上去确实比属性代理表达出来的意图更加明显。</p><p>大家也可以参考 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#user-defaults">Swift 的属性包装器的设计文档</a>，文档中详细列出了一些使用场景和方法，以及一些设计细节，这其中绝大多数的使用场景我们也可以通过 Kotlin 的属性代理在 Kotlin 当中实现。</p><p>这个特性在 Swift 5 才推出，可以说是非常晚了。说来也有趣，在它的设计文档中还特意 “diss” 了 Kotlin 的属性代理的语法设计：单独为了属性代理搞了一个 by 关键字实在是有些重，在其他场景下也不太好复用，于是 Swift 的属性包装器采用了与 Java/Kotlin 的注解类似的长相的设计。</p><h3 id="代理-UserDefaults"><a href="#代理-UserDefaults" class="headerlink" title="代理 UserDefaults"></a>代理 UserDefaults</h3><p><code>UserDefaults</code> 是苹果家族的平台上通用的类似于 SharedPreferences 的配置存储，也是 key-value 的形式进行读写，我们可以使用属性包装器来进行代理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserDefault</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> defaultValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UserDefaults</span>.standard.object(forKey: key) <span class="keyword">as?</span> <span class="type">T</span> <span class="operator">??</span> defaultValue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="type">UserDefaults</span>.standard.set(newValue, forKey: key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>@PropertyWrapper</code> 将 <code>UserDefault</code> 声明为一个属性包装器，我们很自然想到要提供 getter 和 setter 的实现，Swift 通过 <code>wrappedValue</code> 这个计算属性来做到这一点，这样对于被包装的属性的访问其实就转发到对 <code>wrappedValue</code> 的访问上。用法也很直接：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalSettings</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UserDefault</span>(key: <span class="string">&quot;FOO_FEATURE_ENABLED&quot;</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isFooFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@UserDefault</span>(key: <span class="string">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子就是设计文档中的例子，大家可以在 Swift 5.2 当中运行测试。</p><p>稍微提一句，在 Swift 中，struct 是值类型，class 是引用类型，对于属性包装器来讲，二者都是可以的，用哪个取决于具体需求。</p><p>除了语法形式的不同之外，从功能上，Swift 的属性包装器的 wrappedValue 相当于 Kotlin 的属性代理的 <code>getValue</code> 和 <code>setValue</code> 的实现，不同之处在于 Kotlin 在 <code>getValue</code> 和 <code>setValue</code> 中提供了 <code>KProperty</code> 这个参数，我们可以通过它来获取对应属性的一些元信息，最常用的就是 name，所以我们在前面使用 Kotlin 代理 SharedPreferences 的例子当中完全可以不用主动传入 key 的值。</p><p>相比之下，Kotlin 的属性代理的语法更加自由，我们可以轻松地模拟 Swift 的写法来实现属性代理，主要以下是 Kotlin 代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PropertyWrapper</span>&lt;<span class="type">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: Value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: Value = wrappedValue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">Value</span>)</span></span> &#123;</span><br><span class="line">        wrappedValue = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这个思路，实现具体的属性代理，只需要实现这个接口并覆写即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObservableDelegate</span>&lt;<span class="type">Value</span>&gt;</span>(</span><br><span class="line">    initializedValue: Value,</span><br><span class="line">    <span class="keyword">val</span> changedListener: (previous: Value, current: Value) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : PropertyWrapper&lt;Value&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> wrappedValue: Value = initializedValue</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">val</span> previous = field</span><br><span class="line">            field = value</span><br><span class="line">            changedListener(previous, value)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法没有什么特殊之处：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> state: <span class="built_in">Int</span> <span class="keyword">by</span> ObservableDelegate(<span class="number">0</span>) &#123; previous, current -&gt;</span><br><span class="line">    println(<span class="string">&quot;changed <span class="variable">$previous</span> -&gt; <span class="variable">$current</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">state = <span class="number">2</span> <span class="comment">// changed 0 -&gt; 2</span></span><br><span class="line">state = <span class="number">3</span> <span class="comment">// changed 2 -&gt; 3</span></span><br><span class="line">state = <span class="number">4</span> <span class="comment">// changed 3 -&gt; 4</span></span><br></pre></td></tr></table></figure><h3 id="属性包装器的-projectedValue"><a href="#属性包装器的-projectedValue" class="headerlink" title="属性包装器的 projectedValue"></a>属性包装器的 projectedValue</h3><p>我是在学 Swift UI 的时候才开始接触到 Swift 的属性包装器的。Swift UI 就是使用 Swift 代码直接布局的写法，这种写法现在比较流行，例如 Flutter 的 Dart， Android 上之前的 Kotlin Anko 以及现在的 Compose。</p><p>我们来看一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isEnabled: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(isOn: <span class="variable">$isEnabled</span>) &#123;</span><br><span class="line">            isEnabled <span class="operator">?</span> <span class="type">Text</span>(<span class="string">&quot;Click to disable&quot;</span>).foregroundColor(.red)</span><br><span class="line">                : <span class="type">Text</span>(<span class="string">&quot;Click to enable&quot;</span>).foregroundColor(.green)</span><br><span class="line">        &#125;.padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>body</code> 是布局的 View，里面只有一个控件就是一个开关 <code>Toggle</code>，它需要与 <code>isEnabled</code> 这个属性绑定，UI 的效果如下：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-23.png"></p><p><strong><center>isEnabled 为 false 时的 UI</center></strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-42.png"></p><p><strong><center>isEnabled 为 true 时的 UI</center></strong></p><p><code>isEnabled</code> 这个属性被 <code>State</code> 这个属性包装器包装，<code>State</code> 为它提供了一个 <code>projectedValue</code> 的属性，这个 <code>projectedValue</code> 可以通过 <strong><code>$</code> + 属性名</strong> 来获取，也就是说作为 <code>Toggle</code> 的参数 <code>isOn</code> 的 <code>$isEnabled</code> 实际上就是 <code>isEnabled</code> 这个属性的包装器提供的 <code>projectValue</code>。</p><p>这个 <code>projectedValue</code> 实际上也是一个属性包装器，它的类型是 <code>Binding&lt;Bool&gt;</code>，<code>Binding</code> 这个属性包装器的作用比较直接，类似于我们前面介绍 Kotlin 的属性代理时提到的 <code>wrapped::x.delegator()</code>，它的作用就是提供了属性的 getter 和 setter，这样我们将 <code>Binding&lt;Bool&gt;</code> 对象传给 <code>Toggle</code> 的时候，它就可以在其中方便的修改 <code>isEnabled</code> 这个属性了。</p><p><code>State</code> 当然还提供了与 View 的刷新机制相关的逻辑，它实现了 <code>DynamicProperty</code> 协议，可以在属性被修改时调用 <code>update</code> 方法来刷新 UI。</p><p>下面我们给出 <code>State</code> 的声明，具体实现没有开源，但可以想到的是在 <code>wrappedValue</code> 的 setter 调用时一定会触发 <code>DynamicProperty</code> 协议的 <code>update</code> 方法的调用，<code>projectedValue</code> 则是返回一个包装了被 <code>State</code> 包装的属性的 getter 和 setter 的对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">@frozen</span> <span class="keyword">@propertyWrapper</span> <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">State</span>&lt;<span class="title">Value</span>&gt; : <span class="title">DynamicProperty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Initialize with the provided initial value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(wrappedValue value: <span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Initialize with the provided initial value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(initialValue value: <span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The current state value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123; <span class="keyword">get</span> <span class="keyword">nonmutating</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Produces the binding referencing this state value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> projectedValue: <span class="type">Binding</span>&lt;<span class="type">Value</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们考虑下 Kotlin 当中是否存在对应的特性。</p><p>对于 <code>Binding</code> 的使用场景，Kotlin 当中大可不必这么大费周章，因为 Kotlin 的属性引用可以很方便的允许我们传递一个属性的 setter 和 getter，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isEnabled: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get property reference</span></span><br><span class="line"><span class="keyword">val</span> view = View()</span><br><span class="line"><span class="keyword">val</span> isEnabledRef = view::isEnabled</span><br><span class="line"></span><br><span class="line"><span class="comment">// operate on property reference</span></span><br><span class="line">isEnabledRef.<span class="keyword">set</span>(<span class="literal">true</span>)</span><br><span class="line">println(isEnabledRef.<span class="keyword">get</span>())</span><br></pre></td></tr></table></figure><p>也就是说，Swift UI 当中的 <code>Binding</code> 在当中可以使用 Kotlin 的属性引用来替代，以上代码也不需要额外引入 Kotlin 反射。</p><p>但可以确定的是，Kotlin 当中没有 <code>projectedValue</code> 这样的特性，即便我们在前面模拟 Swift 声明的 <code>PropertyWrapper</code> 接口中添加这样的属性，我们也没有直接的类似于 <code>$isEnabled</code> 这样的语法来获取它。不仅如此，在 Kotlin 当中想要获取属性代理对象本身也不是一件轻松的事情，而在 Swift 当中我们可以使用 <code>projectedValue</code> 直接返回自身（也可以返回别的，例如 <code>State</code> 中就没有返回自己，而是返回了 <code>Binding</code>）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserDefault</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> defaultValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> projectedValue: <span class="type">UserDefault</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalSettings</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UserDefault</span>(key: <span class="string">&quot;FOO_FEATURE_ENABLED&quot;</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isFooFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@UserDefault</span>(key: <span class="string">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.isBarFeatureEnabled) </span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDefault&lt;Bool&gt;(key: &quot;BAR_FEATURE_ENABLED&quot;, defaultValue: false)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.<span class="variable">$isBarFeatureEnabled</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.<span class="variable">$isBarFeatureEnabled</span>.wrappedValue) </span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDefault&lt;Bool&gt;(key: &quot;BAR_FEATURE_ENABLED&quot;, defaultValue: false)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.<span class="variable">$isBarFeatureEnabled</span>.projectedValue) </span><br></pre></td></tr></table></figure><p>实际上如果是在被包装的属性所在的类内部，我们还可以直接拿到包装属性的实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalSettings</span> </span>&#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@UserDefault</span>(key: <span class="string">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getIsBarFeatureEnabledWrapper</span><span class="params">()</span></span> -&gt; <span class="type">UserDefault</span>&lt;<span class="type">Bool</span>&gt; &#123;</span><br><span class="line">        _isBarFeatureEnabled</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <code>_isBarFeatureEnabled</code> 得到的就是包装 <code>isBarFeatureEnabled</code> 的实例。</p><p>而这在 Kotlin 当中我们就只能通过反射来做到这一点了。不知道大家是否注意到我们用 Kotlin 属性代理实现的 ReleasableVar 这个组件中用到了 Kotlin 反射方法 <code>getDelegate</code> 来获取属性代理对象，即便我们可以接受使用反射这个前提，但它返回的类型 <code>Any?</code> 也同样不如 Swift 当中可以通过 <code>$</code> 直接获取 <code>projectedValue</code> 以及通过 <code>_</code> 获取属性包装器实例来的直接和安全。更何况 <code>getDelegate</code> 这个反射方法目前只能在 JVM 上使用，无法实现多平台。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="class"><span class="keyword">interface</span> <span class="title">KProperty0</span>&lt;<span class="type">out R</span>&gt; : <span class="type">KProperty</span>&lt;<span class="type">R</span>&gt;, <span class="type"></span></span>() -&gt; R &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of the delegate if this is a delegated property, or `null` if this property is not delegated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SinceKotlin(<span class="meta-string">&quot;1.1&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDelegate</span><span class="params">()</span></span>: Any?</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，我们在 Kotlin 当中可以直接把属性代理对象先定义出来，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"><span class="keyword">val</span> delegate = ObservableDelegate(<span class="number">0</span>) &#123; previous, current -&gt;</span><br><span class="line">    println(<span class="string">&quot;changed <span class="variable">$previous</span> -&gt; <span class="variable">$current</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> state <span class="keyword">by</span> delegate</span><br></pre></td></tr></table></figure><p>但这个写法又显得 <code>delegate</code> 与 <code>state</code> 的联系没有那么紧密，因此 Swift 的属性包装器在 <code>projectedValue</code> 的设计上为开发者提供了更大的发挥空间。</p><p>Kotlin 的规划和提议方面也暂时没有看到有类似的设计，如果我们想要在 Kotlin 当中也实现类似于 <code>projectedValue</code> 的功能，也许可以借助一下 Kotlin 编译器插件来完成。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>属性代理或者属性包装器本质上提供了把读写操作简化成对变量的读写的可能性，能够提供更大程度上的抽象，简化程序的代码重复度。</p><p>Kotlin 的属性代理的语法结构没有类型上的强制约束，只要实现 <code>getValue</code> 和 <code>setValue</code> 这两个方法即可用作属性代理的对象，没有实现接口的限制可以为已有的类型提供更多的扩展可能性；不过，获取一个属性的代理对象的方式不是特别友好，一方面需要使用到反射，另一方面获取到的类型是 <code>Any?</code>，没有静态类型的约束。</p><p>相比之下 Swift 的属性包装器提供了类似的能力，也通过提供 projectedValue 可以衍生出更多灵活的用法。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Swift 的属性代理，见识一下 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="property" scheme="https://www.bennyhuo.com/tags/property/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Native 写 Jni 第三弹：改造成 MPP 的工程结构</title>
    <link href="https://www.bennyhuo.com/2020/04/19/kotlin-native-android-mpp/"/>
    <id>https://www.bennyhuo.com/2020/04/19/kotlin-native-android-mpp/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.979Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。 </p></blockquote><a id="more"></a><p>在读这篇文章之前，大家可以去参考下之前的文章：</p><ul><li><a href="https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/">用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏</a></li><li><a href="https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/">Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法</a></li></ul><p>之前两篇文章已经介绍了如何通过 <code>CName</code> 注解来限定 Kotlin-Native 代码编出来的动态链接库的符号名，以实现与 Java 的 native 方法的绑定，也介绍了如何使用 <code>JNI_OnLoad</code> 来动态注册 native 方法来实现绑定。换句话说，如果你想要知道如何用 Kotlin-Native 写 Android 的 Jni 的 Native 层代码，那么前面的两篇文章里面就有答案。</p><p>前文撰写的时候 Kotlin-Native 的构建插件尚未稳定，当时除了 Multiplatform Project（以下简称 mpp） 的 Gradle 插件以外还有一个单独的 native 的插件，用法也不是特别统一，现在后者已经被废弃，因此我们只需要用 mpp 的插件来构建 Kotlin-Native 的工程即可。顺带提一句，现在使用 Kotlin DSL 来编写 Gradle 脚本体验已经比之前强多了，建议大家把 IDE 的 Kotlin 插件升级到 1.3.70 以上版本来体验。</p><p>接下来我们就把之前的工程改造一下，工程源码见：<a href="https://github.com/enbandari/hello-kni">hello-kni</a>。</p><p>首先我们创建一个 Module，你可以选择使用 IntelliJ 的 new module 方式，选择创建一个 Android library，当然也可以自己创建一个目录，然后再创建一个 build.gradle.kts 文件，就像这样：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-08-37-45.png"></p><p>接着，在 settings.gradle.kts 当中引入这个 Module：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="string">&quot;:app&quot;</span>, <span class="string">&quot;:nativeLib&quot;</span>)</span><br></pre></td></tr></table></figure><p>好，关键来了，剩下的主要就是修改 build.gradle.kts。我们先来添加 mpp 的 Gradle 插件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">&quot;multiplatform&quot;</span>) version <span class="string">&quot;1.3.71&quot;</span></span><br><span class="line">    id(<span class="string">&quot;com.android.library&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到我们还添加了 Android 的 library 插件，原因是我们想要把 Kotlin-Native 编译出来的 so 打进一个 aar 里面作为 Android 的依赖提供给 app 工程。</p><p>所以构建出来的 so 文件我们需要引入到 aar 的编译流程中，可以将这个 so 文件复制到一个路径，我们把这个路径添加为 Android 的 jniLibs 路径即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jniLibDir = File(project.buildDir, arrayOf(<span class="string">&quot;generated&quot;</span>, <span class="string">&quot;jniLibs&quot;</span>).joinToString(File.separator))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        <span class="keyword">val</span> main <span class="keyword">by</span> getting &#123;</span><br><span class="line">            jniLibs.srcDir(jniLibDir)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 build 目录下选了 generated/jniLibs 作为 jniLibs 目录添加到了 aar 的编译流程中。接下来我们只需要完成 so 文件的复制即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kotlin &#123;</span><br><span class="line">    androidNativeArm32 &#123;</span><br><span class="line">        binaries &#123;</span><br><span class="line">            sharedLib(<span class="string">&quot;knlib&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(buildType == NativeBuildType.RELEASE)&#123;</span><br><span class="line">                    linkTask.doLast &#123;</span><br><span class="line">                        copy &#123;</span><br><span class="line">                            from(outputFile)</span><br><span class="line">                            into(File(jniLibDir, <span class="string">&quot;armeabi-v7a&quot;</span>))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    afterEvaluate &#123;</span><br><span class="line">                        <span class="keyword">val</span> preReleaseBuild <span class="keyword">by</span> tasks.getting</span><br><span class="line">                        preReleaseBuild.dependsOn(linkTask)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin mpp 的工程配置非常清晰：</p><ol><li>内部的第一层是选择目标平台，这里选择的是 androidNativeArm32，当然如果你想要构建 iOS 平台的，也可以选择 iosArm64 等等。</li><li>第二层是 binaries 就是定义产出物，其内部的 sharedLib 表示产出物是共享库（shared object，so），当然如果希望编译出可执行文件，就替换成 executable。sharedLib 有两个参数，第一个是库的名字，我们这里与原来保持了一致，将库的名字指定为 knlib，这样编译出来的 so 文件就是 libknlib.so。</li><li>我们通过 buildType 来选择将 RELEASE 的产出物复制到指定路径（也就是刚才定义的 jniLibDir），如果做得更完善的话也可以分别对 DEBUG/RELEASE 进行处理。</li><li>为 aar 的构建流程中的 preReleaseBuild 任务添加依赖，这样在 assembleRelease 执行时可以触发对 Kotlin-Native 代码的编译。当然，这里也可以选择其他的任务进行依赖，只要能够在 assemble 时触发编译即可。</li></ol><p>工程配置搞定之后，我们还需要把源码添加进来。androidNativeArm32 的源码路径默认为 src/androidNativeArm32Main/kotlin，因此我们把之前已经写好的 Kotlin-Native 的源文件添加进去即可：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-18-01-24.png"></p><p>另外作为 Android Library 工程，manifest 文件当然是必须的，不过里面也不需要有什么特别的配置。</p><p>至此，使用 Kotlin-Native 编写 Jni 的工程改造就完成了，在 app 工程中添加依赖：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(project(<span class="string">&quot;:nativeLib&quot;</span>))</span><br></pre></td></tr></table></figure><p>直接编译运行 app 工程即可运行，再也不用使用命令行编译啦。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="kotlin-native" scheme="https://www.bennyhuo.com/tags/kotlin-native/"/>
    
      <category term="mpp" scheme="https://www.bennyhuo.com/tags/mpp/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 新版本也有了交叉类型和联合类型？</title>
    <link href="https://www.bennyhuo.com/2020/04/06/kotlin-intersect-type/"/>
    <id>https://www.bennyhuo.com/2020/04/06/kotlin-intersect-type/</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。 </p></blockquote><a id="more"></a><p>Kotlin 1.4-m1 发布之后，我曾整理了一下官方博客中提到的语法更新，见 <a href="https://www.bennyhuo.com/2020/03/26/kotlin-1.4-preview/">Kotlin 1.4 新特性预览</a>。除了前面的文章中提到的变化，新类型推导算法对于我们平常的代码编写的提升实际上还会体现在很多方面，接下来我们再为大家展示一个 case，来一起感受下新版本的厉害之处。</p><h2 id="1-分支表达式的类型推导问题"><a href="#1-分支表达式的类型推导问题" class="headerlink" title="1. 分支表达式的类型推导问题"></a>1. 分支表达式的类型推导问题</h2><p>先来看一段代码：</p><p><strong>代码清单 1：Kotlin 的分支表达式</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> number = <span class="keyword">if</span> (validation()) <span class="number">1F</span> <span class="keyword">else</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>请问 number 的类型是什么？</p><p>直觉告诉我们，number 的类型应该就是 Number 呀，因为两个分支分别是 Float 和 Double 类型，而 Number 是它俩的父类，因此是 Number 没毛病。</p><p>逻辑上确实如此，不过实际情况就要各种打脸了。你也许想不到，Float 还实现了一个 Comparable<Float> 的接口，而 Double 则实现了 Comparable<Double>，于是 Float 和 Double 应该同样是 Comparable 的子类才对。也就是说 Float 和 Double 有两个父类（接口），那么再想想，number 究竟是什么类型？Comparable 还是 Number？</p><p>都不是。Kotlin 1.3 当中，我们可以通过 IntelliJ 很容易的得到答案：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-13-42.png"></p><p><strong><center>图 1：Kotlin 1.3 对分支表达式的类型推导</center></strong></p><p>是不是很吃惊？居然是 Any。因为 Kotlin 编译器在类型推导时遇到这种模棱两可的情况实在不知道如何做出选择，因此干脆不选。</p><p>当然，如果你为 number 添加类型声明，例如：</p><p><strong>代码清单 2：为分支表达式添加类型信息</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> number: Number = <span class="keyword">if</span> (validation()) <span class="number">1F</span> <span class="keyword">else</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>这样 number 的类型就可以确定为 Number 了，Kotlin 编译器也算是松了一口气。</p><blockquote><p>有关这个问题的详细分析，我曾经在两年前写过一篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484051&idx=1&sn=4676580d88e9751df9a5ae192fd8d0da&chksm=e8a05daedfd7d4b8d7b7cc9201f287ba3f3206ddba246266c450c02d821959b99344e4cbf42c&token=482430266&lang=zh_CN#rd">val b = a?: 0，a 是 Double 类型，那 b 是什么类型？</a>，有兴趣的读者可以去了解下。</p></blockquote><h2 id="2-新类型推导算法的推导结果"><a href="#2-新类型推导算法的推导结果" class="headerlink" title="2. 新类型推导算法的推导结果"></a>2. 新类型推导算法的推导结果</h2><p>那么问题来了，新类型推导算法难道可以自动帮我们选择我们想要的类型嘛？额，说实话，这种情况下编译器并不知道你究竟想要什么类型，于是做出选择那是不可能的事儿了。既然做不出选择，那为什么还要选呢？小孩子才做选择，我当然是都要啊！</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-26-20.png"></p><p><strong><center>图 2：Kotlin 1.4 对分支表达式的类型推导</center></strong></p><p>这是什么情况？这个类型我没见过啊。确实如此，这样的类型我们也没有办法显式声明出来，只有靠编译器推导才能得到。那么这个 {A &amp; B} 的类型究竟算是什么类型呢？字面意思就是既是 A 类型，又是 B 类型，实际含义也是如此。也就是说，{Comparable{Double &amp; Float} &amp; Number} 这个类型既是 Comparable 类型，又是 Number 类型。</p><p>于是在 Kotlin 1.4 当中，以下代码就成了合法的用法：</p><p><strong>代码清单 3：Kotlin 1.4 中对于分支表达式类型的使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Number.<span class="title">compareTo</span><span class="params">(other: <span class="type">Number</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toDouble().compareTo(other.toDouble())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> number = <span class="keyword">if</span> (validation()) <span class="number">1F</span> <span class="keyword">else</span> <span class="number">2.0</span></span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$number</span> &gt; 2&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$number</span> &lt;= 2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在 Kotlin 1.3 当中默认会无法通过编译。</p><h2 id="3-交叉类型与联合类型"><a href="#3-交叉类型与联合类型" class="headerlink" title="3. 交叉类型与联合类型"></a>3. 交叉类型与联合类型</h2><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-49-34.png"></p><p><strong><center>图 3：Double 和 Float 的类型关系</center></strong></p><p>两个类型的交叉类型就是两个类型的交集，因此对于类型 A &amp; B，如果我们把 A 和 B 看做集合的话，相当于 A ∩ B。图 3 的含义其实还涉及到另一个概念：联合类型。对于文章开头的分支表达式，它的类型是 Double 或者 Float，即 Double | Float，这个类型就是一个联合类型，从集合的角度来讲实际上就是 Double ∪ Float。通俗的说，交叉类型是“既是 A 也是 B”的关系，联合类型则是“不是 A 就是 B”的关系。</p><p>既然如此，从图上来看，Comparable &amp; Number == Double | Float，因为我们前面讲到过，Double 和 Float 的公共父类（接口）包括 Comparable 和 Number。请注意，Kotlin 在表达联合类型时实际上是取了一个类型的近似值，这个值就是公共父类。</p><p>坦率地讲，Kotlin 当中的联合类型与真正理想的联合类型还是不一样的，我们给出 TypeScript 中的联合类型让大家感受下：</p><p><strong>代码清单 4：TypeScript 中的联合类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">    fly(): <span class="built_in">void</span>;</span><br><span class="line">    layEggs(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    swim(): <span class="built_in">void</span>;</span><br><span class="line">    layEggs(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"><span class="comment">// OK，两个类型的公共成员</span></span><br><span class="line">pet.layEggs();</span><br></pre></td></tr></table></figure><p>虽然 Bird 和 Fish 两个接口没有公共父接口，但 Bird | Fish 却有二者的公共成员 layEggs。如果这段代码放到 Kotlin 当中，结果可想而知：</p><p><strong>代码清单 5：Kotlin 的联合类型</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">layEggs</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">swim</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">layEggs</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> pet = <span class="keyword">if</span>(validation()) <span class="keyword">object</span> : Bird&#123; ... &#125; <span class="keyword">else</span> <span class="keyword">object</span> : Fish&#123; ... &#125;</span><br><span class="line">pet.layEggs() <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>这里 pet 理论上应该是 Bird | Fish，但 Kotlin 编译器总是会尝试将其类型“退化”成一个当前类型系统可表达的类型，这个退化的方法就是寻找二者的公共父类，即 Any。因此，Kotlin 编译器将分支表达式的类型推导为 Any，pet 自然无法直接访问 layEggs 了，尽管 Bird 和 Fish 都有这个函数。</p><p>按照 Kotlin 语言规范的说法，Kotlin 当中的交叉类型和联合类型都是不能直接声明的，只是会在某些语法现象中产生，例如类型智能转换等等。一旦产生了这样的类型，Kotlin 会采用类型近似、类型退化等手段来找到一个现有类型系统中合适的类型来表达它们。</p><h2 id="4-为什么不直接支持交叉类型和联合类型呢？"><a href="#4-为什么不直接支持交叉类型和联合类型呢？" class="headerlink" title="4. 为什么不直接支持交叉类型和联合类型呢？"></a>4. 为什么不直接支持交叉类型和联合类型呢？</h2><p>其实这个问题已经争论了挺久了。从各方的讨论来看，目前 Kotlin 没有正式引入这样的类型主要有以下原因：</p><ol><li>伪需求。支持引入这个特性的开发者提供的一些 use case 多数情况下可以通过诸如函数重载、泛型约束等特性来实现，有些情况下实际上更应该优化类型设计而不是寄希望于一个更复杂的类型系统。</li><li>存在滥用风险。类型系统复杂一点点，带来的项目代码的复杂度提升可能都会是巨大的。这一点从 Kotlin 对函数类型的支持上就可见一斑，当然不同之处在于函数类型确实是刚需。</li></ol><p>对于这个问题大家怎么看呢？留言说出你的看法吧。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="type" scheme="https://www.bennyhuo.com/tags/type/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 1.4 新特性预览</title>
    <link href="https://www.bennyhuo.com/2020/03/26/kotlin-1.4-preview/"/>
    <id>https://www.bennyhuo.com/2020/03/26/kotlin-1.4-preview/</id>
    <published>2020-03-25T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。 </p></blockquote><a id="more"></a><h2 id="1-安装-Kotlin-1-4"><a href="#1-安装-Kotlin-1-4" class="headerlink" title="1. 安装 Kotlin 1.4"></a>1. 安装 Kotlin 1.4</h2><p>Kotlin 1.4 的第一个里程碑版本发布了，具体发布信息可以在<a href="https://github.com/JetBrains/kotlin/blob/1.4-M1/ChangeLog.md">这里查看</a>。</p><p>生产环境当中最好仍然使用 Kotlin 的稳定版本（例如最新的 1.3.71），如果你想要立刻马上体验 1.4 的新特性，那么我的建议是先安装一个 EAP 版本的 IntelliJ IDEA EAP 版本是 IntelliJ IDEA 2020.1 Beta，然后再在这个版本的 IntelliJ 上安装最新版的 Kotlin 插件，这样既可以继续使用 1.3 做项目，又不耽误体验新特性：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-10-40.png"></p><p><strong><center>图 1：IntelliJ IDEA EAP 版本与正式版可以共存</center></strong></p><p>安装 Kotlin 1.4 的插件方法想必大家都已经轻车熟路了，打开设置，搜 Kotlin，找到插件版本管理的下拉菜单，选择 Early Access Preview 1.4.x 即可：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-20-21.png"></p><p><strong><center>图 2：升级 Kotlin 插件</center></strong></p><p>好了，重启 IntelliJ，新建一个工程试试看吧~~</p><h2 id="2-主要的语法更新"><a href="#2-主要的语法更新" class="headerlink" title="2. 主要的语法更新"></a>2. 主要的语法更新</h2><p>接下来我们就按照官方博客给出的介绍 <a href="https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-4-m1-released/">Kotlin 1.4-M1 Released</a> 来体验下新特性。</p><p>本文源码均已整理至 GitHub：<a href="https://github.com/enbandari/Kotlin1.4FeaturesSample">Kotlin1.4FeaturesSample</a>。</p><h3 id="2-1-Kotlin-接口和函数的-SAM-转换"><a href="#2-1-Kotlin-接口和函数的-SAM-转换" class="headerlink" title="2.1 Kotlin 接口和函数的 SAM 转换"></a>2.1 Kotlin 接口和函数的 SAM 转换</h3><p>一个就是大家期待已久的 Kotlin 接口和函数的 SAM 转换。得益于新的类型推导算法，之前一直只有调用接收 Java 单一方法接口的 Java 的方法时才可以有 SAM 转换，现在这个问题不存在了，且看例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意 fun interface 是新特性</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin 函数，参数为 Kotlin 单一方法接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runAction</span><span class="params">(a: <span class="type">Action</span>)</span></span> = a.run()</span><br><span class="line"><span class="comment">// Kotlin 函数，参数为 Java 单一方法接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runRunnable</span><span class="params">(r: <span class="type">Runnable</span>)</span></span> = r.run()</span><br></pre></td></tr></table></figure><p>在 1.4 以前，我们只能：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runAction(<span class="keyword">object</span>: Action&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Not good..&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runAction(Action &#123; println(<span class="string">&quot;Not good..&quot;</span>) &#125;)</span><br></pre></td></tr></table></figure><p>runRunnable 函数虽然接收的是 Java 的接口，同样不支持 SAM。</p><p>现在在 1.4 当中呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runAction &#123; println(<span class="string">&quot;Hello, Kotlin 1.4!&quot;</span>) &#125;</span><br><span class="line">runRunnable &#123; println(<span class="string">&quot;Hello, Kotlin 1.4!&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>真是妙啊。</p><h3 id="2-2-类型推导支持了更多的场景"><a href="#2-2-类型推导支持了更多的场景" class="headerlink" title="2.2 类型推导支持了更多的场景"></a>2.2 类型推导支持了更多的场景</h3><p>类型推导让 Kotlin 的语法获得了极大的简洁性。不过，大家在使用 Kotlin 开发时，一定会发现有些情况下明明类型是很确定的，编译器却一定要让我们显式的声明出来，这其实就是类型推导算法没有覆盖到的场景了。</p><p>例如以下代码在 Kotlin 1.3 当中会提示类型不匹配的问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rulesMap: Map&lt;String, (String?) -&gt; <span class="built_in">Boolean</span>&gt; = mapOf(</span><br><span class="line">    <span class="string">&quot;weak&quot;</span> to &#123; it != <span class="literal">null</span> &#125;,</span><br><span class="line">    <span class="string">&quot;medium&quot;</span> to &#123; !it.isNullOrBlank() &#125;,</span><br><span class="line">    <span class="string">&quot;strong&quot;</span> to &#123; it != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;^[a-zA-Z0-9]+$&quot;</span>.toRegex().matches(it) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-47-00.png"></p><p><strong><center>图 3：Kotlin 1.3 中提示类型不匹配</center></strong></p><p>博客原文中给出的这个例子乍一看挺复杂，仔细想想问题主要在于我们可以通过 rulesMap 的类型来确定 mapOf 的返回值类型，进而再确定出 mapOf 的参数类型，即 Pair 的泛型参数类型。类型信息是充分的，不过这段代码在 Kotlin 1.4 以前是无法通过编译的，应该是类型推导的层次有点儿多导致算法没有覆盖到。好在新的推导算法解决了这个问题，能够应付更加复杂的推导场景。</p><h3 id="2-3-Lambda-表达式最后一行的智能类型转换"><a href="#2-3-Lambda-表达式最后一行的智能类型转换" class="headerlink" title="2.3 Lambda 表达式最后一行的智能类型转换"></a>2.3 Lambda 表达式最后一行的智能类型转换</h3><p>这个比较容易理解，直接看例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = run &#123;</span><br><span class="line">    <span class="keyword">var</span> str = currentValue()</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">        str = <span class="string">&quot;test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    str <span class="comment">// the Kotlin compiler knows that str is not null here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The type of &#x27;result&#x27; is String? in Kotlin 1.3 and String in Kotlin 1.4</span></span><br></pre></td></tr></table></figure><p>这里 result 作为 run 的返回值，实际上也是 run 的参数 Lambda 的返回值，因此它的类型需要通过 str 的类型来推断。</p><p>在 1.3 当中，str 的类型是可以推断成 String 的，因为 str 是个局部变量，对它的修改是可控的。问题在于虽然 str 被推断为 String 类型，Lambda 表达式的返回值类型却没有使用推断的类型 String 来判断，而是选择使用了 str 的声明类型 String?。</p><p>在 1.4 解决了这个问题，既然 str 可以被推断为 String，那么 Lambda 表达式的结果自然就是 String 了。</p><p>稍微提一下，IntelliJ 的类型提示貌似有 bug，有些情况下会出现不一致的情况：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-12-55-09.png"></p><p><strong><center>图 4：疑似 IntelliJ 行内的类型提示的 bug</center></strong></p><p>我们可以通过快捷键查看 result 的类型为 String，但是行内的类型提示却为 String?，不过这个不影响程序的运行。</p><p>当然，有些开发者经常会抱怨类似下面的这种情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(x != <span class="literal">null</span>)&#123;</span><br><span class="line">        println(x.length) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我明明已经判断了 x 不为空，为什么却不能自动推导成 String？请一定要注意，这种情况不是类型推导算法的问题，而是 x 的类型确实无法推导，因为对于一个共享的可变变量来讲，任何前一秒的判断都无法作为后一秒的依据。</p><h3 id="2-4-带有默认参数的函数的类型支持"><a href="#2-4-带有默认参数的函数的类型支持" class="headerlink" title="2.4 带有默认参数的函数的类型支持"></a>2.4 带有默认参数的函数的类型支持</h3><p>如果一个函数有默认参数，我们在调用它的时候就可以不传入这个参数了，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span> = <span class="number">0</span>)</span></span>: String = <span class="string">&quot;<span class="variable">$i</span>!&quot;</span></span><br></pre></td></tr></table></figure><p>调用的时候既可以是 foo() 也可以是 foo(5)，看上去就如同两个函数一样。在 1.4 以前，如果我们想要获取它的引用，就只能获取到 (Int) -&gt; String 这样的类型，显得不是很方便，现在这个问题解决了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">apply1</span><span class="params">(func: () -&gt; <span class="type">String</span>)</span></span>: String = func()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">apply2</span><span class="params">(func: (<span class="type">Int</span>) -&gt; <span class="type">String</span>)</span></span>: String = func(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(apply1(::foo))</span><br><span class="line">    println(apply2(::foo))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过请注意，通常情况下 ::foo 的类型始终为 (Int) -&gt; String，除了作为参数传递给接收 () -&gt; String 的情况下编译器会自动帮忙转换以外，其他情况下是不可以的。</p><h3 id="2-5-属性代理的类型推导"><a href="#2-5-属性代理的类型推导" class="headerlink" title="2.5 属性代理的类型推导"></a>2.5 属性代理的类型推导</h3><p>在推断代理表达式的类型时，以往不会考虑属性代理的类型，因此我们经常需要在代理表达式中显式的声明泛型参数，下面的例子就是这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prop: String? <span class="keyword">by</span> Delegates.observable(<span class="literal">null</span>) &#123; p, old, new -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$old</span> → <span class="variable">$new</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    prop = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    prop = <span class="string">&quot;xyz&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子在 1.4 中可以运行，但如果是在 1.3 当中，就需要明确泛型类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prop: String? <span class="keyword">by</span> Delegates.observable&lt;String?&gt;(<span class="literal">null</span>) &#123; p, old, new -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$old</span> → <span class="variable">$new</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-混合位置参数和具名参数"><a href="#2-6-混合位置参数和具名参数" class="headerlink" title="2.6 混合位置参数和具名参数"></a>2.6 混合位置参数和具名参数</h3><p>位置参数就是按位置传入的参数，Java 当中只有位置参数，是大家最熟悉的写法。Kotlin 支持了具名参数，那么入参时二者混合使用会怎样呢？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-06-09.png"></p><p><strong><center>图 5：1.3 当中不允许在具名参数之后添加位置参数</center></strong></p><p>1.3 当中，第三个参数会提示错误，理由就是位置参数前面已经有了具名参数了，这是禁止的。这样主要的目的也是希望开发者能够避免写出混乱的入参例子，不过这个例子似乎并不会有什么令人疑惑的地方，于是 1.4 我们可以在具名参数后面跟位置参数啦。</p><p>其实这个特性并不会对入参有很大的影响。首先位置参数的位置仍然必须是对应的，其次具名参数的位置也不能乱来。例如我们为例子中的 a 添加一个默认值：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-16-35.png"></p><p><strong><center>图 6：1.4 当中具名参数之后添加位置参数需要保证位置对应</center></strong></p><p>注意图 6 是 1.4 环境下的情形，这样调用时我们就可以不必显式的传入 a 的值了，这时候直觉告诉我参数 b 后面的参数应该是 c，然而编译器却不领情。这样看来，即便是在 1.4 当中，我们也需要确保具名参数和位置参数与形参的位置对应才能在具名参数之后添加位置参数。</p><p>因此，我个人的建议是对于参数比较多且容易混淆的情形最好都以具名参数的形式给出，对于参数个数较少的情形则可以全部采用位置参数。在这里还有另外的一个建议就是函数的参数不宜过多，参数越多意味着函数复杂度越高，越可能需要重构。</p><h3 id="2-7-优化属性代理的编译"><a href="#2-7-优化属性代理的编译" class="headerlink" title="2.7 优化属性代理的编译"></a>2.7 优化属性代理的编译</h3><p>如果大家自己写过属性代理类的话，一定知道 get 和 set 两个函数都有一个 KProperty 的参数，这个参数其实就是被代理的属性。为了获取这个参数，编译器会生成一个数组来存放这代理的属性，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> lazyProp <span class="keyword">by</span> lazy &#123; <span class="number">42</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后生成的字节码反编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">bennyhuo</span>.<span class="title">kotlin</span>.<span class="title">MyOtherClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> kotlin.reflect.KProperty[] $$delegatedProperties;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getLazyProp</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> com.bennyhuo.kotlin.MyOtherClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 $$delegatedProperties 这个数组就是我们所说的存被代理的属性的数组。不过，绝大多数的属性代理其实不会用到 KProperty 对象，因此无差别的生成这个数组其实存在一定的浪费。</p><p>因此对于属性代理类的 get 和 set 函数实现为内联函数的情形，编译器可以确切的分析出 KProperty 是否被用到，如果没有被用到，那么就不会生成这个 KProperty 对象。</p><p>这里还有一个细节，如果一个类当中同时存在用到和没用到 KProperty 对象的两类属性代理，那么生成的数组在 1.4 当中只包含用到的 KProperty 对象，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> lazyProp <span class="keyword">by</span> lazy &#123; <span class="number">42</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> myProp: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;&lt;no name&gt;&quot;</span>) &#123;</span><br><span class="line">            kProperty, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;kProperty.name&#125;</span>: <span class="variable">$oldValue</span> -&gt; <span class="variable">$newValue</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 myProp 用到了 KProperty 对象，lazyProp 没有用到，那么生成的 $$delegatedProperties 当中就只包含 myProp 的属性引用了。</p><h3 id="2-8-参数列表最后的逗号"><a href="#2-8-参数列表最后的逗号" class="headerlink" title="2.8 参数列表最后的逗号"></a>2.8 参数列表最后的逗号</h3><p>这个需求别看小，非常有用。我们来看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(</span><br><span class="line">        <span class="string">&quot;bennyhuo&quot;</span>,</span><br><span class="line">        <span class="number">30</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person 类有多个参数，传参的时候就会出现前面的参数后面都有个逗号，最后一个没有。这样看上去好像也没什么问题是吧？那有可能你没有用到过多行编辑：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-04-01.png"></p><p><strong><center>图 7：多行编辑逗号的问题</center></strong></p><p>这里这个逗号有时候会特别碍事儿，但如何每一行都可以有一个逗号这个问题就简单多了：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-05-25.png"></p><p><strong><center>图 8：多行编辑所有参数</center></strong></p><p>除了这个场景之外，还有就是调整参数列表的时候，例如我给 Person 在最后加了个 id，我还得单独给 age 的参数后面加个逗号：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-08-36.png"></p><p><strong><center>图 9：增加参数给原来的参数加逗号</center></strong></p><p>这时候我又觉得 id 应该放到最前面，于是做了个复制粘贴，发现还是要修改逗号。当然，最后的这个功能 IntelliJ 有个快捷键可以直接交换行，同时帮我们自动处理逗号的问题，不过整体上这个小功能还是很有意思的。</p><p>说起来，JavaScript 当中的对象字面量当中也允许最后一个字段后面加逗号：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-12-48.png"></p><p><strong><center>图 10：JavaScript 的对象字面量</center></strong></p><p>不过请注意，尽管它与 JSON 有着深厚的渊源，但 JSON 的最后一个字段后面是不允许加逗号的（当然还有字段要加引号）。</p><h3 id="2-9-when-表达式中使用-continue-和-break"><a href="#2-9-when-表达式中使用-continue-和-break" class="headerlink" title="2.9 when 表达式中使用 continue 和 break"></a>2.9 when 表达式中使用 continue 和 break</h3><p>continue 和 break 的含义没有任何变化，这二者仍然在循环当中使用，只不过循环内部的 when 表达式当中在之前是不可以使用 continue 和 break 的，按照官方的说法，他们之前有意将 continue 或者 break 用作 when 表达式条件 fallthrough 的，不过看样子现在还没想好，只是不想再耽误 continue 和 break 的正常功能了。</p><h3 id="2-10-尾递归函数的优化"><a href="#2-10-尾递归函数的优化" class="headerlink" title="2.10 尾递归函数的优化"></a>2.10 尾递归函数的优化</h3><p>尾递归函数估计大家用的不多，这里主要有两个优化点</p><ul><li>尾递归函数的默认参数的初始化顺序改为从左向右：</li><li>尾递归函数不能声明为 open 的，即不能被子类覆写，因为尾递归函数的形式有明确的要求，即函数的最后一个操作必须只能是调用自己，父类的函数声明为 tailrec 并不能保证子类能够正确地按要求覆写，于是产生矛盾。</li></ul><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-25-23.png"></p><p><strong><center>图 11：1.4 中尾递归函数的默认参数列表初始化顺序</center></strong></p><h3 id="2-11-契约的支持"><a href="#2-11-契约的支持" class="headerlink" title="2.11 契约的支持"></a>2.11 契约的支持</h3><p>从 1.3 开始，Kotlin 引入了一个实验特性契约（Contract），主要来应对一些“显而易见”情况下的类型推导或者智能类型转换。</p><p>在 1.4 当中，这个特性仍然会继续保持实验状态，不过有两项改进：</p><ul><li>支持使用内联特化的函数来实现契约</li><li>1.3当中不能为成员函数添加契约，从1.4开始支持为 final 的成员函数添加契约（当然任意成员函数可能存在被覆写的问题，因而不能添加）</li></ul><h3 id="2-12-其他的一些改动"><a href="#2-12-其他的一些改动" class="headerlink" title="2.12 其他的一些改动"></a>2.12 其他的一些改动</h3><p>除了语法上的明显的改动之外，1.4 当中也直接移除了 1.1-1.2 当中协程的实验阶段的 API，有条件的情况下应该尽快去除对废弃的协程 API 的使用，如果暂时无法完成迁移，也可以使用协程的兼容包 kotlin-coroutines-experimental-compat.jar。</p><p>剩下的主要就是针对编译器、使用体验的各种优化了，实际上这才是 Kotlin 1.4 最重要的工作。这些内容相对抽象，我就不做介绍了。</p><p>补充一点，在本文撰写过程中，我使用 IntelliJ IDEA 2019.3.3 来运行 Kotlin 1.3，使用 IntelliJ IDEA 2020.1 BETA 来运行 Kotlin 1.4-M1，结果发现后者的代码提示速度似乎有明显的提升，不知道是不是我的错觉，大家可以自行感受下并发表你的评论。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>Kotlin 目前的语法已经比较成熟了，还是那句话，提升开发体验，扩展应用场景才是它现在最应该发力的点。</p><p>未来可期。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="news" scheme="https://www.bennyhuo.com/tags/news/"/>
    
      <category term="release" scheme="https://www.bennyhuo.com/tags/release/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(11) - Flow 篇</title>
    <link href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/"/>
    <id>https://www.bennyhuo.com/2020/03/14/coroutine-flow/</id>
    <published>2020-03-13T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。 </p></blockquote><a id="more"></a><p>随着 RxJava 的流行，响应式编程模型逐步深入人心。<code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物。</p><p><em>本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶段，后续也可能会发生细微的调整。</em></p><h2 id="认识-Flow"><a href="#认识-Flow" class="headerlink" title="认识 Flow"></a>认识 Flow</h2><p>介绍 <code>Flow</code> 之前，我们先来回顾下序列生成器：</p><p><strong>代码清单1： 序列生成器</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ints = sequence &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; </span><br><span class="line">    yield(it)</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次访问 <code>ints</code> 的下一个元素的时候它就执行内部的逻辑直到遇到 <code>yield</code>，如果我希望在元素之间加个延时呢？</p><p><strong>代码清单2：序列生成器中不能调用其他挂起函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ints = sequence &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; </span><br><span class="line">    yield(it)</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// ERROR!</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受 <code>RestrictsSuspension</code> 注解的约束，<code>delay</code> 不能在 <code>SequenceScope</code> 的扩展成员当中被调用，因而不能在序列生成器的协程体内调用了。</p><p>假设序列生成器不受这个限制，调用 <code>delay</code> 会导致后续的执行流程的线程发生变化，外部的调用者发现在访问 <code>ints</code> 的下一个元素的时候居然还会有切换线程的副作用，这个是不是算一个“惊喜”呢？不仅如此，我想通过指定调度器来限定序列创建所在的线程，同样是不可以的，我们甚至没有办法为它设置协程上下文。</p><p>既然序列生成器有这么多限制，那我们是时候需要认识一下 <code>Flow</code> 了。它的 API 与序列生成器极为相似：</p><p><strong>代码清单3：创建 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intFlow = flow &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; </span><br><span class="line">    emit(it)</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新元素通过 <code>emit</code> 函数提供，Flow 的执行体内部也可以调用其他挂起函数，这样我们就可以在每次提供一个新元素后再延时 100ms 了。</p><p>Flow 也可以设定它运行时所使用的调度器：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intFlow.flowOn(Dispatchers.IO)</span><br></pre></td></tr></table></figure><p>通过 <code>flowOn</code> 设置的调度器只对它之前的操作有影响，因此这里意味着 intFlow 的构造逻辑会在 <code>IO</code> 调度器上执行。</p><p>最终消费 <code>intFlow</code> 需要调用 <code>collect</code> 函数，这个函数也是一个挂起函数，我们启动一个协程来消费 <code>intFlow</code>：</p><p><strong>代码清单4： 消费 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(myDispatcher) &#123;</span><br><span class="line">  intFlow.flowOn(Dispatchers.IO)</span><br><span class="line">    .collect &#123; println(it) &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><p>为了区分调度器，我们为协程设置了一个自定义的调度器，它会将协程调度到名叫 <code>MyThread</code> 的线程上，结果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[MyThread] <span class="number">1</span></span><br><span class="line">[MyThread] <span class="number">2</span></span><br><span class="line">[MyThread] <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="对比-RxJava-的线程切换"><a href="#对比-RxJava-的线程切换" class="headerlink" title="对比 RxJava 的线程切换"></a>对比 RxJava 的线程切换</h2><p>RxJava 也是一个基于响应式编程模型的异步框架，它提供了两个切换调度器的 API 分别是 <code>subscribeOn</code> 和 <code>observeOn</code>：</p><p><strong>代码清单5：RxJava 的调度器切换</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; e -&gt;</span><br><span class="line">    it.onNext(e)</span><br><span class="line">  &#125;</span><br><span class="line">  it.onComplete()</span><br><span class="line">&#125;.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(Schedulers.from(myExecutor))</span><br><span class="line">.subscribe &#123;</span><br><span class="line">  println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>subscribeOn</code> 指定的调度器影响前面的逻辑，<code>observeOn</code> 影响的是后面的逻辑，因此 <code>it.onNext(e)</code> 执行在它的 <code>io</code> 这个调度器上，而最后的 <code>println(it)</code> 执行在通过 <code>myExecutor</code> 创建出来的调度器上。</p><p>Flow 的调度器 API 中看似只有 <code>flowOn</code> 与 <code>subscribeOn</code> 对应，其实不然， <code>collect</code> 所在协程的调度器则与 <code>observeOn</code> 指定的调度器对应。</p><p>在 RxJava 的学习和使用过程中， <code>subscribeOn</code> 和 <code>observeOn</code> 经常容易被混淆；而在 Flow 当中 <code>collect</code> 所在的协程自然就是观察者，它想运行在什么调度器上它自己指定即可，非常容易区分。</p><h2 id="冷数据流"><a href="#冷数据流" class="headerlink" title="冷数据流"></a>冷数据流</h2><p>一个 Flow 创建出来之后，不消费则不生产，多次消费则多次生产，生产和消费总是相对应的。</p><p><strong>代码清单6：Flow 可以被重复消费</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><p><code>intFlow</code> 就是本节最开始我们创建的 Flow，消费它会输出 1,2,3，重复消费它会重复输出 1,2,3。</p><p>这一点其实类似于我们前面提到的 <code>sequence</code> 和 RxJava 例子，它们也都有自己的消费端。我们创建一个序列然后去迭代它，每次迭代都会创建一个新的迭代器从头开始迭代；RxJava 的 <code>Observable</code> 也是如此，每次调用它的 <code>subscribe</code> 都会重新消费一次。</p><p>所谓<strong>冷</strong>数据流，就是只有消费时才会生产的数据流，这一点与 <code>Channel</code> 正对应：<code>Channel</code> 的发送端并不依赖于接收端。</p><blockquote><p><strong>说明</strong> RxJava 也存在热数据流，可以通过一定的手段实现冷热数据流的转化。不过相比之下，冷数据流的应用场景更为丰富。</p></blockquote><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Flow 的异常处理也比较直接，直接调用 <code>catch</code> 函数即可：</p><p><strong>代码清单7：捕获 Flow 的异常</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Div 0&quot;</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">&quot;caught error: <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 Flow 的参数中抛了一个异常，在 <code>catch</code> 函数中就可以直接捕获到这个异常。如果没有调用 <code>catch</code> 函数，未捕获异常会在消费时抛出。请注意，<code>catch</code> 函数只能捕获它的上游的异常。</p><p>如果我们想要在流完成时执行逻辑，可以使用 <code>onCompletion</code>：</p><p><strong>代码清单8：订阅流的完成</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Div 0&quot;</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">&quot;caught error: <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">&#125;.onCompletion &#123; t: Throwable? -&gt;</span><br><span class="line">  println(<span class="string">&quot;finally.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onCompletion</code> 用起来比较类似于 <code>try ... catch ... finally</code> 中的 <code>finally</code>，无论前面是否存在异常，它都会被调用，参数 <code>t</code> 则是前面未捕获的异常。</p><p>Flow 的设计初衷是希望确保流操作中异常透明。因此，以下写法是违反 Flow 的设计原则的：</p><p><strong>代码清单9：命令式的异常处理（不推荐）</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flow &#123; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    emit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Div 0&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (t: Throwable)&#123;</span><br><span class="line">    println(<span class="string">&quot;caught error: <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;finally.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在流操作内部使用 <code>try ... catch ... finally</code> 这样的写法后续可能被禁用。</p><p>在 RxJava 当中还有 <code>onErrorReturn</code> 类似的操作：</p><p><strong>代码清单10：RxJava 从异常中恢复</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> observable = Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;.onErrorReturn &#123;</span><br><span class="line">  println(t)</span><br><span class="line">  <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获异常后，返回 10 作为下一个值。</p><p>我们在 Flow 当中也可以模拟这样的操作：</p><p><strong>代码清单11：Flow 从异常中恢复</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Div 0&quot;</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">&quot;caught error: <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">  emit(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以使用 <code>emit</code> 重新生产新元素出来。细心的读者一定会发现，<code>emit</code> 定义在 <code>FlowCollector</code> 当中，因此只要遇到 Receiver 为 <code>FlowCollector</code> 的函数，我们就可以生产新元素。</p><blockquote><p><strong>说明</strong> onCompletion 预计在协程框架的 1.4 版本中会被重新设计，之后它的作用类似于 RxJava 中 Subscriber 的 onComplete，即作为整个 Flow 的完成回调使用，回调的参数也将包含整个 Flow 的未捕获异常，参见 GitHub Issue：<a href="https://github.com/Kotlin/kotlinx.coroutines/pull/1732">Breaking change: Experimental Flow.onCompletion contract for cause #1732</a>。</p></blockquote><h2 id="末端操作符"><a href="#末端操作符" class="headerlink" title="末端操作符"></a>末端操作符</h2><p>前面的例子当中，我们用 <code>collect</code> 消费 Flow 的数据。<code>collect</code> 是最基本的<strong>末端操作符</strong>，功能与 RxJava 的 <code>subscribe</code> 类似。除了 <code>collect</code> 之外，还有其他常见的末端操作符，大体分为两类：</p><ol><li>集合类型转换操作，包括 <code>toList</code>、<code>toSet</code> 等。</li><li>聚合操作，包括将 Flow 规约到单值的 <code>reduce</code>、<code>fold</code> 等操作，以及获得单个元素的操作包括 <code>single</code>、<code>singleOrNull</code>、<code>first</code> 等。</li></ol><p>实际上，识别是否为末端操作符，还有一个简单方法，由于 Flow 的消费端一定需要运行在协程当中，因此末端操作符都是挂起函数。</p><h2 id="分离-flow-的消费和触发"><a href="#分离-flow-的消费和触发" class="headerlink" title="分离 flow 的消费和触发"></a>分离 flow 的消费和触发</h2><p>我们除了可以在 <code>collect</code> 处消费 Flow 的元素以外，还可以通过 <code>onEach</code> 来做到这一点。这样消费的具体操作就不需要与末端操作符放到一起，<code>collect</code> 函数可以放到其他任意位置调用，例如：</p><p><strong>代码清单12：分离 Flow 的消费和触发</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createFlow</span><span class="params">()</span></span> = flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">      emit(it)</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.onEach &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  GlobalScope.launch &#123;</span><br><span class="line">    createFlow().collect()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此，我们又可以衍生出一种新的消费 Flow 的写法：</p><p><strong>代码清单13：使用协程作用域直接触发 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  createFlow().launchIn(GlobalScope)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>launchIn</code> 函数只接收一个 <code>CoroutineScope</code> 类型的参数。</p><h2 id="Flow-的取消"><a href="#Flow-的取消" class="headerlink" title="Flow 的取消"></a>Flow 的取消</h2><p>Flow 没有提供取消操作，原因很简单：不需要。</p><p>我们前面已经介绍了 Flow 的消费依赖于 <code>collect</code> 这样的末端操作符，而它们又必须在协程当中调用，因此 Flow 的取消主要依赖于末端操作符所在的协程的状态。</p><p><strong>代码清单14：Flow 的取消</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">  <span class="keyword">val</span> intFlow = flow &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">      delay(<span class="number">1000</span>)</span><br><span class="line">      emit(it)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">2500</span>)</span><br><span class="line">job.cancelAndJoin()</span><br></pre></td></tr></table></figure><p>每隔 1000ms 生产一个元素，2500ms 以后协程被取消，因此最后一个元素生产前 Flow 就已经被取消，输出为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">▶ 1000ms later</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>如此看来，想要取消 Flow 只需要取消它所在的协程即可。</p><h2 id="其他-Flow-的创建方式"><a href="#其他-Flow-的创建方式" class="headerlink" title="其他 Flow 的创建方式"></a>其他 Flow 的创建方式</h2><p>我们已经知道了 <code>flow &#123; ... &#125;</code> 这种形式的创建方式，不过在这当中无法随意切换调度器，这是因为 <code>emit</code> 函数不是线程安全的：</p><p><strong>代码清单15：不能在 Flow 中直接切换调度器</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flow &#123; <span class="comment">// BAD!!</span></span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  withContext(Dispatchers.IO)&#123;</span><br><span class="line">    emit(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在生成元素时切换调度器，就必须使用 <code>channelFlow</code> 函数来创建 Flow：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channelFlow &#123;</span><br><span class="line">  send(<span class="number">1</span>)</span><br><span class="line">  withContext(Dispatchers.IO) &#123;</span><br><span class="line">    send(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，我们也可以通过集合框架来创建 Flow：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asFlow()</span><br><span class="line">setOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asFlow()</span><br><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="Flow-的背压"><a href="#Flow-的背压" class="headerlink" title="Flow 的背压"></a>Flow 的背压</h2><p>只要是响应式编程，就一定会有背压问题，我们先来看看背压究竟是什么。</p><p>背压问题在生产者的生产速率高于消费者的处理速率的情况下出现。为了保证数据不丢失，我们也会考虑添加缓存来缓解问题：</p><p><strong>代码清单16：为 Flow 添加缓冲</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.buffer()</span><br></pre></td></tr></table></figure><p>我们也可以为 <code>buffer</code> 指定一个容量。不过，如果我们只是单纯地添加缓存，而不是从根本上解决问题就始终会造成数据积压。</p><p>问题产生的根本原因是生产和消费速率的不匹配，除直接优化消费者的性能以外，我们也可以采取一些取舍的手段。</p><p>第一种是 <code>conflate</code>。与 <code>Channel</code> 的 <code>Conflate</code> 模式一致，新数据会覆盖老数据，例如：</p><p><strong>代码清单17：使用 conflate 解决背压问题</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.conflate()</span><br><span class="line">.collect &#123; value -&gt;</span><br><span class="line">  println(<span class="string">&quot;Collecting <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">  delay(<span class="number">100</span>) </span><br><span class="line">  println(<span class="string">&quot;<span class="variable">$value</span> collected&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们快速地发送了 100 个元素，最后接收到的只有两个，当然这个结果每次都不一定一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting <span class="number">1</span></span><br><span class="line"><span class="number">1</span> collected</span><br><span class="line">Collecting <span class="number">99</span></span><br><span class="line"><span class="number">99</span> collected</span><br></pre></td></tr></table></figure><p>第二种是 <code>collectLatest</code>。顾名思义，只处理最新的数据，这看上去似乎与 <code>conflate</code> 没有区别，其实区别大了：它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p><p>还是前面的例子，我们稍作修改：</p><p><strong>代码清单18：使用 collectLatest 解决背压问题</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.collectLatest &#123; value -&gt;</span><br><span class="line">  println(<span class="string">&quot;Collecting <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">  delay(<span class="number">100</span>)</span><br><span class="line">  println(<span class="string">&quot;<span class="variable">$value</span> collected&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collecting 0</span><br><span class="line">Collecting 1</span><br><span class="line">...</span><br><span class="line">Collecting 97</span><br><span class="line">Collecting 98</span><br><span class="line">Collecting 99</span><br><span class="line">▶ 100ms later</span><br><span class="line">99 collected</span><br></pre></td></tr></table></figure><p>前面的 <code>Collecting</code> 输出了 0 ~ 99 的所有结果，而 <code>collected</code> 却只有 99，因为后面的数据到达时，处理上一个数据的操作正好被挂起了（请注意<code>delay(100)</code>）。</p><p>除 <code>collectLatest</code> 之外还有 <code>mapLatest</code>、<code>flatMapLatest</code> 等等，都是这个作用。</p><h2 id="Flow-的变换"><a href="#Flow-的变换" class="headerlink" title="Flow 的变换"></a>Flow 的变换</h2><p>我们已经对集合框架的变换非常熟悉了，<code>Flow</code> 看上去极其类似于这样的数据结构，这一点与 RxJava 的 <code>Observable</code> 的表现也基本一致。</p><p>例如我们可以使用 <code>map</code> 来变换 <code>Flow</code> 的数据：</p><p><strong>代码清单19：Flow 的元素变换</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123; </span><br><span class="line">  it * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以映射成其他 Flow：</p><p><strong>代码清单20：Flow 的嵌套</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123;</span><br><span class="line">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上得到的是一个数据类型为 <code>Flow</code> 的 <code>Flow</code>，如果希望将它们拼接起来，可以使用 <code>flattenConcat</code>：</p><p><strong>代码清单21：拼接 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123;</span><br><span class="line">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class="line">&#125;.flattenConcat()</span><br><span class="line">  .collect &#123; println(it) &#125;</span><br></pre></td></tr></table></figure><p>拼接的操作中 <code>flattenConcat</code> 是按顺序拼接的，结果的顺序仍然是生产时的顺序；还有一个是 <code>flattenMerge</code>，它会并发拼接，因此结果不会保证顺序。</p><h2 id="使用-Flow-实现多路复用"><a href="#使用-Flow-实现多路复用" class="headerlink" title="使用 Flow 实现多路复用"></a>使用 Flow 实现多路复用</h2><p>多数情况下，我们可以通过构造合适的 Flow 来实现多路复用的效果。</p><p>上一篇文章<a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程(10) - Select 篇</a>中对 await 的复用我们可以用 Flow 实现如下：</p><p><strong>代码清单22：使用 Flow 实现对 await 的多路复用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">coroutineScope &#123;</span><br><span class="line">  <span class="keyword">val</span> login = <span class="string">&quot;...&quot;</span></span><br><span class="line">  listOf(::getUserFromApi, ::getUserFromLocal) ... ①</span><br><span class="line">    .map &#123; function -&gt;</span><br><span class="line">      function.call(login) ... ②</span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123; deferred -&gt;</span><br><span class="line">      flow &#123; emit(deferred.await()) &#125; ... ③</span><br><span class="line">    &#125;</span><br><span class="line">    .merge() ... ④</span><br><span class="line">    .onEach &#123; user -&gt;</span><br><span class="line">      println(<span class="string">&quot;Result: <span class="variable">$user</span>&quot;</span>)</span><br><span class="line">    &#125;.launchIn(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中，① 处用创建了两个函数引用组成的 List；② 处调用它们得到 deferred；③ 处比较关键，对于每一个 deferred 我们创建一个单独的 Flow，并在 Flow 内部发送 deferred.await() 返回的结果，即返回的 User 对象；现在我们有了两个 Flow 实例，我们需要将它们整合成一个 Flow 进行处理，调用 merge 函数即可。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png"></p><p><strong>图1：使用 merge 合并 Flow</strong></p><p>同样的，对 Channel 的读取复用的场景也可以使用 Flow 来完成。对照<a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程(10) - Select 篇</a>，我们给出 Flow 的实现版本：</p><p><strong>代码清单23：使用 Flow 实现对 Channel 的复用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channels = List(<span class="number">10</span>) &#123; Channel&lt;<span class="built_in">Int</span>&gt;() &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> result = channels.map &#123;</span><br><span class="line">    it.consumeAsFlow()</span><br><span class="line">  &#125;</span><br><span class="line">  .merge()</span><br><span class="line">  .first()</span><br></pre></td></tr></table></figure><p>这比 <code>select</code> 的版本看上去要更简洁明了，每个 Channel 都通过 <code>consumeAsFlow</code> 函数被映射成 Flow，再 merge 成一个 Flow，取第一个元素。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Flow</code> 是协程当中比较重要的异步工具，它的用法与其他类似的响应式编程框架非常相近，大家可以采取类比的学习方式去了解它的功能。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Flow&lt;/code&gt; 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="flow" scheme="https://www.bennyhuo.com/tags/flow/"/>
    
      <category term="rxjava" scheme="https://www.bennyhuo.com/tags/rxjava/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 官网大变样？这是要干啥？</title>
    <link href="https://www.bennyhuo.com/2020/02/13/kotlin-news-202002/"/>
    <id>https://www.bennyhuo.com/2020/02/13/kotlin-news-202002/</id>
    <published>2020-02-12T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.978Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。 </p></blockquote><a id="more"></a><p>最近有小伙伴提醒我，Kotlin 官网更新了，我打开一看直接吓尿：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-34-00.png"></p><p>这是要干啥？我听说过的没听说过的您这是都要承包吗？</p><p>最有意思的是居然把 Android 放到了最后，hmmm，Kotlin 开发者里面搞 Android 的应该是最多的吧？这么不受待见？</p><p>所以我有个大胆的想法，Kotlin 团队肯定觉得 Android 大军切换 Kotlin 指日可待，基本上稳稳的，所以过河拆桥：Android 已经不再是 Kotlin 唯一的大腿啦，你们看看，最前面的是移动端跨平台，原来谷爸爸的大腿刚捂热乎，就又抱上了果爸爸，真是不得了哇：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-38-52.png"></p><p>其实很早之前我们就一直在聊到 Kotlin 2019 年的重心一定在 Native 上，当时觉得可能是盯上了 5G 时代的物联网的机会？不过一年过去了，5G 手机我还没用上，这不小米 10 刚发布，正琢磨要不要换个呢，嵌入式领域 C 称霸天下哪里会那么快换代，再说还有 Go 和 Rust 虎视眈眈，哪儿有 Kotlin 什么事儿。</p><p>不过从 Android 起家的 Kotlin 横向切入 iOS 这个路子真的是很合适，用户群体都不用怎么变，还让过去不会 iOS 的 Android 开发者有了更多更容易的机会扩展自己的技术栈，即可以扩大自己的影响力，又给开发者带来福利，真是双赢 666。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-17-54-20.png"></p><p>当然，这个移动端跨平台并不是什么特别新鲜的事儿，毕竟开源项目嘛，没事儿刷刷 Kotlin 的 <a href="https://kotl.in/slack">Slack</a>，啥都能提前知道。而且本身 Kotlin 跨平台共享代码从 1.2 刚开始公测就理论上包含了 Kotlin-Jvm@Android 和 Kotlin-Native@iOS 的代码共享能力，所以我们似乎不应该意外，我只是想说 JetBrains 居然把移动端跨平台专门上升到了这么高的优先级，还专门做了 Kotlin Native 与 Objective-C &amp; Swift 的互调用的支持，真是任性~~</p><p>如果过一段时间 Dukat 这个项目逐渐成熟，Kotlin-Js 的编译工具也进一步完善，特别是对 npm 依赖的管理能更加灵活（目前 Kotlin-js 的 Gradle 依赖当中不会自动携带 npm 依赖这个让人非常难受），JavaScript 常见的框架都有了自己的 Kotlin 接口声明，那时候我估计写到最前面的也许还会发生一些变化，那时候也许叫 “Kotlin for 大前端”？</p><p>说到这里有人担心 Kotlin 这是不是在跟 Flutter 叫板。显然不是嘛，Kotlin 跨平台一直都声称自己只是为了逻辑代码的共享，UI 大家还是用原生的就好啦。于是乎 Android 原来该用 ConstraintLayout 你就用你的 XML 布局，iOS 呢就还是用你的 storyboard。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-02-29.png"></p><p>Flutter 抢的是 UI 的饭碗，UI 层跨平台的问题解决了，有人就说我们底层的逻辑也选一套跨平台的方案好不好？这要是放到几年前，怕是没有别的选择了，C++ 是最好的语言；而现在，你可以选择 Kotlin，最为神奇的是 Kotlin 的跨平台和 C++ 的机制非常不同，它在 Android 上使用 Kotlin-Jvm，iOS 上则使用 Kotlin-Native。你要是非想在 Android 上使用 JNI 的话，Kotlin-Native 也已经支持了绝大多数 Android 的 CPU 架构。所以很早就有人发文章报告 Flutter + Kotlin-Native 实现移动端跨平台开发的优秀体验，所以 Flutter 该学就学，不矛盾。</p><p>而且它俩的这基友关系嘛。。。依我看，这 Logo 就已经说明一切了。。。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-06-19.png"></p><p>还有一个比较引人注目的就是 <strong>Data science</strong> 了吧。毕竟 Python 因为这个都火的不得了了，过去的一年里我已经鼓动我们组好几个小伙伴上手 Python，要恰饭的嘛，艺多不压身，免得错过一些项目的机会。现在好了，Kotlin 也能搞科学计算了，目测大概的切入思路暂时还是依托于强大的 Jvm，Java 能用的框架 Kotlin 自然能用，Java 不能直接用的，例如 Python numpy，可以 JNI 直接搞一个封装 <a href="https://github.com/Kotlin/kotlin-numpy">kotlin-numpy</a>；等 Kotlin Native 翅膀硬了之后就更省事儿了，直接跟 C 玩去，连 Jvm 都用不着了。这么发展着，最后也许是我的当然是我的，你的也是我的。。。</p><p>忘了说了，现在已经有了 Jupyter 的 Kotlin 内核，所以以前在 Jupyter Notebook 里用 Python 写的代码也可以用 Kotlin 写了，贴一张官网的效果图：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-16-54-47.png"></p><p>很美是吧，之前 KotlinConf 2019 期间官博就发了一篇文章介绍这个能力，也可以参考一下：Making Kotlin Ready for Data Science [<a href="https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/">原文</a>] [<a href="https://www.kotliner.cn/2020/01/making-kotlin-ready-for-data-science/">中文翻译</a>]。</p><p>顺便提一句，调用 GPU 其实也是 IO 操作，我看了几个 cuda 的程序都很有意思，要么是阻塞调用，要么就是异步调用之后在主流程里死循环等待结果返回。这似乎与我们的 Socket 读写类似，异步的 API 可能在大规模调用时性能更好，但代码编写起来更加复杂。前几天读到一篇论文讲的就是如何使用 C++ 的协程来降低 GPU 编程的复杂度(<a href="https://iopscience.iop.org/article/10.1088/1742-6596/681/1/012048/pdf">Integrating GPGPU computations with CPU coroutines in C++</a>)，随着 Kotlin Native 的逐渐成熟稳定，我们可以直接通过 C 接口编写 GPU 相关程序，Kotlin 协程也许可以为 GPU 编程带来一定的便利。</p><p>这么看来，预计在 2020年春天发布的 Kotlin 1.4 的形势也比较明朗了，正如 Kotlin 之父 Andrey 说的，这个版本没有什么太多的新特性。因为作为一门语言本身，Kotlin 已经比较成熟，现在最应当关注的是开发体验，开发效率，稳定性，易用性以及应用场景等等语言生态的内容。</p><p>我之前还比较担心 Kotlin Multiplatform 和 Kotlin Native 会不会借此机会正式发布，从官网的这次改动来看，这样的担心应该是多余的了。我们来回顾一下过去 Kotlin 的重要版本的发布时间：</p><ul><li>Kotlin 1.0：2016.2</li><li>Kotlin 1.1：2017.3（13个月之后）</li><li>Kotlin 1.2：2017.11（8个月之后）</li><li>Kotlin 1.3：2018.10（11个月之后）</li></ul><p>多数情况下 Kotlin 的大版本都是保持一年左右一个的（1.2 这个版本估计是趁着热度努力冲了一波 KPI，毕竟 2017 年 Kotlin 出名了），小版本大概两个月一个，所以一般小版本到 1.x.7 的时候也就是下一个大版本发布的时间。现在 1.3.70 已经 EAP 了一个多月了，你们懂我意思吧。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="news" scheme="https://www.bennyhuo.com/tags/news/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(10) - Select 篇</title>
    <link href="https://www.bennyhuo.com/2020/02/03/coroutine-select/"/>
    <id>https://www.bennyhuo.com/2020/02/03/coroutine-select/</id>
    <published>2020-02-02T16:00:00.000Z</published>
    <updated>2021-01-23T02:20:02.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。 </p></blockquote><a id="more"></a><h2 id="复用多个-await"><a href="#复用多个-await" class="headerlink" title="复用多个 await"></a>复用多个 await</h2><p>我们前面已经接触了很多挂起函数，那么如果我有这样一个场景，两个 API 分别从网络和本地缓存获取数据，期望哪个先返回就先用哪个做展示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">getUserFromApi</span><span class="params">(login: <span class="type">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class="line">    gitHubServiceApi.getUserSuspend(login)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">getUserFromLocal</span><span class="params">(login:<span class="type">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class="line">    File(localDir, login).takeIf &#123; it.exists() &#125;?.readText()?.let &#123; gson.fromJson(it, User::<span class="keyword">class</span>.java) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管先调用哪个 API 返回的 <code>Deferred</code> 的 <code>await</code>，都会被挂起，如果想要实现这一需求就要启动两个协程来调用 <code>await</code>，这样反而将问题复杂化了。</p><p>接下来我们用 <code>select</code> 来解决这个问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> localDeferred = getUserFromLocal(login)</span><br><span class="line">    <span class="keyword">val</span> remoteDeferred = getUserFromApi(login)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userResponse = select&lt;Response&lt;User?&gt;&gt; &#123;</span><br><span class="line">        localDeferred.onAwait &#123; Response(it, <span class="literal">true</span>) &#125;</span><br><span class="line">        remoteDeferred.onAwait &#123; Response(it, <span class="literal">false</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><p>大家可以看到，我们没有直接调用 <code>await</code>，而是调用了 <code>onAwait</code> 在 <code>select</code> 当中注册了个回调，不管哪个先回调，<code>select</code> 立即返回对应回调中的结果。假设 <code>localDeferred.onAwait</code> 先返回，那么 <code>userResponse</code> 的值就是 <code>Response(it, true)</code>，当然由于我们的本地缓存可能不存在，因此 <code>select</code> 的结果类型是 <code>Response&lt;User?&gt;</code>。</p><p>对于这个案例本身，如果先返回的是本地缓存，那么我们还需要获取网络结果来展示最新结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    ...</span><br><span class="line">    userResponse.value?.let &#123; log(it) &#125;</span><br><span class="line">    userResponse.isLocal.takeIf &#123; it &#125;?.let &#123;</span><br><span class="line">        <span class="keyword">val</span> userFromApi = remoteDeferred.await()</span><br><span class="line">        cacheUser(login, userFromApi)</span><br><span class="line">        log(userFromApi)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><h2 id="复用多个-Channel"><a href="#复用多个-Channel" class="headerlink" title="复用多个 Channel"></a>复用多个 Channel</h2><p>对于多个 <code>Channel</code> 的情况，也比较类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channels = List(<span class="number">10</span>) &#123; Channel&lt;<span class="built_in">Int</span>&gt;() &#125;</span><br><span class="line"></span><br><span class="line">select&lt;<span class="built_in">Int</span>?&gt; &#123;</span><br><span class="line">    channels.forEach &#123; channel -&gt;</span><br><span class="line">        channel.onReceive &#123; it &#125;</span><br><span class="line">        <span class="comment">// OR</span></span><br><span class="line">        channel.onReceiveOrNull &#123; it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>onReceive</code>，如果 <code>Channel</code> 被关闭，<code>select</code> 会直接抛出异常；而对于 <code>onReceiveOrNull</code> 如果遇到 <code>Channel</code> 被关闭的情况，<code>it</code> 的值就是 <code>null</code>。</p><h2 id="SelectClause"><a href="#SelectClause" class="headerlink" title="SelectClause"></a>SelectClause</h2><p>我们怎么知道哪些事件可以被 <code>select</code> 呢？其实所有能够被 <code>select</code> 的事件都是 <code>SelectClauseN</code> 类型，包括：</p><ul><li><p><code>SelectClause0</code>：对应事件没有返回值，例如 <code>join</code> 没有返回值，对应的 <code>onJoin</code> 就是这个类型，使用时 <code>onJoin</code> 的参数是一个无参函数：</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    job.onJoin &#123; log(<span class="string">&quot;Join resumed!&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>SelectClause1</code>：对应事件有返回值，前面的 <code>onAwait</code> 和 <code>onReceive</code> 都是此类情况。</p></li><li><p><code>SelectClause2</code>：对应事件有返回值，此外还需要额外的一个参数，例如 <code>Channel.onSend</code> 有两个参数，第一个就是一个 <code>Channel</code> 数据类型的值，表示即将发送的值，第二个是发送成功时的回调：</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List(<span class="number">100</span>) &#123; element -&gt;</span><br><span class="line">    select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        channels.forEach &#123; channel -&gt;</span><br><span class="line">            channel.onSend(element) &#123; sentChannel -&gt; log(<span class="string">&quot;sent on <span class="variable">$sentChannel</span>&quot;</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在消费者的消费效率较低时，数据能发给哪个就发给哪个进行处理，<code>onSend</code> 的第二个参数的参数是数据成功发送到的 <code>Channel</code> 对象。</p></li></ul><p>因此如果大家想要确认挂起函数是否支持 <code>select</code>，只需要查看其是否存在对应的 <code>SelectClauseN</code> 即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在协程当中，Select 的语义与 Java NIO 或者 Unix 的 IO 多路复用类似，它的存在使得我们可以轻松实现 1 拖 N，实现哪个先来就处理哪个。尽管 Select 和 Channel 比起标准库的协程 API 已经更接近业务开发了，不过个人认为它们仍属于相对底层的 API 封装，在实践当中多数情况下也可以使用 Flow API 来解决。</p><p>而这个 Flow API，完全就是响应式编程的协程版 API，我们简直可以照着 RxJava 来学习它，所以我们下一篇再见吧~~~</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》，上线一个月已经有 400 位同学在一起学习了：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有 1100 多位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
      <category term="select" scheme="https://www.bennyhuo.com/tags/select/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 最近怎么样了</title>
    <link href="https://www.bennyhuo.com/2019/12/23/kotlin-2019-whats-new/"/>
    <id>https://www.bennyhuo.com/2019/12/23/kotlin-2019-whats-new/</id>
    <published>2019-12-22T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 已经很成熟了。有多成熟呢？Kotlin Team 现在的重心已经是在为各个领域内的 Kotlin 实践提供支持了。 </p></blockquote><a id="more"></a><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p>KotlinConf 在 12月5日前后的那几天开完了。Kotlin 1.4 有什么新特性吗？还真有一个，那就是 Kotlin 接口的 SAM 转换（KT-7770）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runAction</span><span class="params">(action: <span class="type">Action</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    runAction &#123;</span><br><span class="line">        <span class="comment">//action here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈，终于在新的类型推导到来时，这个特性被支持了。前不久我在录制 《Kotlin 入门到精通》这门课的时候讲到这个点的时候还说“我也不知道什么时候，会不会支持这个特性”，好了，Kotlin Team 终于听到了人民的呼声。</p><h2 id="新形势"><a href="#新形势" class="headerlink" title="新形势"></a>新形势</h2><p>Kotlin 1.0 发布到现在已经快 4 年了，我推广 Kotlin 差不多也 4 年多了。在 Google 开始决定扶持 Kotlin 之前，我们社区的小伙伴的内心感觉大概跟之前的 Rust 社区的小伙伴差不多吧，然后 Google 从 2017 年把 Kotlin 确定为 Android 的一级语言（表示会从官方提供支持，开发者可以使用）到 2019 年转变为首选语言（表示官方推荐你用 Kotlin），社区小伙伴们最初得到这样的消息大概也许相当于 Rust 社区的小伙伴们听到微软决定要用 Rust 来重写部分操作系统模块一样吧（激动）。</p><p>我们来看看现在 Kotlin 的排名情况，第一个是大家用的比较多的：</p><p><strong>TIOBE Index for December 2019</strong><br><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761917429814.jpg"></p><p>这个排名上 Kotlin 上升的还是比较缓慢的，不过也已经不错了，两年前的时候还在 50 名那儿呢。当然，这个排名其实也有一些争议，因为它是按照互联网上现有的某一门语言的网页数来计算排名的，排名前几的某些语言其实有很多网页都大概都没什么人访问。</p><p>第二个是我觉得比较能反映现在大家对待一门语言的态度的排名：</p><p><strong>PYPL PopularitY of Programming Language</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761920410684.jpg"></p><p>（我把图截得大了一些，主要是想把我同样也很喜欢的 Lua 截进来，(～￣▽￣)～）</p><p>这个索引比较科学的地方主要在于它关注的是大家搜索这门语言的教程的频次，这个表明今年 12月大家学习 Kotlin 的热度比起去年上升了 0.5%，名次上升了 4 位。</p><p>也就是说，这两个索引一个反应存量，一个反应增量，数据上就能看出 Kotlin 的潜力还是非常巨大的，尽管现在开发者群体还比不上当红的 Java Python 这类“发达”语言，但这个增速绝对就是“发展中”语言中一道亮丽的风景线。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15770731567913.jpg"><br>PYPL 的排名确实能够比较真实的反映时下大家的态度，Java 已经被唱衰了好几年，Python 近几年火热到一下冒出特别多新书。Kotlin 在 Native 领域存活自然需要直面 Go，在 JavaScript 上当然也离不开 TypeScript，正好我们也对比下它们各自的发展，Kotlin 作为后起之秀真实有后来居上的气势。</p><h2 id="新发展"><a href="#新发展" class="headerlink" title="新发展"></a>新发展</h2><p>事实上，Kotlin 的主要应用领域当然就是  Android 了。可以说 Kotlin 简直运气好到了极点（也可以说是 Kotlin Team 的决策高明），选择从 Android 撕开一道口子切入市场，道理很简单啊，搞后台的人选择面太广了，Android 端除了忍受 Java，实在没有什么办法，我当时尝试了 Groovy 和 Scala 写 Android，结果标准库方法数一个 3W ，一个 5W，几年前我们还在饱受方法数的折磨，大家应该懂我是什么意思。可是 Kotlin 就很聪明，我不造轮子，标准库方法数 7k ，而且一直到现在都没怎么增加太多，所以大家就开始尝试。到现在，很多人都还觉得 Kotlin 一定是给 Android 开发者准备的 —— 怎么会呢。不过要说支持的比较好的，当然还是 Android，<a href="https://developer.android.com/kotlin/ktx">KTX 的库</a>已经非常丰富，<a href="https://developer.android.com/topic/libraries/architecture/lifecycle">Lifecycle</a>、<a href="https://developer.android.com/topic/libraries/architecture/room">Room</a> 这样的组件也已经支持协程（前者提供 scope，后者的 Dao 支持 suspend 函数），第三方的 <a href="https://github.com/square/retrofit">Retrofit</a> 早在 2.6.0 就支持 suspend 函数，<a href="https://github.com/square/okhttp">OkHttp</a> 4.x 已经完全用 Kotlin 重写等等。就连我们公司年初开源的（实际上这个项目在内部也早就开源）插件化框架 <a href="https://github.com/Tencent/Shadow">Shadow</a> 也有很多模块是使用 Kotlin 开发的。数不胜数。</p><p>其次自然就是 Java 所覆盖的其他领域。印象中 <a href="https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0">Spring 5.0 就开始支持 Kotlin</a>，前不久试了下 <a href="https://www.baeldung.com/spring-boot-kotlin-coroutines">WebFlux 都已经支持 <code>suspend</code> 函数作为 RestController 的 API </a>，也提供了各种 <code>Flux</code> 与 <code>Flow</code> 的互转操作，使用体验真实不要太赞。Kotlin Team 的亲儿子 <a href="https://ktor.io/">Ktor</a> 就更不用说了，函数式的 Route 声明，让我一度以为自己在写 Node.js，但又显然不是，Node.js 哪里会提示有什么 API 呢；原生的协程支持，让我们几乎处处可以写 <code>suspend</code> 调用，感觉空气都新鲜了。</p><p>不甘寂寞的 Kotlin Team 很早就开始支持 Js，不过工具链却一直没有跟上，今年还是重点迭代的 <a href="https://github.com/Kotlin/dukat">Dukat</a> 项目就是为了解决 Kotlin 与 JavaScript 交互时，Kotlin 的强类型问题。这个项目可以把现有的 JavaScript 界类型的事实标准 *.d.ts 文件转成 Kotlin 声明，这样就很好的解决了类型问题，省得我们以前写 Kotlin 调用 JavaScript API 的时候要么自己手动在 Kotlin 源码中声明对应的 API，要么就是各种类型都声明为 dynamic 逃过编译器检查。听说 WASM 也要独立门户了，过去一直都在 Kotlin Native 当中，后面也许也是一个重点的发力方向。</p><p>Kotlin Native 最早比较让人难受的就是编译慢的问题了。最开始编译 Hello World 都需要 40s，后来终于缩短到了 10s 以内（我的笔记本是 2015 mbp），当然这个时间随着代码量的增加也并不会有特别显著的增长，所以对于大型项目来讲，编译时间已经不再是问题。还有就是调试麻烦的事儿，如果是写独立的 Kotlin Native 项目，可以直接 CLion 中调试，也可以在 IntelliJ 中安装 Native Debug 插件调试，可是最近很流行的 Kotlin Native 写 iOS 程序呢，貌似不太好办 —— Kotlin Team 宣布会在明年开始 preview 一款运行在 Android Studio 上的插件用来调试跑在 iOS 上的 Kotlin Native 代码，这就有点儿秀了。哦，对了，Kotlin Native 的协程只能跑在一个线程当中的问题也应该很快就能解决，期待一下。</p><p>还有 Kotlin 的脚本，在 3.0 时代就开始尝试支持 Kotlin 的 <a href="https://docs.gradle.org/5.0/release-notes.html">Gradle 在 5.0 正式宣布支持 Kotlin</a>，并且官方文档都配备了 Kotlin 和 Groovy 两个版本，写过 Gradle 插件的都知道，Gradle API 本来就比较复杂，用 Groovy 写没有 IDE 提示的日子有多痛苦，用 Kotlin 就完全不同了。</p><p>更重磅的是，来看看新鲜出炉的 <a href="https://github.com/Kotlin/kotlin-jupyter">kotlin-jupyter</a>，官方博客也刚刚更新了 <a href="https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/">Kotlin 对科学计算支持的介绍文章</a>。看来，Kotlin Team 的野心真的不小啊，我现在就是有点儿担心 Kotlin Team 人手不够了 —— 玩笑话，Kotlin 已经不再是 Kotlin Team 自己的了，而是我们所有开发者的。</p><p>稍微提一下，在函数式编程方面，Kotlin Team 目前没有（明面儿上）专门支持，不过开源项目 <a href="https://github.com/arrow-kt/arrow">Arrow</a>  已经颇具规模，由于 Kotlin 1.4 有公开编译器插件的 API 的计划，Arrow 团队也在积极引进编译器层面的支持来加强某些特性的实现（例如 typeclass，目前在 Java 平台上主要靠 APT）。</p><h2 id="一如既往的建议"><a href="#一如既往的建议" class="headerlink" title="一如既往的建议"></a>一如既往的建议</h2><p>尽管发展趋势日新月异，不过建议却一直没变。现如今的 Kotlin 的发展形势越来越好 ，如果现在你还没有趁早用起来，难道要等到几年后后悔吗？当然也有很多小伙伴说用 Kotlin 的时候“巨坑”，然后我问他们都哪儿坑了，说出来之后结果发现都是因为对 Kotlin 甚至是对 Java 不熟悉造成的。其实大家只要认真阅读官方文档，稍微练习上几天，一定会逐渐熟悉起来的，如果英文吃力，可以关注下<a href="https://www.kotlincn.net/">中文 Kotlin 官网</a>，有问题可以到<a href="https://discuss.kotliner.cn/">Kotlin 中文论坛</a>提问。当然，如果大家喜欢通过视频学习，也可以在慕课网关注下 “<a href="https://coding.imooc.com/class/398.html">新版 Kotlin 从入门到精通</a>“ 这门课，我大概从国庆前后开始基于 Kotlin 1.3.50 制作了这套新版的视频教程，Kotlin 的知识点基本上都有覆盖，也结合了过去推广教学的经验对重难点进行了深入剖析，希望对大家在 Kotlin 入门或是进阶的过程中提供帮助。</p><p>Have a nice Kotlin!</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，大家可以在2019年12月26日之前联系慕课网客服索取价值 150 元的定向代金券，结合课程的限时优惠只需要 115 元即可升级新课。新课限时优惠同样截止于2019年12月26日，因此有需要的小伙伴们一定要抓紧了哟！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Kotlin 已经很成熟了。有多成熟呢？Kotlin Team 现在的重心已经是在为各个领域内的 Kotlin 实践提供支持了。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="News" scheme="https://www.bennyhuo.com/tags/news/"/>
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程 番外篇(2) - 协程的几类常见的实现</title>
    <link href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/"/>
    <id>https://www.bennyhuo.com/2019/12/01/coroutine-implementations/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。 </p></blockquote><a id="more"></a><p>前面一篇文章我们大概讨论了协程是怎么一回事，也举了一些例子，不过整体上覆盖的细节比较少。这篇文章我们按照协程的经典论文 “Revisiting Coroutines” 的思路展开，详细的讨论下协程究竟是怎样的存在。当然由于涉及语言较多，个人水平有限，如有不恰当之处，欢迎大家指正。</p><h2 id="1-协程的分类"><a href="#1-协程的分类" class="headerlink" title="1. 协程的分类"></a>1. 协程的分类</h2><p>协程的主流实现虽然细节上差异较大，但总体来讲仍然有章可循。</p><h3 id="1-1-按调用栈分类"><a href="#1-1-按调用栈分类" class="headerlink" title="1.1 按调用栈分类"></a>1.1 按调用栈分类</h3><p>由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似地，线程会因为 CPU 调度权的切换而被中断，它的中断状态会保存在调用栈当中，因而协程的实现也按照是否开辟相应的调用栈存在以下两种类型：</p><ul><li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li><li>无栈协程 Stackless Coroutine：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法来实现。</li></ul><p>有栈协程的优点就是可以在任意函数调用层级的任意位置进行挂起，并转移调度权，例如 Lua 的协程，这方面多数无栈协程就显得力不从心了，例如 Python 的 Generator；通常来讲，有栈协程因为总是会给协程开辟一块儿栈内存，因此内存开销也相对可观，而无栈协程在内存方面就比较有优势了。</p><p>当然也有反例。</p><p>Go 语言的 go routine 可以认为是有栈协程的一个实现，不过 Go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB，相比之下线程的栈空间通常是 MB 级别，因而它在内存方面的表现也相对轻量。</p><p>Kotlin 的协程是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现的，不过 Kotlin 的协程可以在任意调用层次挂起，换句话说我们启动一个 Kotlin 协程，可以在其中任意嵌套 <code>suspend</code> 函数，而这又恰恰是有栈协程最重要的特性之一：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">level_0</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;I&#x27;m in level 0!&quot;</span>)</span><br><span class="line">    level_1() <span class="comment">// ............ ①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">level_1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;I&#x27;m in level 1!&quot;</span>)</span><br><span class="line">    suspendNow() <span class="comment">// ............ ②</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendNow</span><span class="params">()</span></span> </span><br><span class="line">        = suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中 ① 处并没有真正直接挂起，② 处的调用才会真正挂起，Kotlin 通过 <code>suspend</code> 函数嵌套调用的方式可以实现任意函数调用层次的挂起。</p><p>当然，想要在任意位置挂起，那就需要调用栈了，与开发者通过调用 API 显式地挂起协程相比，任意位置的挂起主要用于运行时对协程执行的干预，这种挂起方式对于开发者不可见，因而是一种隐式的挂起操作。Go 语言的 go routine 可以通过对 channel 的读写来实现挂起和恢复，除了这种显式地切换调度权之外，Go 运行时还会对长期占用调度权的 go routine 进行隐式挂起，并将调度权转移给其他 go routine，这实际上就是我们熟悉的线程的抢占式调度了。</p><h3 id="1-2-按调度方式分类"><a href="#1-2-按调度方式分类" class="headerlink" title="1.2 按调度方式分类"></a>1.2 按调度方式分类</h3><p>调度过程中，根据协程转移调度权的目标又将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>：</p><ul><li>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。</li><li>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li></ul><p>对称协程实际上已经非常接近线程的样子了，例如 Go 语言中的 go routine 可以通过读写不同的 channel 来实现控制权的自由转移。而非对称协程的调用关系实际上也更符合我们的思维方式，常见的语言对协程的实现大多是非对称实现，例如 Lua 的协程中当前协程调用 <code>yield</code> 总是会将调度权转移给 <code>resume</code> 它的协程；还有就是我们在前面提到的 <code>async</code>/<code>await</code>，<code>await</code> 时将调度权转移到异步调用中，异步调用返回结果或抛出异常时总是将调度权转移回 <code>await</code> 的位置。</p><p>从实现的角度来讲，非对称协程的实现更自然，也相对容易；不过，我们只要对非对称协程稍作修改，即可实现对称协程的能力。在非对称协程的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有的协程在挂起时都将控制权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，例如 Lua 的第三方库 <a href="https://luapower.com/coro">coro</a>，以及 Kotlin 协程框架中基于 <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html">Channel</a> 的通信等。</p><h2 id="2-协程的实现举例"><a href="#2-协程的实现举例" class="headerlink" title="2. 协程的实现举例"></a>2. 协程的实现举例</h2><p>我们已经介绍了非常多的协程相关的理论知识，简单来说协程需要关注的就是程序自己处理挂起和恢复，只不过在分类的时候又根据解决挂起和恢复时具体实现细节的不同又区分了按照<strong>栈</strong>的有无和<strong>调度权</strong>转移的对称性的分类。不管怎样，协程的关注点就是程序自己处理挂起和恢复，以下我们给出一些实现，请大家留意它们是如何做到这一点的。</p><h3 id="2-1-Python-的-Generator"><a href="#2-1-Python-的-Generator" class="headerlink" title="2.1 Python 的 Generator"></a>2.1 Python 的 Generator</h3><p>Python 的 Generator 也是协程，是一个典型的无栈协程的实现，我们可以在任意 Python 函数中调用 <code>yield</code> 来实现当前函数调用的挂起，<code>yield</code> 的参数作为对下一次 <code>next(num_generator)</code>调用的返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers</span>():</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span>(i) <span class="comment"># ..................... ①</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">num_generator = numbers()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&quot;[0] <span class="subst">&#123;<span class="built_in">next</span>(num_generator)&#125;</span>&quot;</span>) <span class="comment"># ... ②</span></span><br><span class="line">print(<span class="string">f&quot;[1] <span class="subst">&#123;<span class="built_in">next</span>(num_generator)&#125;</span>&quot;</span>) <span class="comment"># ... ③</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_generator: <span class="comment"># ............... ④</span></span><br><span class="line">    print(<span class="string">f&quot;[Loop] <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>所以运行这段程序时，首先会在 ① 处 <code>yield</code>，并将 <code>0</code> 传出，在 ② 处输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0] 0</span><br></pre></td></tr></table></figure><p>接着自 ③ 处调用 <code>next</code>，将调度权从主流程转移到 <code>numbers</code> 函数当中，从上一次挂起的位置 ① 处继续执行，<code>i</code> 的值修改为 <code>1</code>，1s 后，再次通过 <code>yield(1)</code> 挂起，③ 处输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br></pre></td></tr></table></figure><p>后续就以同样的逻辑在 <code>for</code> 循环中一直输出 <code>[Loop] n</code>，直到程序被终止。</p><p>我们看到，之所以称 Python 的 Generator 为协程，就是因为它具备了通过 <code>yield</code> 来挂起当前 Generator 函数的执行，通过 <code>next</code> 来恢复参数对应的 Generator 执行来实现挂起、恢复的协程调度权控制转移的。</p><p>当然，如果在 <code>numbers</code> 函数中嵌套调用 <code>yield</code>，就无法对 <code>numbers</code> 的调用进行中断了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers</span>():</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        yield_here(i) <span class="comment"># ................. ①</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yield_here</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">yield</span>(i)</span><br></pre></td></tr></table></figure><p>这时候我们再调用 <code>numbers</code> 函数，就会陷入死循环而无法返回，因为这次 <code>yield_here</code> 的返回值才是 Generator。</p><blockquote><p><strong>说明</strong> Python 的 Generator 属于<strong>非对称无栈协程</strong>的一种实现。从 Python 3.5 开始也支持 <code>async</code>/<code>await</code>，原理与 JavaScript 的实现类似，与 Generator 的不同之处在于我们可以通过这一组关键字实现在函数嵌套调用挂起。</p></blockquote><h3 id="2-2-Lua-标准库的协程实现"><a href="#2-2-Lua-标准库的协程实现" class="headerlink" title="2.2 Lua 标准库的协程实现"></a>2.2 Lua 标准库的协程实现</h3><p>Lua 的协程实现可以认为是一个教科书式的案例了，它提供了几个 API 允许开发者灵活控制协程的执行：</p><ul><li><code>coroutine.create</code>：创建协程，参数为函数，作为协程的执行体，返回协程实例。</li><li><code>coroutine.yield</code>：挂起协程，第一个参数为被挂起的协程实例，后面的参数则作为外部调用 <code>resume</code> 来继续当前协程时的返回值，而它的返回值则又是外部下一次 <code>resume</code> 调用时传入的参数。</li><li><code>coroutine.resume</code>：继续协程，第一个参数为被继续的协程实例，后面的参数则作为协程内部 <code>yield</code> 时的返回值，返回值则为协程内部下一次 <code>yield</code> 时传出的参数；如果是第一次对该协程实例执行 <code>resume</code>，参数会作为协程函数的参数传入。</li></ul><p>Lua 的协程也有几个状态，挂起（suspended）、运行（running）、结束（dead）。其中，调用 <code>yield</code> 之后的协程处于挂起态，获得执行权而正在运行的协程则是处于运行态，协程对应的函数运行结束后，则处于结束态。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span> </span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>, <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;send &quot;</span>..i)</span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(i) <span class="comment">-- ④</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End Producer&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(value)</span></span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;receive &quot;</span>..value)</span><br><span class="line">        value = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>() <span class="comment">-- ⑤</span></span><br><span class="line">    <span class="keyword">until</span>(<span class="keyword">not</span> value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End Consumer&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">producerCoroutine = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(producer) <span class="comment">-- ①</span></span><br><span class="line">consumerCoroutine = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(consumer) <span class="comment">-- ②</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">status</span>, product = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(producerCoroutine) <span class="comment">-- ③</span></span><br><span class="line">    <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(consumerCoroutine, product) <span class="comment">-- ⑥</span></span><br><span class="line"><span class="keyword">until</span>(<span class="keyword">not</span> <span class="built_in">status</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;End Main&quot;</span>)</span><br></pre></td></tr></table></figure><p>这段代码在 ①、②两处创建协程，③处开始执行，<code>producer</code> 在 ④ 处 <code>yield(0)</code>，意味着 ③ 的返回值 <code>product</code> 就是 <code>0</code>，我们把 <code>0</code> 作为参数又传给 <code>consumer</code>，第一次 <code>resume</code> 参数 <code>0</code> 会作为 <code>consumer</code> 的参数 <code>value</code> 传入，因此会打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">send 0</span><br><span class="line">receive 0</span><br></pre></td></tr></table></figure><p>接下来 <code>consumer</code> 通过 ⑤ 处的 <code>yield</code> 挂起，它的参数会作为 ⑥ 处的返回值，不过我们没有传任何参数。这时控制权又回到主流程，<code>status</code> 的值在对应的协程结束后会返回 <code>false</code>，这时候 <code>producer</code> 尚未结束，因此是 <code>true</code>，于是循环继续执行，后续流程类似，输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">send 1</span><br><span class="line">receive 1</span><br><span class="line">send 2</span><br><span class="line">receive 2</span><br><span class="line">send 3</span><br><span class="line">receive 3</span><br><span class="line">End Producer</span><br><span class="line">End Consumer</span><br><span class="line">End Main</span><br></pre></td></tr></table></figure><p>通过这个例子，希望大家能够对协程有一个更加具体的认识，我们看到对于协程来讲，它包括：</p><ul><li>协程的执行体，主要是指启动协程时对应的函数</li><li>协程的控制实例，我们可以通过协程创建时返回的实例控制协程的调用流转</li><li>协程的状态，在调用流程转移前后，协程的状态会发生相应的变化</li></ul><blockquote><p><strong>说明</strong> Lua 标准库的协程属于<strong>非对称有栈协程</strong>，不过第三方提供了基于标准库的<strong>对称协程</strong>的实现，有兴趣的话可以参考： <a href="https://luapower.com/coro">coro</a>。有趣的是，这也恰恰是<strong>对称协程</strong>的实现可以基于<strong>非对称协程</strong>来实现的很好的例证。</p></blockquote><h3 id="2-3-Go-语言中的-go-routine"><a href="#2-3-Go-语言中的-go-routine" class="headerlink" title="2.3 Go 语言中的 go routine"></a>2.3 Go 语言中的 go routine</h3><p>go routine 的调度没有 Lua 那么明显，没有类似 <code>yield</code> 和 <code>resume</code> 的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// .......... ①</span></span><br><span class="line"><span class="keyword">var</span> readChannel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = channel</span><br><span class="line"><span class="keyword">var</span> writeChannel <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = channel</span><br><span class="line"></span><br><span class="line"><span class="comment">// reader</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// ........................ ②</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;wait for read&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> readChannel &#123; <span class="comment">// ... ③</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;read&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;read end&quot;</span>)</span><br><span class="line">&#125;()  <span class="comment">// ............................... ④</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// writer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;write&quot;</span>, i)</span><br><span class="line">        writeChannel &lt;- i <span class="comment">// .......... ⑤</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>我们先来简单介绍下 go routine 的启动方式。在任意函数调用前面加关键字 <code>go</code> 即可启动一个 go routine，并在该 go routine 中调用这个函数，例如 ② 处实际上是创建了一个匿名函数，并在后面 ④ 处立即调用了该函数。我们把这两个 go routine 依次称为 “reader” 和 “writer”。</p><p>① 处创建了一个双向的 <code>channel</code>，可读可写，接着创建的 <code>readChannel</code> 声明为只读类型，<code>writeChannel</code> 声明为只写类型，这二者实际上是同一个 <code>channel</code>，并且由于这个 <code>channel</code> 没有缓冲区，因此写操作会一直挂起直到读操作执行，反过来也是如此。</p><p>在 reader 中，③ 处的 <code>for</code> 循环会对 <code>readChannel</code> 进行读操作，如果此时还没有对饮的写操作，就会挂起，直到有数据写入；在 writer 中，⑤ 处表示向 <code>writeChannel</code> 中写入 <code>i</code>，同样，如果写入时尚未有对应的读操作，就会挂起，直到有数据读取。整段程序的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait for read</span><br><span class="line">write 0</span><br><span class="line">read 0</span><br><span class="line">write 1</span><br><span class="line">read 1</span><br><span class="line">write 2</span><br><span class="line">read 2</span><br><span class="line">read end</span><br></pre></td></tr></table></figure><p>如果我们有多个 go routine 对 <code>channel</code> 进行读写，或者有多个 <code>channel</code> 供多个 go routine 读写，那么这时的读写操作实际上就是在 go routine 之间平等的转移调度权，因此可以认为 go routine 是<strong>对称</strong>的协程实现。</p><p>这个示例看上去对于 <code>channel</code> 的读写操作有点儿类似两个线程中的阻塞式 IO 操作，不过 go routine 相对操作系统的内核线程来说要轻量得都，切换的成本也很低，因此在读写过程中挂起的成本也远比我们熟悉的线程阻塞的调用切换成本。实际上这两个 go routine 在切换时，很大概率不会有线程的切换，为了让示例更加能说明问题，我们为输出添加了当前的线程 id，同时将每次向 <code>writeChannel</code> 写入数据之后的 <code>Sleep</code> 操作去掉：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(windows.GetCurrentThreadId(), <span class="string">&quot;wait for read&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> readChannel &#123;</span><br><span class="line">        fmt.Println(windows.GetCurrentThreadId(), <span class="string">&quot;read&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(windows.GetCurrentThreadId(), <span class="string">&quot;read end&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">        fmt.Println(windows.GetCurrentThreadId(), <span class="string">&quot;write&quot;</span>, i)</span><br><span class="line">        writeChannel &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>修改后的运行结果可以看到程序在输出时所在的线程 id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">181808 write 0</span><br><span class="line">183984 wait for read</span><br><span class="line">181808 read 0</span><br><span class="line">181808 write 1</span><br><span class="line">181808 write 2</span><br><span class="line">181808 read 1</span><br><span class="line">181808 read 2</span><br><span class="line">181808 read end</span><br></pre></td></tr></table></figure><p>两个 go routine 除了开始运行时占用了两个线程，后续都在一个线程中转移调度权（不同场景的实际运行结果可能有细微差异，这取决于 Go 运行时的调度器）。</p><blockquote><p><strong>获取线程 id</strong> 本例在 windows 上调试，通过 <a href="https://github.com/golang/sys">sys</a> 库的 windows 包下提供的 <code>GetCurrentThreadId</code> 函数来获取线程 id。Linux 系统可以通过 <code>syscall.Gettid</code> 来获取。</p></blockquote><blockquote><p><strong>说明</strong> 我们虽然一直在用 go routine 做例子，并把它称作为<strong>对称有栈协程</strong>的一种实现，但考虑到 Go 运行时本身做了足够多超出其他语言的能力，例如栈优化，调度优化等，特别是的调度器还支持特定场景下的抢占式调度，某种意义上已经超越了协程概念的讨论范围，因此也有很多人认为 go routine 不能简单的认为就是协程。</p></blockquote><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>本文整体上对协程的分类做了较为详细的探讨。不管怎么分类，协程的本质就是程序自己处理挂起和恢复。协程描述了多个程序之间如何通过相互出让运行调度权来完成执行，基于这一对基本的控制转移操作进而衍生出各种异步模型，并发模型例如 <code>async</code>/<code>await</code>，Channel 等。</p><p>相比之下，有朋友抱怨 Kotlin 的协程没有其他语言的 <code>async</code>/<code>await</code> 那么容易上手，也没有 go routine 那么容易使用，原因也很简单，Kotlin 的协程用一个最基本的 <code>suspend</code> 关键字来支持了最基本的挂起恢复逻辑，进而在上层封装，衍生出了以上提到的几乎所有的模型，让我们在 Kotlin 当中可以有机会使用 <code>async</code>/<code>await</code>、Channel，以及最新出的 Flow API，将来还会有更多（也许包括在 issue 中被提到想要重做的 Actor），它想做的事儿太多了，也确实在一步一步地做到。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:&#107;&#x66;&#x40;&#x69;&#109;&#111;&#111;&#99;&#46;&#99;&#x6f;&#109;">&#107;&#x66;&#x40;&#x69;&#109;&#111;&#111;&#99;&#46;&#99;&#x6f;&#109;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 中文论坛的使用技巧</title>
    <link href="https://www.bennyhuo.com/2019/10/22/kotlin-forum-mobile/"/>
    <id>https://www.bennyhuo.com/2019/10/22/kotlin-forum-mobile/</id>
    <published>2019-10-21T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.421Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！ </p></blockquote><a id="more"></a><p>欢迎访问 <a href="https://discuss.kotliner.cn/">Kotlin 中文论坛</a> 讨论 Kotlin！为了能够有时间刷论坛，我卸载了知乎卸载了脉脉，来吧，抛出你的问题~~</p><p>大家知道，额，估计不知道吧。。。我们的 Kotlin 中文论坛实际上是采用了与官方论坛相同的框架 <a href="https://www.discourse.org/">Discourse</a>，很厉害的项目呢。这个框架界面风格都非常的清爽，Github 的论坛、Gradle 论坛好多论坛都采用了这个项目搭建：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716995316308.jpg"></p><p>我其实一直以为它的优点就只有这么点儿，直到我发现用手机端的 Chrome 可以直接创建一个快捷方式：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716998152892.jpg"></p><p>之后呢？我们就可以在桌面上看到：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999181369.jpg"></p><p>点击这个 icon 进入之后，就好像原生 App 一样：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999799086.jpg"></p><p>浏览器的地址不见了有没有，使用体验也很不错，小伙伴们就可以随时随地刷论坛啦！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！</p><hr><p>经过小伙伴们之处，桌面也可以：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720452651204.jpg"></p><p>然后就得到了一个桌面 APP 有木有！</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720453054368.jpg"></p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:&#107;&#102;&#64;&#105;&#109;&#111;&#x6f;&#x63;&#x2e;&#x63;&#x6f;&#x6d;">&#107;&#102;&#64;&#105;&#109;&#111;&#x6f;&#x63;&#x2e;&#x63;&#x6f;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Website" scheme="https://www.bennyhuo.com/tags/website/"/>
    
  </entry>
  
</feed>
