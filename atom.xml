<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bennyhuo</title>
  
  <subtitle>编程、教学 &amp; Kotlin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.bennyhuo.com/"/>
  <updated>2020-05-17T23:16:47.028Z</updated>
  <id>https://www.bennyhuo.com/</id>
  
  <author>
    <name>Bennyhuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin 的 Property Delegate 与 Swift 的 Property Wrapper</title>
    <link href="https://www.bennyhuo.com/2020/05/08/kotlin-swift-property-delegate/"/>
    <id>https://www.bennyhuo.com/2020/05/08/kotlin-swift-property-delegate/</id>
    <published>2020-05-07T16:00:00.000Z</published>
    <updated>2020-05-17T23:16:47.028Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Swift 的属性代理，见识一下</p></blockquote><a id="more"></a><p>Swift 想必大家都已经非常熟悉了，它是苹果公司推出的一门开源语言。Swift 与 Kotlin 几乎是同一段时间开始研发，也是前后呈现在公众面前。二者语法设计上有诸多相似之处，它们的关系让我甚至想到了当年的 Java 和 C#。更神奇的是，Kotlin-Native 居然支持了与 Objective-C 的互调用，进而也就相当于某种意义上支持了与 Swift 的互调用，这下它们就更亲密了。</p><blockquote><p>Swift：我不是我没有别瞎说。</p></blockquote><p>本文我们来聊聊二者的属性代理的设计和使用。通过对比，我们能够更加清楚的认识到属性代理的设计意图，以及其优势和不足，此外我们还能够了解更多属性代理这一语法特性的使用场景。</p><h2 id="Kotlin-的属性代理（Property-Delegate）"><a href="#Kotlin-的属性代理（Property-Delegate）" class="headerlink" title="Kotlin 的属性代理（Property Delegate）"></a>Kotlin 的属性代理（Property Delegate）</h2><p>我们先来简单回顾下 Kotlin 的属性代理的一些基础知识和应用场景。</p><h3 id="简化存储的读写"><a href="#简化存储的读写" class="headerlink" title="简化存储的读写"></a>简化存储的读写</h3><p>Kotlin 的属性代理算是大多数开发者在学习过程中会遇到的一个小难点。这其实让我一直都感到比较意外，因为属性代理本身应该是一个很自然的需求，例如我们经常在 Android 当中会读写 SharedPreference，一个 Key 对应于一个 Value，读写的过程高度相似且繁琐：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="comment">// write</span></span><br><span class="line"><span class="keyword">val</span> prefs = context.getSharedPreferences(prefName, Context.MODE_PRIVATE)</span><br><span class="line">prefs.putString(key, value)</span><br><span class="line">prefs.apply()</span><br><span class="line"></span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="keyword">val</span> value = prefs.getString(key, defaultValue)</span><br></pre></td></tr></table></figure><p>这当中还经常需要定义一堆常量作为 key 的值，无论从代码编写的舒适度上还是从代码的编写效率上来看都不是最理想的状态。</p><p>实际上，如果我们把 SharedPreference 看成是类似内存一样的存储空间，那么为什么我们不能像读写内存中的变量那样轻松自在呢？于是乎我们通过属性代理将 SharedPreference 的读写操作做一下封装，实现了使用对变量的读写方式来读写 SharedPreference 的效果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loginName <span class="keyword">by</span> pref(context, <span class="keyword">default</span> = <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// save "bennyhuo" as key "loginName"</span></span><br><span class="line">loginName = <span class="string">"bennyhuo"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// load key "loginName" from SharedPreferences</span></span><br><span class="line"><span class="keyword">val</span> currentLoginName = loginName</span><br></pre></td></tr></table></figure><p>请大家注意，<code>pref</code> 是一个函数，它有一个泛型参数可以通过第二个函数参数的类型推导出来。对 <code>loginName</code> 的读写等同于对 SharedPreferences 中的 “loginName” 这个 key 的读写，这个操作是不是非常方便？想要实现这样的功能也不需要太多的逻辑，我们以 <code>String</code> 为例给出实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Preference</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> context: Context, <span class="keyword">val</span> name: String, </span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">default</span>: T, <span class="keyword">val</span> prefName: String = <span class="string">"default"</span>) : ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> prefs <span class="keyword">by</span> lazy &#123; context.getSharedPreferences(prefName, Context.MODE_PRIVATE) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> findPreference(findProperName(property), <span class="keyword">default</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        putPreference(findProperName(property), value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findProperName</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;)</span></span> = <span class="keyword">if</span>(name.isEmpty()) property.name <span class="keyword">else</span> name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;U&gt;</span> <span class="title">findPreference</span><span class="params">(name: <span class="type">String</span>, <span class="keyword">default</span>: <span class="type">U</span>)</span></span>: U = with(prefs) &#123;</span><br><span class="line">        <span class="keyword">val</span> res: Any = <span class="keyword">when</span> (<span class="keyword">default</span>) &#123;</span><br><span class="line">            <span class="keyword">is</span> String -&gt; getString(name, <span class="keyword">default</span>)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res <span class="keyword">as</span> U</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;U&gt;</span> <span class="title">putPreference</span><span class="params">(name: <span class="type">String</span>, value: <span class="type">U</span>)</span></span> = with(prefs.edit()) &#123;</span><br><span class="line">        <span class="keyword">when</span> (value) &#123;</span><br><span class="line">            <span class="keyword">is</span> String -&gt; putString(name, value)</span><br><span class="line">            ...</span><br><span class="line">        &#125;.apply()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他数据类型的支持大家可以根据需要自行扩展。</p><p>属性代理的本质就是 <code>getValue</code> 和 <code>setValue</code> 这两个方法，这里的代码实现了 <code>ReadWriteProperty</code> 这个接口，不过这不是必须的，我们当然也可以改成下面的样子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Preference</span>&lt;<span class="type">T</span>&gt;</span>(...) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> findPreference(findProperName(property), <span class="keyword">default</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        putPreference(findProperName(property), value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 <code>getValue</code> 和 <code>setValue</code> 还是运算符方法，其实这里我们甚至可以把它们定义成扩展方法，只要方法的类型符合要求就可以。</p><p>既然如此，那我们是不是还可以对 Java 的 <code>Properties</code> 文件提供类似的支持呢？当然。我们同样可以通过被代理的属性名来查询对应 key 在 <code>Properties</code> 文件中的值，这个逻辑与 SharedPreferences 如出一辙，大家有兴趣可以参考这里：<a href="https://github.com/enbandari/QCloudImageUploaderForMarkDown/blob/master/src/main/kotlin/com/bennyhuo/qcloud/prop/AbsProperties.kt" target="_blank" rel="noopener">AbsProperties.kt</a>。</p><p>官网在介绍属性代理的时候还给出了 Map 作为属性代理的用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name : String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age  : <span class="built_in">Int</span>    <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在很早的时候还专门写过一篇文章来介绍这个用法：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247484018&amp;idx=1&amp;sn=170499992c0f29d9304eeddc4379f34e&amp;chksm=e8a05d4fdfd7d459d7e75fa987eda85b39d43ce9b2ea5c8d2b8c884efc7b0431ae39b3c9c22f&amp;token=397611765&amp;lang=zh_CN#rd" target="_blank" rel="noopener">用 Map 为你的属性做代理</a>。其实 <code>Map</code> 也是一种存储的方式，这与前面提到的 SharedPreferences 又有什么区别呢？</p><p>这样的例子我们还能列举很多，如数据库读写、文件读写甚至网络读写等等。</p><h3 id="控制属性的生命周期"><a href="#控制属性的生命周期" class="headerlink" title="控制属性的生命周期"></a>控制属性的生命周期</h3><p>标准库中也提供了 Lazy、Observable 这样的属性代理实现，它们与前面的简化存储的写法不同，二者分别代表了控制、监听属性的读写的使用场景。Lazy 的例子想必大家已经见过很多了，我们可以通过 Lazy 代理属性的初始化逻辑，确保只有在第一次访问时才会对属性进行初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textView <span class="keyword">by</span> lazy &#123; rootView.findViewById(R.id.text) &#125;</span><br></pre></td></tr></table></figure><p>我们对属性进行延迟初始化的理由总是会有很多，例如初始化可能比较耗时，依赖的其他成员尚未初始化等等。</p><p>我们再来看个例子。</p><p>Kotlin 当中的变量类型分为可空和不可空，定义时必须明确其类型，例如下面例子中的 image：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> image: Bitmap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        image = <span class="literal">null</span> <span class="comment">// Error!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>image</code> 在定义时如果定义为 <code>Bitmap?</code>，那么在不需要的时候自然是可以置为 <code>null</code> 的，只不过用的时候每次都需要判空，感觉就很让人难受。而如果定义成 <code>Bitmap</code>，用的时候倒是省事儿了，可是最后我们又无法将其置为 <code>null</code>。怎么办？</p><p>有人说你这个是伪需求，不置为 <code>null</code> 也不会有内存泄露。不过，<code>Activity</code> 经常在 <code>onStop</code> 调用之后还会存续一段时间才会被销毁，对应的 <code>Bitmap</code> 对象也要晚一段时间才能被释放，不置为 <code>null</code> 似乎并不是一个最优的选择。不管怎样，如果我们就是想要把这个 <code>Bitmap</code> 对象（或者其他什么对象）置为空，又想不影响开发体验，似乎是不可行的。</p><p>但如果我们用属性代理来控制对象的内部逻辑呢：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> image <span class="keyword">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        <span class="comment">// release the Bitmap instance.</span></span><br><span class="line">        ::image.release() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过 <code>releasableNotNull</code> 函数来创建这样一个属性代理，这个属性代理的工作就是提供一个真正的属性存储，可读可写可释放，它的实现并不复杂：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">releasableNotNull</span><span class="params">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> value ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">"Not Initialized or released already."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span> = value != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isAccessible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">"Delegate is null or is not an instance of ReleasableNotNull."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过对属性代理类 <code>ReleasableNotNull</code> 实现了对真正存储值的 <code>value</code> 的代理，前面对 <code>image</code> 的访问实际上就是对 <code>value</code> 的访问，而 <code>value</code> 的类型又是可空的，因此我们实现了既可将属性置为 <code>null</code> 又可将属性 <code>image</code> 声明为不可空的 <code>Bitmap</code> 类型的需求。</p><p>这个小功能已经开源并上传到 jcenter，大家可以通过配置依赖 <code>com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0</code> 来使用它，也可以直接到我的 GitHub 上查看它的源码：<a href="https://github.com/enbandari/ReleasableVar" target="_blank" rel="noopener">ReleasableVar</a>，源码当中我也给出了不依赖 Kotlin 反射的实现方法。</p><blockquote><p>例子当中的 <code>KProperty0&lt;R&gt;.release</code> 扩展方法实际上是为被代理的属性的引用添加了一个扩展，其中使用反射可以获取到代理对象，这样我们就可以使用 <code>::image.release()</code> 来实现对 image 背后的值的置空。请大家留意我们获取属性代理对象的方式，这在 Kotlin 当中需要用到反射；后面我们会看到， Swift 则直接提供了更好的语法来支持这样的功能。</p></blockquote><h3 id="代理其他类属性或者方法"><a href="#代理其他类属性或者方法" class="headerlink" title="代理其他类属性或者方法"></a>代理其他类属性或者方法</h3><p>前面的例子都比较直观，我们再给大家看一个更复杂的用法。</p><p>假设我们现在有这么一类，它有一些方法和属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapped</span></span>(<span class="keyword">var</span> x: <span class="built_in">Boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> z = <span class="number">10L</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setY</span><span class="params">(y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getY</span><span class="params">()</span></span> = <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的实例会被包在另一个类当中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Boolean</span> = ...</span><br><span class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span> = ...</span><br><span class="line">    <span class="keyword">val</span> z: <span class="built_in">Long</span> = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>Wrapper</code> 类当中还想把 <code>Wrapped</code> 类的一些成员暴露给外部调用者，可能的实现就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = wrapped.x</span><br><span class="line">        <span class="keyword">set</span>(value) &#123; wrapped.x = value &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的写法并不是很简洁，我们可以通过属性代理实现这样的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">by</span> wrapped::x.delegator()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性代理本质上就是 <code>setValue</code> 和 <code>getValue</code>，所以代理 getter 和 setter <code>也是顺理成章。delegator</code> 函数是 <code>x</code> 的属性引用的扩展成员，定义也不复杂：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> KProperty0<span class="type">&lt;T&gt;</span>.<span class="title">delegator</span><span class="params">(initializedValue: <span class="type">T</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">    : ReadWriteProperty&lt;Any, T&gt;</span><br><span class="line">        = ObjectPropertyDelegate0(</span><br><span class="line">            propertyRef = <span class="keyword">this</span> <span class="keyword">as</span> PropertyReference, </span><br><span class="line">            initializedValue = initializedValue</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectPropertyDelegate0</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> getter: (() -&gt; T), </span><br><span class="line">        <span class="keyword">val</span> setter: ((T) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span>, </span><br><span class="line">        initializedValue: T? = <span class="literal">null</span>) : ReadWriteProperty&lt;Any, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        propertyRef: PropertyReference, </span><br><span class="line">        initializedValue: T? = <span class="literal">null</span></span><br><span class="line">        ): <span class="keyword">this</span>(</span><br><span class="line">            (propertyRef <span class="keyword">as</span> KProperty0&lt;T&gt;)::<span class="keyword">get</span>, </span><br><span class="line">            <span class="keyword">if</span> (propertyRef <span class="keyword">is</span> KMutableProperty0&lt;*&gt;) (propertyRef <span class="keyword">as</span> KMutableProperty0&lt;T&gt;)::<span class="keyword">set</span> <span class="keyword">else</span> <span class="literal">null</span>, initializedValue</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        initializedValue?.let &#123; setter?.invoke(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> getter.invoke()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        setter?.invoke(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有点儿像请求转发一样，对 <code>Wrapper</code> 的属性 <code>x</code> 的读写直接转发给了 <code>Wrapped</code> 的属性 <code>x</code> 。既然我们把属性拆解开看做是 getter 和 setter，那么所有符合此类特征的函数也是可以被代理的，因此对于 <code>Wrapped</code> 的 <code>getY</code> 也可以代理成一个只读属性，<code>setY</code> 也可以单独代理成一个可变属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> y <span class="keyword">by</span> wrapped::setY.delegator(defaultValue = <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> yGetter <span class="keyword">by</span> wrapped::getY.delegator()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>getY</code> 的代理比较容易理解。对于 <code>setY</code> 的代理就有些奇怪了，属性 <code>y</code> 只代理了 <code>wrapped::setY</code>，那读取 <code>y</code> 的值时从哪儿获取呢？这其实也不难做到，我们可以通过属性代理提供一个 backingfield 来保存这个值就可以了。其实对于 setter 的代理的场景还真有，例如对于 Android 中某些 <code>View</code> 的属性只有 setter 的方法，没有对应的 getter，如果我想要做一个属性动画，那么这样的属性代理就会比较有帮助。</p><p>当然，类似的扩展我们还可以做很多，甚至支持 lazy：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> delegateLazyOf(TextView::getText, TextView::setText) &#123; textView &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们前面的例子当中 <code>wrapped</code> 从一开始就被初始化了，而这个例子当中 <code>textView</code> 需要等到 <code>Activity</code> 的 <code>onCreate</code> 调用之后才会初始化，因此 <code>lazy</code> 就显得非常必要了。具体实现就不一一列举了，有兴趣的朋友可以参考我的 GitHub 项目：<a href="https://github.com/enbandari/ObjectPropertyDelegate" target="_blank" rel="noopener">ObjectPropertyDelegate</a>，大家也可以通过引入 <code>com.bennyhuo.kotlin:delegates:1.0</code> 来直接使用它。</p><p>需要补充说明的一点是，根据 Kotlin 官方最新发布的博客来看，Kotlin 1.4 会直接支持使用属性代理其他属性，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> newName: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">   <span class="meta">@Deprecated(<span class="meta-string">"Use 'newName' instead"</span>, ReplaceWith(<span class="meta-string">"newName"</span>)</span>)</span><br><span class="line">   <span class="keyword">var</span> oldName: <span class="built_in">Int</span> <span class="keyword">by</span> <span class="keyword">this</span>::newName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上与我们前面使用属性代理其他属性问题的处理上如出一辙。当然，官方给出的这个例子还直接展示了这个特性的一个使用场景，即属性重命名。</p><h2 id="Swift-的属性包装器（Property-Wrapper）"><a href="#Swift-的属性包装器（Property-Wrapper）" class="headerlink" title="Swift 的属性包装器（Property Wrapper）"></a>Swift 的属性包装器（Property Wrapper）</h2><p>Swift 的属性包装器其实就是属性代理，最早推出这个特性的时候实际上也叫做 Property Delegate，但设计者们觉得 Property Wrapper 更贴切它的实际用法和含义，加上 Delegate 这个词在 Swift 当中（或者说更早的 Objective-C 当中）已经有了非常确切的含义，因此改成了Property Wrapper。这个名字看上去确实比属性代理表达出来的意图更加明显。</p><p>大家也可以参考 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#user-defaults" target="_blank" rel="noopener">Swift 的属性包装器的设计文档</a>，文档中详细列出了一些使用场景和方法，以及一些设计细节，这其中绝大多数的使用场景我们也可以通过 Kotlin 的属性代理在 Kotlin 当中实现。</p><p>这个特性在 Swift 5 才推出，可以说是非常晚了。说来也有趣，在它的设计文档中还特意 “diss” 了 Kotlin 的属性代理的语法设计：单独为了属性代理搞了一个 by 关键字实在是有些重，在其他场景下也不太好复用，于是 Swift 的属性包装器采用了与 Java/Kotlin 的注解类似的长相的设计。</p><h3 id="代理-UserDefaults"><a href="#代理-UserDefaults" class="headerlink" title="代理 UserDefaults"></a>代理 UserDefaults</h3><p><code>UserDefaults</code> 是苹果家族的平台上通用的类似于 SharedPreferences 的配置存储，也是 key-value 的形式进行读写，我们可以使用属性包装器来进行代理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserDefault</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> defaultValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UserDefaults</span>.standard.object(forKey: key) <span class="keyword">as</span>? <span class="type">T</span> ?? defaultValue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(newValue, forKey: key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>@PropertyWrapper</code> 将 <code>UserDefault</code> 声明为一个属性包装器，我们很自然想到要提供 getter 和 setter 的实现，Swift 通过 <code>wrappedValue</code> 这个计算属性来做到这一点，这样对于被包装的属性的访问其实就转发到对 <code>wrappedValue</code> 的访问上。用法也很直接：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalSettings</span> </span>&#123;</span><br><span class="line">    @<span class="type">UserDefault</span>(key: <span class="string">"FOO_FEATURE_ENABLED"</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isFooFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    @<span class="type">UserDefault</span>(key: <span class="string">"BAR_FEATURE_ENABLED"</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子就是设计文档中的例子，大家可以在 Swift 5.2 当中运行测试。</p><p>稍微提一句，在 Swift 中，struct 是值类型，class 是引用类型，对于属性包装器来讲，二者都是可以的，用哪个取决于具体需求。</p><p>除了语法形式的不同之外，从功能上，Swift 的属性包装器的 wrappedValue 相当于 Kotlin 的属性代理的 <code>getValue</code> 和 <code>setValue</code> 的实现，不同之处在于 Kotlin 在 <code>getValue</code> 和 <code>setValue</code> 中提供了 <code>KProperty</code> 这个参数，我们可以通过它来获取对应属性的一些元信息，最常用的就是 name，所以我们在前面使用 Kotlin 代理 SharedPreferences 的例子当中完全可以不用主动传入 key 的值。</p><p>相比之下，Kotlin 的属性代理的语法更加自由，我们可以轻松地模拟 Swift 的写法来实现属性代理，主要以下是 Kotlin 代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PropertyWrapper</span>&lt;<span class="type">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: Value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: Value = wrappedValue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">Value</span>)</span></span> &#123;</span><br><span class="line">        wrappedValue = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这个思路，实现具体的属性代理，只需要实现这个接口并覆写即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObservableDelegate</span>&lt;<span class="type">Value</span>&gt;</span>(</span><br><span class="line">    initializedValue: Value,</span><br><span class="line">    <span class="keyword">val</span> changedListener: (previous: Value, current: Value) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : PropertyWrapper&lt;Value&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> wrappedValue: Value = initializedValue</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">val</span> previous = field</span><br><span class="line">            field = value</span><br><span class="line">            changedListener(previous, value)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法没有什么特殊之处：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> state: <span class="built_in">Int</span> <span class="keyword">by</span> ObservableDelegate(<span class="number">0</span>) &#123; previous, current -&gt;</span><br><span class="line">    println(<span class="string">"changed <span class="variable">$previous</span> -&gt; <span class="variable">$current</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">state = <span class="number">2</span> <span class="comment">// changed 0 -&gt; 2</span></span><br><span class="line">state = <span class="number">3</span> <span class="comment">// changed 2 -&gt; 3</span></span><br><span class="line">state = <span class="number">4</span> <span class="comment">// changed 3 -&gt; 4</span></span><br></pre></td></tr></table></figure><h3 id="属性包装器的-projectedValue"><a href="#属性包装器的-projectedValue" class="headerlink" title="属性包装器的 projectedValue"></a>属性包装器的 projectedValue</h3><p>我是在学 Swift UI 的时候才开始接触到 Swift 的属性包装器的。Swift UI 就是使用 Swift 代码直接布局的写法，这种写法现在比较流行，例如 Flutter 的 Dart， Android 上之前的 Kotlin Anko 以及现在的 Compose。</p><p>我们来看一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> isEnabled: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(isOn: $isEnabled) &#123;</span><br><span class="line">            isEnabled ? <span class="type">Text</span>(<span class="string">"Click to disable"</span>).foregroundColor(.red)</span><br><span class="line">                : <span class="type">Text</span>(<span class="string">"Click to enable"</span>).foregroundColor(.green)</span><br><span class="line">        &#125;.padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>body</code> 是布局的 View，里面只有一个控件就是一个开关 <code>Toggle</code>，它需要与 <code>isEnabled</code> 这个属性绑定，UI 的效果如下：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-23.png" alt=""></p><p><strong><center>isEnabled 为 false 时的 UI</center></strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-42.png" alt=""></p><p><strong><center>isEnabled 为 true 时的 UI</center></strong></p><p><code>isEnabled</code> 这个属性被 <code>State</code> 这个属性包装器包装，<code>State</code> 为它提供了一个 <code>projectedValue</code> 的属性，这个 <code>projectedValue</code> 可以通过 <strong><code>$</code> + 属性名</strong> 来获取，也就是说作为 <code>Toggle</code> 的参数 <code>isOn</code> 的 <code>$isEnabled</code> 实际上就是 <code>isEnabled</code> 这个属性的包装器提供的 <code>projectValue</code>。</p><p>这个 <code>projectedValue</code> 实际上也是一个属性包装器，它的类型是 <code>Binding&lt;Bool&gt;</code>，<code>Binding</code> 这个属性包装器的作用比较直接，类似于我们前面介绍 Kotlin 的属性代理时提到的 <code>wrapped::x.delegator()</code>，它的作用就是提供了属性的 getter 和 setter，这样我们将 <code>Binding&lt;Bool&gt;</code> 对象传给 <code>Toggle</code> 的时候，它就可以在其中方便的修改 <code>isEnabled</code> 这个属性了。</p><p><code>State</code> 当然还提供了与 View 的刷新机制相关的逻辑，它实现了 <code>DynamicProperty</code> 协议，可以在属性被修改时调用 <code>update</code> 方法来刷新 UI。</p><p>下面我们给出 <code>State</code> 的声明，具体实现没有开源，但可以想到的是在 <code>wrappedValue</code> 的 setter 调用时一定会触发 <code>DynamicProperty</code> 协议的 <code>update</code> 方法的调用，<code>projectedValue</code> 则是返回一个包装了被 <code>State</code> 包装的属性的 getter 和 setter 的对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line">@frozen <span class="meta">@propertyWrapper</span> <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">State</span>&lt;<span class="title">Value</span>&gt; : <span class="title">DynamicProperty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Initialize with the provided initial value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(wrappedValue value: <span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Initialize with the provided initial value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(initialValue value: <span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The current state value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123; <span class="keyword">get</span> <span class="keyword">nonmutating</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Produces the binding referencing this state value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> projectedValue: <span class="type">Binding</span>&lt;<span class="type">Value</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们考虑下 Kotlin 当中是否存在对应的特性。</p><p>对于 <code>Binding</code> 的使用场景，Kotlin 当中大可不必这么大费周章，因为 Kotlin 的属性引用可以很方便的允许我们传递一个属性的 setter 和 getter，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isEnabled: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get property reference</span></span><br><span class="line"><span class="keyword">val</span> view = View()</span><br><span class="line"><span class="keyword">val</span> isEnabledRef = view::isEnabled</span><br><span class="line"></span><br><span class="line"><span class="comment">// operate on property reference</span></span><br><span class="line">isEnabledRef.<span class="keyword">set</span>(<span class="literal">true</span>)</span><br><span class="line">println(isEnabledRef.<span class="keyword">get</span>())</span><br></pre></td></tr></table></figure><p>也就是说，Swift UI 当中的 <code>Binding</code> 在当中可以使用 Kotlin 的属性引用来替代，以上代码也不需要额外引入 Kotlin 反射。</p><p>但可以确定的是，Kotlin 当中没有 <code>projectedValue</code> 这样的特性，即便我们在前面模拟 Swift 声明的 <code>PropertyWrapper</code> 接口中添加这样的属性，我们也没有直接的类似于 <code>$isEnabled</code> 这样的语法来获取它。不仅如此，在 Kotlin 当中想要获取属性代理对象本身也不是一件轻松的事情，而在 Swift 当中我们可以使用 <code>projectedValue</code> 直接返回自身（也可以返回别的，例如 <code>State</code> 中就没有返回自己，而是返回了 <code>Binding</code>）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserDefault</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> defaultValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> projectedValue: <span class="type">UserDefault</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalSettings</span> </span>&#123;</span><br><span class="line">    @<span class="type">UserDefault</span>(key: <span class="string">"FOO_FEATURE_ENABLED"</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isFooFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    @<span class="type">UserDefault</span>(key: <span class="string">"BAR_FEATURE_ENABLED"</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.isBarFeatureEnabled) </span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDefault&lt;Bool&gt;(key: "BAR_FEATURE_ENABLED", defaultValue: false)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.$isBarFeatureEnabled) </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.$isBarFeatureEnabled.wrappedValue) </span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDefault&lt;Bool&gt;(key: "BAR_FEATURE_ENABLED", defaultValue: false)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.$isBarFeatureEnabled.projectedValue)</span><br></pre></td></tr></table></figure><p>实际上如果是在被包装的属性所在的类内部，我们还可以直接拿到包装属性的实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalSettings</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @<span class="type">UserDefault</span>(key: <span class="string">"BAR_FEATURE_ENABLED"</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getIsBarFeatureEnabledWrapper</span><span class="params">()</span></span> -&gt; <span class="type">UserDefault</span>&lt;<span class="type">Bool</span>&gt; &#123;</span><br><span class="line">        _isBarFeatureEnabled</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <code>_isBarFeatureEnabled</code> 得到的就是包装 <code>isBarFeatureEnabled</code> 的实例。</p><p>而这在 Kotlin 当中我们就只能通过反射来做到这一点了。不知道大家是否注意到我们用 Kotlin 属性代理实现的 ReleasableVar 这个组件中用到了 Kotlin 反射方法 <code>getDelegate</code> 来获取属性代理对象，即便我们可以接受使用反射这个前提，但它返回的类型 <code>Any?</code> 也同样不如 Swift 当中可以通过 <code>$</code> 直接获取 <code>projectedValue</code> 以及通过 <code>_</code> 获取属性包装器实例来的直接和安全。更何况 <code>getDelegate</code> 这个反射方法目前只能在 JVM 上使用，无法实现多平台。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="class"><span class="keyword">interface</span> <span class="title">KProperty0</span>&lt;<span class="type">out R</span>&gt; : <span class="type">KProperty</span>&lt;<span class="type">R</span>&gt;, <span class="type"></span></span>() -&gt; R &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of the delegate if this is a delegated property, or `null` if this property is not delegated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDelegate</span><span class="params">()</span></span>: Any?</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们在 Kotlin 当中可以直接把属性代理对象先定义出来，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"><span class="keyword">val</span> delegate = ObservableDelegate(<span class="number">0</span>) &#123; previous, current -&gt;</span><br><span class="line">    println(<span class="string">"changed <span class="variable">$previous</span> -&gt; <span class="variable">$current</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> state <span class="keyword">by</span> delegate</span><br></pre></td></tr></table></figure><p>但这个写法又显得 <code>delegate</code> 与 <code>state</code> 的联系没有那么紧密，因此 Swift 的属性包装器在 <code>projectedValue</code> 的设计上为开发者提供了更大的发挥空间。</p><p>Kotlin 的规划和提议方面也暂时没有看到有类似的设计，如果我们想要在 Kotlin 当中也实现类似于 <code>projectedValue</code> 的功能，也许可以借助一下 Kotlin 编译器插件来完成。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>属性代理或者属性包装器本质上提供了把读写操作简化成对变量的读写的可能性，能够提供更大程度上的抽象，简化程序的代码重复度。</p><p>Kotlin 的属性代理的语法结构没有类型上的强制约束，只要实现 <code>getValue</code> 和 <code>setValue</code> 这两个方法即可用作属性代理的对象；不过，获取一个属性的代理对象的方式不是特别友好，一方面需要使用到反射，另一方面获取到的类型是 <code>Any?</code>，没有静态类型的约束。</p><p>相比之下 Swift 的属性包装器提供了类似的能力，也通过提供 projectedValue 可以衍生出更多灵活的用法。</p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有近 1000 位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Swift 的属性代理，见识一下&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="Property" scheme="https://www.bennyhuo.com/tags/property/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Native 写 Jni 第三弹：改造成 MPP 的工程结构</title>
    <link href="https://www.bennyhuo.com/2020/04/19/kotlin-native-android-mpp/"/>
    <id>https://www.bennyhuo.com/2020/04/19/kotlin-native-android-mpp/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2020-05-08T08:25:34.383Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。</p></blockquote><a id="more"></a><p>在读这篇文章之前，大家可以去参考下之前的文章：</p><ul><li><a href="https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/">用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏</a></li><li><a href="https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/">Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法</a></li></ul><p>之前两篇文章已经介绍了如何通过 <code>CName</code> 注解来限定 Kotlin-Native 代码编出来的动态链接库的符号名，以实现与 Java 的 native 方法的绑定，也介绍了如何使用 <code>JNI_OnLoad</code> 来动态注册 native 方法来实现绑定。换句话说，如果你想要知道如何用 Kotlin-Native 写 Android 的 Jni 的 Native 层代码，那么前面的两篇文章里面就有答案。</p><p>前文撰写的时候 Kotlin-Native 的构建插件尚未稳定，当时除了 Multiplatform Project（以下简称 mpp） 的 Gradle 插件以外还有一个单独的 native 的插件，用法也不是特别统一，现在后者已经被废弃，因此我们只需要用 mpp 的插件来构建 Kotlin-Native 的工程即可。顺带提一句，现在使用 Kotlin DSL 来编写 Gradle 脚本体验已经比之前强多了，建议大家把 IDE 的 Kotlin 插件升级到 1.3.70 以上版本来体验。</p><p>接下来我们就把之前的工程改造一下，工程源码见：<a href="https://github.com/enbandari/hello-kni" target="_blank" rel="noopener">hello-kni</a>。</p><p>首先我们创建一个 Module，你可以选择使用 IntelliJ 的 new module 方式，选择创建一个 Android library，当然也可以自己创建一个目录，然后再创建一个 build.gradle.kts 文件，就像这样：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-08-37-45.png" alt=""></p><p>接着，在 settings.gradle.kts 当中引入这个 Module：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="string">":app"</span>, <span class="string">":nativeLib"</span>)</span><br></pre></td></tr></table></figure><p>好，关键来了，剩下的主要就是修改 build.gradle.kts。我们先来添加 mpp 的 Gradle 插件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">"multiplatform"</span>) version <span class="string">"1.3.71"</span></span><br><span class="line">    id(<span class="string">"com.android.library"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到我们还添加了 Android 的 library 插件，原因是我们想要把 Kotlin-Native 编译出来的 so 打进一个 aar 里面作为 Android 的依赖提供给 app 工程。</p><p>所以构建出来的 so 文件我们需要引入到 aar 的编译流程中，可以将这个 so 文件复制到一个路径，我们把这个路径添加为 Android 的 jniLibs 路径即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jniLibDir = File(project.buildDir, arrayOf(<span class="string">"generated"</span>, <span class="string">"jniLibs"</span>).joinToString(File.separator))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        <span class="keyword">val</span> main <span class="keyword">by</span> getting &#123;</span><br><span class="line">            jniLibs.srcDir(jniLibDir)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 build 目录下选了 generated/jniLibs 作为 jniLibs 目录添加到了 aar 的编译流程中。接下来我们只需要完成 so 文件的复制即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kotlin &#123;</span><br><span class="line">    androidNativeArm32 &#123;</span><br><span class="line">        binaries &#123;</span><br><span class="line">            sharedLib(<span class="string">"knlib"</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(buildType == NativeBuildType.RELEASE)&#123;</span><br><span class="line">                    linkTask.doLast &#123;</span><br><span class="line">                        copy &#123;</span><br><span class="line">                            from(outputFile)</span><br><span class="line">                            into(File(jniLibDir, <span class="string">"armeabi-v7a"</span>))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    afterEvaluate &#123;</span><br><span class="line">                        <span class="keyword">val</span> preReleaseBuild <span class="keyword">by</span> tasks.getting</span><br><span class="line">                        preReleaseBuild.dependsOn(linkTask)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin mpp 的工程配置非常清晰：</p><ol><li>内部的第一层是选择目标平台，这里选择的是 androidNativeArm32，当然如果你想要构建 iOS 平台的，也可以选择 iosArm64 等等。</li><li>第二层是 binaries 就是定义产出物，其内部的 sharedLib 表示产出物是共享库（shared object，so），当然如果希望编译出可执行文件，就替换成 executable。sharedLib 有两个参数，第一个是库的名字，我们这里与原来保持了一致，将库的名字指定为 knlib，这样编译出来的 so 文件就是 libknlib.so。</li><li>我们通过 buildType 来选择将 RELEASE 的产出物复制到指定路径（也就是刚才定义的 jniLibDir），如果做得更完善的话也可以分别对 DEBUG/RELEASE 进行处理。</li><li>为 aar 的构建流程中的 preReleaseBuild 任务添加依赖，这样在 assembleRelease 执行时可以触发对 Kotlin-Native 代码的编译。当然，这里也可以选择其他的任务进行依赖，只要能够在 assemble 时触发编译即可。</li></ol><p>工程配置搞定之后，我们还需要把源码添加进来。androidNativeArm32 的源码路径默认为 src/androidNativeArm32Main/kotlin，因此我们把之前已经写好的 Kotlin-Native 的源文件添加进去即可：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-18-01-24.png" alt=""></p><p>另外作为 Android Library 工程，manifest 文件当然是必须的，不过里面也不需要有什么特别的配置。</p><p>至此，使用 Kotlin-Native 编写 Jni 的工程改造就完成了，在 app 工程中添加依赖：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(project(<span class="string">":nativeLib"</span>))</span><br></pre></td></tr></table></figure><p>直接编译运行 app 工程即可运行，再也不用使用命令行编译啦。</p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有近 1000 位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Kotlin-Native" scheme="https://www.bennyhuo.com/tags/kotlin-native/"/>
    
      <category term="MPP" scheme="https://www.bennyhuo.com/tags/mpp/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 新版本也有了交叉类型和联合类型？</title>
    <link href="https://www.bennyhuo.com/2020/04/06/kotlin-intersect-type/"/>
    <id>https://www.bennyhuo.com/2020/04/06/kotlin-intersect-type/</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2020-05-08T08:25:34.384Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。</p></blockquote><a id="more"></a><p>Kotlin 1.4-m1 发布之后，我曾整理了一下官方博客中提到的语法更新，见 <a href="https://www.bennyhuo.com/2020/03/26/kotlin-1.4-preview/">Kotlin 1.4 新特性预览</a>。除了前面的文章中提到的变化，新类型推导算法对于我们平常的代码编写的提升实际上还会体现在很多方面，接下来我们再为大家展示一个 case，来一起感受下新版本的厉害之处。</p><h2 id="1-分支表达式的类型推导问题"><a href="#1-分支表达式的类型推导问题" class="headerlink" title="1. 分支表达式的类型推导问题"></a>1. 分支表达式的类型推导问题</h2><p>先来看一段代码：</p><p><strong>代码清单 1：Kotlin 的分支表达式</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> number = <span class="keyword">if</span> (validation()) <span class="number">1</span>F <span class="keyword">else</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>请问 number 的类型是什么？</p><p>直觉告诉我们，number 的类型应该就是 Number 呀，因为两个分支分别是 Float 和 Double 类型，而 Number 是它俩的父类，因此是 Number 没毛病。</p><p>逻辑上确实如此，不过实际情况就要各种打脸了。你也许想不到，Float 还实现了一个 Comparable<float>的接口，而 Double 则实现了 Comparable<double>，于是 Float 和 Double 应该同样是 Comparable 的子类才对。也就是说 Float 和 Double 有两个父类（接口），那么再想想，number 究竟是什么类型？Comparable 还是 Number？</double></float></p><p>都不是。Kotlin 1.3 当中，我们可以通过 IntelliJ 很容易的得到答案：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-13-42.png" alt=""></p><p><strong><center>图 1：Kotlin 1.3 对分支表达式的类型推导</center></strong></p><p>是不是很吃惊？居然是 Any。因为 Kotlin 编译器在类型推导时遇到这种模棱两可的情况实在不知道如何做出选择，因此干脆不选。</p><p>当然，如果你为 number 添加类型声明，例如：</p><p><strong>代码清单 2：为分支表达式添加类型信息</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> number: Number = <span class="keyword">if</span> (validation()) <span class="number">1</span>F <span class="keyword">else</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>这样 number 的类型就可以确定为 Number 了，Kotlin 编译器也算是松了一口气。</p><blockquote><p>有关这个问题的详细分析，我曾经在两年前写过一篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247484051&amp;idx=1&amp;sn=4676580d88e9751df9a5ae192fd8d0da&amp;chksm=e8a05daedfd7d4b8d7b7cc9201f287ba3f3206ddba246266c450c02d821959b99344e4cbf42c&amp;token=482430266&amp;lang=zh_CN#rd" target="_blank" rel="noopener">val b = a?: 0，a 是 Double 类型，那 b 是什么类型？</a>，有兴趣的读者可以去了解下。</p></blockquote><h2 id="2-新类型推导算法的推导结果"><a href="#2-新类型推导算法的推导结果" class="headerlink" title="2. 新类型推导算法的推导结果"></a>2. 新类型推导算法的推导结果</h2><p>那么问题来了，新类型推导算法难道可以自动帮我们选择我们想要的类型嘛？额，说实话，这种情况下编译器并不知道你究竟想要什么类型，于是做出选择那是不可能的事儿了。既然做不出选择，那为什么还要选呢？小孩子才做选择，我当然是都要啊！</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-26-20.png" alt=""></p><p><strong><center>图 2：Kotlin 1.4 对分支表达式的类型推导</center></strong></p><p>这是什么情况？这个类型我没见过啊。确实如此，这样的类型我们也没有办法显式声明出来，只有靠编译器推导才能得到。那么这个 {A &amp; B} 的类型究竟算是什么类型呢？字面意思就是既是 A 类型，又是 B 类型，实际含义也是如此。也就是说，{Comparable{Double &amp; Float} &amp; Number} 这个类型既是 Comparable 类型，又是 Number 类型。</p><p>于是在 Kotlin 1.4 当中，以下代码就成了合法的用法：</p><p><strong>代码清单 3：Kotlin 1.4 中对于分支表达式类型的使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Number.<span class="title">compareTo</span><span class="params">(other: <span class="type">Number</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toDouble().compareTo(other.toDouble())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> number = <span class="keyword">if</span> (validation()) <span class="number">1</span>F <span class="keyword">else</span> <span class="number">2.0</span></span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$number</span> &gt; 2"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$number</span> &lt;= 2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在 Kotlin 1.3 当中默认会无法通过编译。</p><h2 id="3-交叉类型与联合类型"><a href="#3-交叉类型与联合类型" class="headerlink" title="3. 交叉类型与联合类型"></a>3. 交叉类型与联合类型</h2><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-49-34.png" alt=""></p><p><strong><center>图 3：Double 和 Float 的类型关系</center></strong></p><p>两个类型的交叉类型就是两个类型的交集，因此对于类型 A &amp; B，如果我们把 A 和 B 看做集合的话，相当于 A ∩ B。图 3 的含义其实还涉及到另一个概念：联合类型。对于文章开头的分支表达式，它的类型是 Double 或者 Float，即 Double | Float，这个类型就是一个联合类型，从集合的角度来讲实际上就是 Double ∪ Float。通俗的说，交叉类型是“既是 A 也是 B”的关系，联合类型则是“不是 A 就是 B”的关系。</p><p>既然如此，从图上来看，Comparable &amp; Number == Double | Float，因为我们前面讲到过，Double 和 Float 的公共父类（接口）包括 Comparable 和 Number。请注意，Kotlin 在表达联合类型时实际上是取了一个类型的近似值，这个值就是公共父类。</p><p>坦率地讲，Kotlin 当中的联合类型与真正理想的联合类型还是不一样的，我们给出 TypeScript 中的联合类型让大家感受下：</p><p><strong>代码清单 4：TypeScript 中的联合类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">    fly(): <span class="built_in">void</span>;</span><br><span class="line">    layEggs(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    swim(): <span class="built_in">void</span>;</span><br><span class="line">    layEggs(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"><span class="comment">// OK，两个类型的公共成员</span></span><br><span class="line">pet.layEggs();</span><br></pre></td></tr></table></figure><p>虽然 Bird 和 Fish 两个接口没有公共父接口，但 Bird | Fish 却有二者的公共成员 layEggs。如果这段代码放到 Kotlin 当中，结果可想而知：</p><p><strong>代码清单 5：Kotlin 的联合类型</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">layEggs</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">swim</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">layEggs</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> pet = <span class="keyword">if</span>(validation()) <span class="keyword">object</span> : Bird&#123; ... &#125; <span class="keyword">else</span> <span class="keyword">object</span> : Fish&#123; ... &#125;</span><br><span class="line">pet.layEggs() <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>这里 pet 理论上应该是 Bird | Fish，但 Kotlin 编译器总是会尝试将其类型“退化”成一个当前类型系统可表达的类型，这个退化的方法就是寻找二者的公共父类，即 Any。因此，Kotlin 编译器将分支表达式的类型推导为 Any，pet 自然无法直接访问 layEggs 了，尽管 Bird 和 Fish 都有这个函数。</p><p>按照 Kotlin 语言规范的说法，Kotlin 当中的交叉类型和联合类型都是不能直接声明的，只是会在某些语法现象中产生，例如类型智能转换等等。一旦产生了这样的类型，Kotlin 会采用类型近似、类型退化等手段来找到一个现有类型系统中合适的类型来表达它们。</p><h2 id="4-为什么不直接支持交叉类型和联合类型呢？"><a href="#4-为什么不直接支持交叉类型和联合类型呢？" class="headerlink" title="4. 为什么不直接支持交叉类型和联合类型呢？"></a>4. 为什么不直接支持交叉类型和联合类型呢？</h2><p>其实这个问题已经争论了挺久了。从各方的讨论来看，目前 Kotlin 没有正式引入这样的类型主要有以下原因：</p><ol><li>伪需求。支持引入这个特性的开发者提供的一些 use case 多数情况下可以通过诸如函数重载、泛型约束等特性来实现，有些情况下实际上更应该优化类型设计而不是寄希望于一个更复杂的类型系统。</li><li>存在滥用风险。类型系统复杂一点点，带来的项目代码的复杂度提升可能都会是巨大的。这一点从 Kotlin 对函数类型的支持上就可见一斑，当然不同之处在于函数类型确实是刚需。</li></ol><p>对于这个问题大家怎么看呢？留言说出你的看法吧。</p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有近 1000 位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Type" scheme="https://www.bennyhuo.com/tags/type/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 1.4 新特性预览</title>
    <link href="https://www.bennyhuo.com/2020/03/26/kotlin-1.4-preview/"/>
    <id>https://www.bennyhuo.com/2020/03/26/kotlin-1.4-preview/</id>
    <published>2020-03-25T16:00:00.000Z</published>
    <updated>2020-05-08T08:25:34.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。</p></blockquote><a id="more"></a><h2 id="1-安装-Kotlin-1-4"><a href="#1-安装-Kotlin-1-4" class="headerlink" title="1. 安装 Kotlin 1.4"></a>1. 安装 Kotlin 1.4</h2><p>Kotlin 1.4 的第一个里程碑版本发布了，具体发布信息可以在<a href="https://github.com/JetBrains/kotlin/blob/1.4-M1/ChangeLog.md" target="_blank" rel="noopener">这里查看</a>。</p><p>生产环境当中最好仍然使用 Kotlin 的稳定版本（例如最新的 1.3.71），如果你想要立刻马上体验 1.4 的新特性，那么我的建议是先安装一个 EAP 版本的 IntelliJ IDEA EAP 版本是 IntelliJ IDEA 2020.1 Beta，然后再在这个版本的 IntelliJ 上安装最新版的 Kotlin 插件，这样既可以继续使用 1.3 做项目，又不耽误体验新特性：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-10-40.png" alt=""></p><p><strong><center>图 1：IntelliJ IDEA EAP 版本与正式版可以共存</center></strong></p><p>安装 Kotlin 1.4 的插件方法想必大家都已经轻车熟路了，打开设置，搜 Kotlin，找到插件版本管理的下拉菜单，选择 Early Access Preview 1.4.x 即可：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-20-21.png" alt=""></p><p><strong><center>图 2：升级 Kotlin 插件</center></strong></p><p>好了，重启 IntelliJ，新建一个工程试试看吧~~</p><h2 id="2-主要的语法更新"><a href="#2-主要的语法更新" class="headerlink" title="2. 主要的语法更新"></a>2. 主要的语法更新</h2><p>接下来我们就按照官方博客给出的介绍 <a href="https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-4-m1-released/" target="_blank" rel="noopener">Kotlin 1.4-M1 Released</a> 来体验下新特性。</p><p>本文源码均已整理至 GitHub：<a href="https://github.com/enbandari/Kotlin1.4FeaturesSample" target="_blank" rel="noopener">Kotlin1.4FeaturesSample</a>。</p><h3 id="2-1-Kotlin-接口和函数的-SAM-转换"><a href="#2-1-Kotlin-接口和函数的-SAM-转换" class="headerlink" title="2.1 Kotlin 接口和函数的 SAM 转换"></a>2.1 Kotlin 接口和函数的 SAM 转换</h3><p>一个就是大家期待已久的 Kotlin 接口和函数的 SAM 转换。得益于新的类型推导算法，之前一直只有调用接收 Java 单一方法接口的 Java 的方法时才可以有 SAM 转换，现在这个问题不存在了，且看例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意 fun interface 是新特性</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> interface Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin 函数，参数为 Kotlin 单一方法接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runAction</span><span class="params">(a: <span class="type">Action</span>)</span></span> = a.run()</span><br><span class="line"><span class="comment">// Kotlin 函数，参数为 Java 单一方法接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runRunnable</span><span class="params">(r: <span class="type">Runnable</span>)</span></span> = r.run()</span><br></pre></td></tr></table></figure><p>在 1.4 以前，我们只能：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runAction(<span class="keyword">object</span>: Action&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Not good.."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runAction(Action &#123; println(<span class="string">"Not good.."</span>) &#125;)</span><br></pre></td></tr></table></figure><p>runRunnable 函数虽然接收的是 Java 的接口，同样不支持 SAM。</p><p>现在在 1.4 当中呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runAction &#123; println(<span class="string">"Hello, Kotlin 1.4!"</span>) &#125;</span><br><span class="line">runRunnable &#123; println(<span class="string">"Hello, Kotlin 1.4!"</span>) &#125;</span><br></pre></td></tr></table></figure><p>真是妙啊。</p><h3 id="2-2-类型推导支持了更多的场景"><a href="#2-2-类型推导支持了更多的场景" class="headerlink" title="2.2 类型推导支持了更多的场景"></a>2.2 类型推导支持了更多的场景</h3><p>类型推导让 Kotlin 的语法获得了极大的简洁性。不过，大家在使用 Kotlin 开发时，一定会发现有些情况下明明类型是很确定的，编译器却一定要让我们显式的声明出来，这其实就是类型推导算法没有覆盖到的场景了。</p><p>例如以下代码在 Kotlin 1.3 当中会提示类型不匹配的问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rulesMap: Map&lt;String, (String?) -&gt; <span class="built_in">Boolean</span>&gt; = mapOf(</span><br><span class="line">    <span class="string">"weak"</span> to &#123; it != <span class="literal">null</span> &#125;,</span><br><span class="line">    <span class="string">"medium"</span> to &#123; !it.isNullOrBlank() &#125;,</span><br><span class="line">    <span class="string">"strong"</span> to &#123; it != <span class="literal">null</span> &amp;&amp; <span class="string">"^[a-zA-Z0-9]+$"</span>.toRegex().matches(it) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-47-00.png" alt=""></p><p><strong><center>图 3：Kotlin 1.3 中提示类型不匹配</center></strong></p><p>博客原文中给出的这个例子乍一看挺复杂，仔细想想问题主要在于我们可以通过 rulesMap 的类型来确定 mapOf 的返回值类型，进而再确定出 mapOf 的参数类型，即 Pair 的泛型参数类型。类型信息是充分的，不过这段代码在 Kotlin 1.4 以前是无法通过编译的，应该是类型推导的层次有点儿多导致算法没有覆盖到。好在新的推导算法解决了这个问题，能够应付更加复杂的推导场景。</p><h3 id="2-3-Lambda-表达式最后一行的智能类型转换"><a href="#2-3-Lambda-表达式最后一行的智能类型转换" class="headerlink" title="2.3 Lambda 表达式最后一行的智能类型转换"></a>2.3 Lambda 表达式最后一行的智能类型转换</h3><p>这个比较容易理解，直接看例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = run &#123;</span><br><span class="line">    <span class="keyword">var</span> str = currentValue()</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">        str = <span class="string">"test"</span></span><br><span class="line">    &#125;</span><br><span class="line">    str <span class="comment">// the Kotlin compiler knows that str is not null here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The type of 'result' is String? in Kotlin 1.3 and String in Kotlin 1.4</span></span><br></pre></td></tr></table></figure><p>这里 result 作为 run 的返回值，实际上也是 run 的参数 Lambda 的返回值，因此它的类型需要通过 str 的类型来推断。</p><p>在 1.3 当中，str 的类型是可以推断成 String 的，因为 str 是个局部变量，对它的修改是可控的。问题在于虽然 str 被推断为 String 类型，Lambda 表达式的返回值类型却没有使用推断的类型 String 来判断，而是选择使用了 str 的声明类型 String?。</p><p>在 1.4 解决了这个问题，既然 str 可以被推断为 String，那么 Lambda 表达式的结果自然就是 String 了。</p><p>稍微提一下，IntelliJ 的类型提示貌似有 bug，有些情况下会出现不一致的情况：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-12-55-09.png" alt=""></p><p><strong><center>图 4：疑似 IntelliJ 行内的类型提示的 bug</center></strong></p><p>我们可以通过快捷键查看 result 的类型为 String，但是行内的类型提示却为 String?，不过这个不影响程序的运行。</p><p>当然，有些开发者经常会抱怨类似下面的这种情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="string">"Hello"</span></span><br><span class="line">    <span class="keyword">if</span>(x != <span class="literal">null</span>)&#123;</span><br><span class="line">        println(x.length) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我明明已经判断了 x 不为空，为什么却不能自动推导成 String？请一定要注意，这种情况不是类型推导算法的问题，而是 x 的类型确实无法推导，因为对于一个共享的可变变量来讲，任何前一秒的判断都无法作为后一秒的依据。</p><h3 id="2-4-带有默认参数的函数的类型支持"><a href="#2-4-带有默认参数的函数的类型支持" class="headerlink" title="2.4 带有默认参数的函数的类型支持"></a>2.4 带有默认参数的函数的类型支持</h3><p>如果一个函数有默认参数，我们在调用它的时候就可以不传入这个参数了，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span> = <span class="number">0</span>)</span></span>: String = <span class="string">"<span class="variable">$i</span>!"</span></span><br></pre></td></tr></table></figure><p>调用的时候既可以是 foo() 也可以是 foo(5)，看上去就如同两个函数一样。在 1.4 以前，如果我们想要获取它的引用，就只能获取到 (Int) -&gt; String 这样的类型，显得不是很方便，现在这个问题解决了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">apply1</span><span class="params">(func: ()</span></span> -&gt; String): String = func()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">apply2</span><span class="params">(func: (<span class="type">Int</span>)</span></span> -&gt; String): String = func(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(apply1(::foo))</span><br><span class="line">    println(apply2(::foo))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过请注意，通常情况下 ::foo 的类型始终为 (Int) -&gt; String，除了作为参数传递给接收 () -&gt; String 的情况下编译器会自动帮忙转换以外，其他情况下是不可以的。</p><h3 id="2-5-属性代理的类型推导"><a href="#2-5-属性代理的类型推导" class="headerlink" title="2.5 属性代理的类型推导"></a>2.5 属性代理的类型推导</h3><p>在推断代理表达式的类型时，以往不会考虑属性代理的类型，因此我们经常需要在代理表达式中显式的声明泛型参数，下面的例子就是这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prop: String? <span class="keyword">by</span> Delegates.observable(<span class="literal">null</span>) &#123; p, old, new -&gt;</span><br><span class="line">        println(<span class="string">"<span class="variable">$old</span> → <span class="variable">$new</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    prop = <span class="string">"abc"</span></span><br><span class="line">    prop = <span class="string">"xyz"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子在 1.4 中可以运行，但如果是在 1.3 当中，就需要明确泛型类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prop: String? <span class="keyword">by</span> Delegates.observable&lt;String?&gt;(<span class="literal">null</span>) &#123; p, old, new -&gt;</span><br><span class="line">    println(<span class="string">"<span class="variable">$old</span> → <span class="variable">$new</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-混合位置参数和具名参数"><a href="#2-6-混合位置参数和具名参数" class="headerlink" title="2.6 混合位置参数和具名参数"></a>2.6 混合位置参数和具名参数</h3><p>位置参数就是按位置传入的参数，Java 当中只有位置参数，是大家最熟悉的写法。Kotlin 支持了具名参数，那么入参时二者混合使用会怎样呢？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-06-09.png" alt=""></p><p><strong><center>图 5：1.3 当中不允许在具名参数之后添加位置参数</center></strong></p><p>1.3 当中，第三个参数会提示错误，理由就是位置参数前面已经有了具名参数了，这是禁止的。这样主要的目的也是希望开发者能够避免写出混乱的入参例子，不过这个例子似乎并不会有什么令人疑惑的地方，于是 1.4 我们可以在具名参数后面跟位置参数啦。</p><p>其实这个特性并不会对入参有很大的影响。首先位置参数的位置仍然必须是对应的，其次具名参数的位置也不能乱来。例如我们为例子中的 a 添加一个默认值：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-16-35.png" alt=""></p><p><strong><center>图 6：1.4 当中具名参数之后添加位置参数需要保证位置对应</center></strong></p><p>注意图 6 是 1.4 环境下的情形，这样调用时我们就可以不必显式的传入 a 的值了，这时候直觉告诉我参数 b 后面的参数应该是 c，然而编译器却不领情。这样看来，即便是在 1.4 当中，我们也需要确保具名参数和位置参数与形参的位置对应才能在具名参数之后添加位置参数。</p><p>因此，我个人的建议是对于参数比较多且容易混淆的情形最好都以具名参数的形式给出，对于参数个数较少的情形则可以全部采用位置参数。在这里还有另外的一个建议就是函数的参数不宜过多，参数越多意味着函数复杂度越高，越可能需要重构。</p><h3 id="2-7-优化属性代理的编译"><a href="#2-7-优化属性代理的编译" class="headerlink" title="2.7 优化属性代理的编译"></a>2.7 优化属性代理的编译</h3><p>如果大家自己写过属性代理类的话，一定知道 get 和 set 两个函数都有一个 KProperty 的参数，这个参数其实就是被代理的属性。为了获取这个参数，编译器会生成一个数组来存放这代理的属性，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> lazyProp <span class="keyword">by</span> lazy &#123; <span class="number">42</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后生成的字节码反编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">bennyhuo</span>.<span class="title">kotlin</span>.<span class="title">MyOtherClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> kotlin.reflect.KProperty[] $$delegatedProperties;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getLazyProp</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> com.bennyhuo.kotlin.MyOtherClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 $$delegatedProperties 这个数组就是我们所说的存被代理的属性的数组。不过，绝大多数的属性代理其实不会用到 KProperty 对象，因此无差别的生成这个数组其实存在一定的浪费。</p><p>因此对于属性代理类的 get 和 set 函数实现为内联函数的情形，编译器可以确切的分析出 KProperty 是否被用到，如果没有被用到，那么就不会生成这个 KProperty 对象。</p><p>这里还有一个细节，如果一个类当中同时存在用到和没用到 KProperty 对象的两类属性代理，那么生成的数组在 1.4 当中只包含用到的 KProperty 对象，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> lazyProp <span class="keyword">by</span> lazy &#123; <span class="number">42</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> myProp: String <span class="keyword">by</span> Delegates.observable(<span class="string">"&lt;no name&gt;"</span>) &#123;</span><br><span class="line">            kProperty, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">"<span class="subst">$&#123;kProperty.name&#125;</span>: <span class="variable">$oldValue</span> -&gt; <span class="variable">$newValue</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 myProp 用到了 KProperty 对象，lazyProp 没有用到，那么生成的 $$delegatedProperties 当中就只包含 myProp 的属性引用了。</p><h3 id="2-8-参数列表最后的逗号"><a href="#2-8-参数列表最后的逗号" class="headerlink" title="2.8 参数列表最后的逗号"></a>2.8 参数列表最后的逗号</h3><p>这个需求别看小，非常有用。我们来看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(</span><br><span class="line">        <span class="string">"bennyhuo"</span>,</span><br><span class="line">        <span class="number">30</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person 类有多个参数，传参的时候就会出现前面的参数后面都有个逗号，最后一个没有。这样看上去好像也没什么问题是吧？那有可能你没有用到过多行编辑：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-04-01.png" alt=""></p><p><strong><center>图 7：多行编辑逗号的问题</center></strong></p><p>这里这个逗号有时候会特别碍事儿，但如何每一行都可以有一个逗号这个问题就简单多了：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-05-25.png" alt=""></p><p><strong><center>图 8：多行编辑所有参数</center></strong></p><p>除了这个场景之外，还有就是调整参数列表的时候，例如我给 Person 在最后加了个 id，我还得单独给 age 的参数后面加个逗号：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-08-36.png" alt=""></p><p><strong><center>图 9：增加参数给原来的参数加逗号</center></strong></p><p>这时候我又觉得 id 应该放到最前面，于是做了个复制粘贴，发现还是要修改逗号。当然，最后的这个功能 IntelliJ 有个快捷键可以直接交换行，同时帮我们自动处理逗号的问题，不过整体上这个小功能还是很有意思的。</p><p>说起来，JavaScript 当中的对象字面量当中也允许最后一个字段后面加逗号：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-12-48.png" alt=""></p><p><strong><center>图 10：JavaScript 的对象字面量</center></strong></p><p>不过请注意，尽管它与 JSON 有着深厚的渊源，但 JSON 的最后一个字段后面是不允许加逗号的（当然还有字段要加引号）。</p><h3 id="2-9-when-表达式中使用-continue-和-break"><a href="#2-9-when-表达式中使用-continue-和-break" class="headerlink" title="2.9 when 表达式中使用 continue 和 break"></a>2.9 when 表达式中使用 continue 和 break</h3><p>continue 和 break 的含义没有任何变化，这二者仍然在循环当中使用，只不过循环内部的 when 表达式当中在之前是不可以使用 continue 和 break 的，按照官方的说法，他们之前有意将 continue 或者 break 用作 when 表达式条件 fallthrough 的，不过看样子现在还没想好，只是不想再耽误 continue 和 break 的正常功能了。</p><h3 id="2-10-尾递归函数的优化"><a href="#2-10-尾递归函数的优化" class="headerlink" title="2.10 尾递归函数的优化"></a>2.10 尾递归函数的优化</h3><p>尾递归函数估计大家用的不多，这里主要有两个优化点</p><ul><li>尾递归函数的默认参数的初始化顺序改为从左向右：</li><li>尾递归函数不能声明为 open 的，即不能被子类覆写，因为尾递归函数的形式有明确的要求，即函数的最后一个操作必须只能是调用自己，父类的函数声明为 tailrec 并不能保证子类能够正确地按要求覆写，于是产生矛盾。</li></ul><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-25-23.png" alt=""></p><p><strong><center>图 11：1.4 中尾递归函数的默认参数列表初始化顺序</center></strong></p><h3 id="2-11-契约的支持"><a href="#2-11-契约的支持" class="headerlink" title="2.11 契约的支持"></a>2.11 契约的支持</h3><p>从 1.3 开始，Kotlin 引入了一个实验特性契约（Contract），主要来应对一些“显而易见”情况下的类型推导或者智能类型转换。</p><p>在 1.4 当中，这个特性仍然会继续保持实验状态，不过有两项改进：</p><ul><li>支持使用内联特化的函数来实现契约</li><li>1.3当中不能为成员函数添加契约，从1.4开始支持为 final 的成员函数添加契约（当然任意成员函数可能存在被覆写的问题，因而不能添加）</li></ul><h3 id="2-12-其他的一些改动"><a href="#2-12-其他的一些改动" class="headerlink" title="2.12 其他的一些改动"></a>2.12 其他的一些改动</h3><p>除了语法上的明显的改动之外，1.4 当中也直接移除了 1.1-1.2 当中协程的实验阶段的 API，有条件的情况下应该尽快去除对废弃的协程 API 的使用，如果暂时无法完成迁移，也可以使用协程的兼容包 kotlin-coroutines-experimental-compat.jar。</p><p>剩下的主要就是针对编译器、使用体验的各种优化了，实际上这才是 Kotlin 1.4 最重要的工作。这些内容相对抽象，我就不做介绍了。</p><p>补充一点，在本文撰写过程中，我使用 IntelliJ IDEA 2019.3.3 来运行 Kotlin 1.3，使用 IntelliJ IDEA 2020.1 BETA 来运行 Kotlin 1.4-M1，结果发现后者的代码提示速度似乎有明显的提升，不知道是不是我的错觉，大家可以自行感受下并发表你的评论。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>Kotlin 目前的语法已经比较成熟了，还是那句话，提升开发体验，扩展应用场景才是它现在最应该发力的点。</p><p>未来可期。</p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有近 1000 位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="News" scheme="https://www.bennyhuo.com/tags/news/"/>
    
      <category term="Release" scheme="https://www.bennyhuo.com/tags/release/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(11) - Flow 篇</title>
    <link href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/"/>
    <id>https://www.bennyhuo.com/2020/03/14/coroutine-flow/</id>
    <published>2020-03-13T16:00:00.000Z</published>
    <updated>2020-05-08T08:25:34.383Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。</p></blockquote><a id="more"></a><p>随着 RxJava 的流行，响应式编程模型逐步深入人心。<code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物。</p><p><em>本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶段，后续也可能会发生细微的调整。</em></p><h2 id="认识-Flow"><a href="#认识-Flow" class="headerlink" title="认识 Flow"></a>认识 Flow</h2><p>介绍 <code>Flow</code> 之前，我们先来回顾下序列生成器：</p><p><strong>代码清单1： 序列生成器</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ints = sequence &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; </span><br><span class="line">    yield(it)</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次访问 <code>ints</code> 的下一个元素的时候它就执行内部的逻辑直到遇到 <code>yield</code>，如果我希望在元素之间加个延时呢？</p><p><strong>代码清单2：序列生成器中不能调用其他挂起函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ints = sequence &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; </span><br><span class="line">    yield(it)</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// ERROR!</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受 <code>RestrictsSuspension</code> 注解的约束，<code>delay</code> 不能在 <code>SequenceScope</code> 的扩展成员当中被调用，因而不能在序列生成器的协程体内调用了。</p><p>假设序列生成器不受这个限制，调用 <code>delay</code> 会导致后续的执行流程的线程发生变化，外部的调用者发现在访问 <code>ints</code> 的下一个元素的时候居然还会有切换线程的副作用，这个是不是算一个“惊喜”呢？不仅如此，我想通过指定调度器来限定序列创建所在的线程，同样是不可以的，我们甚至没有办法为它设置协程上下文。</p><p>既然序列生成器有这么多限制，那我们是时候需要认识一下 <code>Flow</code> 了。它的 API 与序列生成器极为相似：</p><p><strong>代码清单3：创建 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intFlow = flow &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; </span><br><span class="line">    emit(it)</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新元素通过 <code>emit</code> 函数提供，Flow 的执行体内部也可以调用其他挂起函数，这样我们就可以在每次提供一个新元素后再延时 100ms 了。</p><p>Flow 也可以设定它运行时所使用的调度器：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intFlow.flowOn(Dispatchers.IO)</span><br></pre></td></tr></table></figure><p>通过 <code>flowOn</code> 设置的调度器只对它之前的操作有影响，因此这里意味着 intFlow 的构造逻辑会在 <code>IO</code> 调度器上执行。</p><p>最终消费 <code>intFlow</code> 需要调用 <code>collect</code> 函数，这个函数也是一个挂起函数，我们启动一个协程来消费 <code>intFlow</code>：</p><p><strong>代码清单4： 消费 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(myDispatcher) &#123;</span><br><span class="line">  intFlow.flowOn(Dispatchers.IO)</span><br><span class="line">    .collect &#123; println(it) &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><p>为了区分调度器，我们为协程设置了一个自定义的调度器，它会将协程调度到名叫 <code>MyThread</code> 的线程上，结果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[MyThread] <span class="number">1</span></span><br><span class="line">[MyThread] <span class="number">2</span></span><br><span class="line">[MyThread] <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="对比-RxJava-的线程切换"><a href="#对比-RxJava-的线程切换" class="headerlink" title="对比 RxJava 的线程切换"></a>对比 RxJava 的线程切换</h2><p>RxJava 也是一个基于响应式编程模型的异步框架，它提供了两个切换调度器的 API 分别是 <code>subscribeOn</code> 和 <code>observeOn</code>：</p><p><strong>代码清单5：RxJava 的调度器切换</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; e -&gt;</span><br><span class="line">    it.onNext(e)</span><br><span class="line">  &#125;</span><br><span class="line">  it.onComplete()</span><br><span class="line">&#125;.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(Schedulers.from(myExecutor))</span><br><span class="line">.subscribe &#123;</span><br><span class="line">  println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>subscribeOn</code> 指定的调度器影响前面的逻辑，<code>observeOn</code> 影响的是后面的逻辑，因此 <code>it.onNext(e)</code> 执行在它的 <code>io</code> 这个调度器上，而最后的 <code>println(it)</code> 执行在通过 <code>myExecutor</code> 创建出来的调度器上。</p><p>Flow 的调度器 API 中看似只有 <code>flowOn</code> 与 <code>subscribeOn</code> 对应，其实不然， <code>collect</code> 所在协程的调度器则与 <code>observeOn</code> 指定的调度器对应。</p><p>在 RxJava 的学习和使用过程中， <code>subscribeOn</code> 和 <code>observeOn</code> 经常容易被混淆；而在 Flow 当中 <code>collect</code> 所在的协程自然就是观察者，它想运行在什么调度器上它自己指定即可，非常容易区分。</p><h2 id="冷数据流"><a href="#冷数据流" class="headerlink" title="冷数据流"></a>冷数据流</h2><p>一个 Flow 创建出来之后，不消费则不生产，多次消费则多次生产，生产和消费总是相对应的。</p><p><strong>代码清单6：Flow 可以被重复消费</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><p><code>intFlow</code> 就是本节最开始我们创建的 Flow，消费它会输出 1,2,3，重复消费它会重复输出 1,2,3。</p><p>这一点其实类似于我们前面提到的 <code>sequence</code> 和 RxJava 例子，它们也都有自己的消费端。我们创建一个序列然后去迭代它，每次迭代都会创建一个新的迭代器从头开始迭代；RxJava 的 <code>Observable</code> 也是如此，每次调用它的 <code>subscribe</code> 都会重新消费一次。</p><p>所谓<strong>冷</strong>数据流，就是只有消费时才会生产的数据流，这一点与 <code>Channel</code> 正对应：<code>Channel</code> 的发送端并不依赖于接收端。</p><blockquote><p><strong>说明</strong> RxJava 也存在热数据流，可以通过一定的手段实现冷热数据流的转化。不过相比之下，冷数据流的应用场景更为丰富。</p></blockquote><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Flow 的异常处理也比较直接，直接调用 <code>catch</code> 函数即可：</p><p><strong>代码清单7：捕获 Flow 的异常</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">"Div 0"</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">"caught error: <span class="variable">$t</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 Flow 的参数中抛了一个异常，在 <code>catch</code> 函数中就可以直接捕获到这个异常。如果没有调用 <code>catch</code> 函数，未捕获异常会在消费时抛出。请注意，<code>catch</code> 函数只能捕获它的上游的异常。</p><p>如果我们想要在流完成时执行逻辑，可以使用 <code>onCompletion</code>：</p><p><strong>代码清单8：订阅流的完成</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">"Div 0"</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">"caught error: <span class="variable">$t</span>"</span>)</span><br><span class="line">&#125;.onCompletion &#123; t: Throwable? -&gt;</span><br><span class="line">  println(<span class="string">"finally."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onCompletion</code> 用起来比较类似于 <code>try ... catch ... finally</code> 中的 <code>finally</code>，无论前面是否存在异常，它都会被调用，参数 <code>t</code> 则是前面未捕获的异常。</p><p>Flow 的设计初衷是希望确保流操作中异常透明。因此，以下写法是违反 Flow 的设计原则的：</p><p><strong>代码清单9：命令式的异常处理（不推荐）</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flow &#123; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    emit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> ArithmeticException(<span class="string">"Div 0"</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (t: Throwable)&#123;</span><br><span class="line">    println(<span class="string">"caught error: <span class="variable">$t</span>"</span>)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    println(<span class="string">"finally."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在流操作内部使用 <code>try ... catch ... finally</code> 这样的写法后续可能被禁用。</p><p>在 RxJava 当中还有 <code>onErrorReturn</code> 类似的操作：</p><p><strong>代码清单10：RxJava 从异常中恢复</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> observable = Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;.onErrorReturn &#123;</span><br><span class="line">  println(t)</span><br><span class="line">  <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获异常后，返回 10 作为下一个值。</p><p>我们在 Flow 当中也可以模拟这样的操作：</p><p><strong>代码清单11：Flow 从异常中恢复</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">"Div 0"</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">"caught error: <span class="variable">$t</span>"</span>)</span><br><span class="line">  emit(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以使用 <code>emit</code> 重新生产新元素出来。细心的读者一定会发现，<code>emit</code> 定义在 <code>FlowCollector</code> 当中，因此只要遇到 Receiver 为 <code>FlowCollector</code> 的函数，我们就可以生产新元素。</p><blockquote><p><strong>说明</strong> onCompletion 预计在协程框架的 1.4 版本中会被重新设计，之后它的作用类似于 RxJava 中 Subscriber 的 onComplete，即作为整个 Flow 的完成回调使用，回调的参数也将包含整个 Flow 的未捕获异常，参见 GitHub Issue：<a href="https://github.com/Kotlin/kotlinx.coroutines/pull/1732" target="_blank" rel="noopener">Breaking change: Experimental Flow.onCompletion contract for cause #1732</a>。</p></blockquote><h2 id="末端操作符"><a href="#末端操作符" class="headerlink" title="末端操作符"></a>末端操作符</h2><p>前面的例子当中，我们用 <code>collect</code> 消费 Flow 的数据。<code>collect</code> 是最基本的<strong>末端操作符</strong>，功能与 RxJava 的 <code>subscribe</code> 类似。除了 <code>collect</code> 之外，还有其他常见的末端操作符，大体分为两类：</p><ol><li>集合类型转换操作，包括 <code>toList</code>、<code>toSet</code> 等。</li><li>聚合操作，包括将 Flow 规约到单值的 <code>reduce</code>、<code>fold</code> 等操作，以及获得单个元素的操作包括 <code>single</code>、<code>singleOrNull</code>、<code>first</code> 等。</li></ol><p>实际上，识别是否为末端操作符，还有一个简单方法，由于 Flow 的消费端一定需要运行在协程当中，因此末端操作符都是挂起函数。</p><h2 id="分离-flow-的消费和触发"><a href="#分离-flow-的消费和触发" class="headerlink" title="分离 flow 的消费和触发"></a>分离 flow 的消费和触发</h2><p>我们除了可以在 <code>collect</code> 处消费 Flow 的元素以外，还可以通过 <code>onEach</code> 来做到这一点。这样消费的具体操作就不需要与末端操作符放到一起，<code>collect</code> 函数可以放到其他任意位置调用，例如：</p><p><strong>代码清单12：分离 Flow 的消费和触发</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createFlow</span><span class="params">()</span></span> = flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">      emit(it)</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.onEach &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  GlobalScope.launch &#123;</span><br><span class="line">    createFlow().collect()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此，我们又可以衍生出一种新的消费 Flow 的写法：</p><p><strong>代码清单13：使用协程作用域直接触发 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  createFlow().launchIn(GlobalScope)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>launchIn</code> 函数只接收一个 <code>CoroutineScope</code> 类型的参数。</p><h2 id="Flow-的取消"><a href="#Flow-的取消" class="headerlink" title="Flow 的取消"></a>Flow 的取消</h2><p>Flow 没有提供取消操作，原因很简单：不需要。</p><p>我们前面已经介绍了 Flow 的消费依赖于 <code>collect</code> 这样的末端操作符，而它们又必须在协程当中调用，因此 Flow 的取消主要依赖于末端操作符所在的协程的状态。</p><p><strong>代码清单14：Flow 的取消</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">  <span class="keyword">val</span> intFlow = flow &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">      delay(<span class="number">1000</span>)</span><br><span class="line">      emit(it)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">2500</span>)</span><br><span class="line">job.cancelAndJoin()</span><br></pre></td></tr></table></figure><p>每隔 1000ms 生产一个元素，2500ms 以后协程被取消，因此最后一个元素生产前 Flow 就已经被取消，输出为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">▶ <span class="number">1000</span>ms later</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>如此看来，想要取消 Flow 只需要取消它所在的协程即可。</p><h2 id="其他-Flow-的创建方式"><a href="#其他-Flow-的创建方式" class="headerlink" title="其他 Flow 的创建方式"></a>其他 Flow 的创建方式</h2><p>我们已经知道了 <code>flow { ... }</code> 这种形式的创建方式，不过在这当中无法随意切换调度器，这是因为 <code>emit</code> 函数不是线程安全的：</p><p><strong>代码清单15：不能在 Flow 中直接切换调度器</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flow &#123; <span class="comment">// BAD!!</span></span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  withContext(Dispatchers.IO)&#123;</span><br><span class="line">    emit(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在生成元素时切换调度器，就必须使用 <code>channelFlow</code> 函数来创建 Flow：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channelFlow &#123;</span><br><span class="line">  send(<span class="number">1</span>)</span><br><span class="line">  withContext(Dispatchers.IO) &#123;</span><br><span class="line">    send(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，我们也可以通过集合框架来创建 Flow：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asFlow()</span><br><span class="line">setOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asFlow()</span><br><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="Flow-的背压"><a href="#Flow-的背压" class="headerlink" title="Flow 的背压"></a>Flow 的背压</h2><p>只要是响应式编程，就一定会有背压问题，我们先来看看背压究竟是什么。</p><p>背压问题在生产者的生产速率高于消费者的处理速率的情况下出现。为了保证数据不丢失，我们也会考虑添加缓存来缓解问题：</p><p><strong>代码清单16：为 Flow 添加缓冲</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.buffer()</span><br></pre></td></tr></table></figure><p>我们也可以为 <code>buffer</code> 指定一个容量。不过，如果我们只是单纯地添加缓存，而不是从根本上解决问题就始终会造成数据积压。</p><p>问题产生的根本原因是生产和消费速率的不匹配，除直接优化消费者的性能以外，我们也可以采取一些取舍的手段。</p><p>第一种是 <code>conflate</code>。与 <code>Channel</code> 的 <code>Conflate</code> 模式一致，新数据会覆盖老数据，例如：</p><p><strong>代码清单17：使用 conflate 解决背压问题</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.conflate()</span><br><span class="line">.collect &#123; value -&gt;</span><br><span class="line">  println(<span class="string">"Collecting <span class="variable">$value</span>"</span>)</span><br><span class="line">  delay(<span class="number">100</span>) </span><br><span class="line">  println(<span class="string">"<span class="variable">$value</span> collected"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们快速地发送了 100 个元素，最后接收到的只有两个，当然这个结果每次都不一定一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting <span class="number">1</span></span><br><span class="line"><span class="number">1</span> collected</span><br><span class="line">Collecting <span class="number">99</span></span><br><span class="line"><span class="number">99</span> collected</span><br></pre></td></tr></table></figure><p>第二种是 <code>collectLatest</code>。顾名思义，只处理最新的数据，这看上去似乎与 <code>conflate</code> 没有区别，其实区别大了：它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p><p>还是前面的例子，我们稍作修改：</p><p><strong>代码清单18：使用 collectLatest 解决背压问题</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.collectLatest &#123; value -&gt;</span><br><span class="line">  println(<span class="string">"Collecting <span class="variable">$value</span>"</span>)</span><br><span class="line">  delay(<span class="number">100</span>)</span><br><span class="line">  println(<span class="string">"<span class="variable">$value</span> collected"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collecting 0</span><br><span class="line">Collecting 1</span><br><span class="line">...</span><br><span class="line">Collecting 97</span><br><span class="line">Collecting 98</span><br><span class="line">Collecting 99</span><br><span class="line">▶ 100ms later</span><br><span class="line">99 collected</span><br></pre></td></tr></table></figure><p>前面的 <code>Collecting</code> 输出了 0 ~ 99 的所有结果，而 <code>collected</code> 却只有 99，因为后面的数据到达时，处理上一个数据的操作正好被挂起了（请注意<code>delay(100)</code>）。</p><p>除 <code>collectLatest</code> 之外还有 <code>mapLatest</code>、<code>flatMapLatest</code> 等等，都是这个作用。</p><h2 id="Flow-的变换"><a href="#Flow-的变换" class="headerlink" title="Flow 的变换"></a>Flow 的变换</h2><p>我们已经对集合框架的变换非常熟悉了，<code>Flow</code> 看上去极其类似于这样的数据结构，这一点与 RxJava 的 <code>Observable</code> 的表现也基本一致。</p><p>例如我们可以使用 <code>map</code> 来变换 <code>Flow</code> 的数据：</p><p><strong>代码清单19：Flow 的元素变换</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123; </span><br><span class="line">  it * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以映射成其他 Flow：</p><p><strong>代码清单20：Flow 的嵌套</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123;</span><br><span class="line">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上得到的是一个数据类型为 <code>Flow</code> 的 <code>Flow</code>，如果希望将它们拼接起来，可以使用 <code>flattenConcat</code>：</p><p><strong>代码清单21：拼接 Flow</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123;</span><br><span class="line">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class="line">&#125;.flattenConcat()</span><br><span class="line">  .collect &#123; println(it) &#125;</span><br></pre></td></tr></table></figure><p>拼接的操作中 <code>flattenConcat</code> 是按顺序拼接的，结果的顺序仍然是生产时的顺序；还有一个是 <code>flattenMerge</code>，它会并发拼接，因此结果不会保证顺序。</p><h2 id="使用-Flow-实现多路复用"><a href="#使用-Flow-实现多路复用" class="headerlink" title="使用 Flow 实现多路复用"></a>使用 Flow 实现多路复用</h2><p>多数情况下，我们可以通过构造合适的 Flow 来实现多路复用的效果。</p><p>上一篇文章<a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程(10) - Select 篇</a>中对 await 的复用我们可以用 Flow 实现如下：</p><p><strong>代码清单22：使用 Flow 实现对 await 的多路复用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">coroutineScope &#123;</span><br><span class="line">  <span class="keyword">val</span> login = <span class="string">"..."</span></span><br><span class="line">  listOf(::getUserFromApi, ::getUserFromLocal) ... ①</span><br><span class="line">    .map &#123; function -&gt;</span><br><span class="line">      function.call(login) ... ②</span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123; deferred -&gt;</span><br><span class="line">      flow &#123; emit(deferred.await()) &#125; ... ③</span><br><span class="line">    &#125;</span><br><span class="line">    .merge() ... ④</span><br><span class="line">    .onEach &#123; user -&gt;</span><br><span class="line">      println(<span class="string">"Result: <span class="variable">$user</span>"</span>)</span><br><span class="line">    &#125;.launchIn(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中，① 处用创建了两个函数引用组成的 List；② 处调用它们得到 deferred；③ 处比较关键，对于每一个 deferred 我们创建一个单独的 Flow，并在 Flow 内部发送 deferred.await() 返回的结果，即返回的 User 对象；现在我们有了两个 Flow 实例，我们需要将它们整合成一个 Flow 进行处理，调用 merge 函数即可。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png" alt=""></p><p><strong>图1：使用 merge 合并 Flow</strong></p><p>同样的，对 Channel 的读取复用的场景也可以使用 Flow 来完成。对照<a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程(10) - Select 篇</a>，我们给出 Flow 的实现版本：</p><p><strong>代码清单23：使用 Flow 实现对 Channel 的复用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channels = List(<span class="number">10</span>) &#123; Channel&lt;<span class="built_in">Int</span>&gt;() &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> result = channels.map &#123;</span><br><span class="line">    it.consumeAsFlow()</span><br><span class="line">  &#125;</span><br><span class="line">  .merge()</span><br><span class="line">  .first()</span><br></pre></td></tr></table></figure><p>这比 <code>select</code> 的版本看上去要更简洁明了，每个 Channel 都通过 <code>consumeAsFlow</code> 函数被映射成 Flow，再 merge 成一个 Flow，取第一个元素。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Flow</code> 是协程当中比较重要的异步工具，它的用法与其他类似的响应式编程框架非常相近，大家可以采取类比的学习方式去了解它的功能。</p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有近 1000 位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;code&gt;Flow&lt;/code&gt; 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Flow" scheme="https://www.bennyhuo.com/tags/flow/"/>
    
      <category term="RxJava" scheme="https://www.bennyhuo.com/tags/rxjava/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 官网大变样？这是要干啥？</title>
    <link href="https://www.bennyhuo.com/2020/02/13/kotlin-news-202002/"/>
    <id>https://www.bennyhuo.com/2020/02/13/kotlin-news-202002/</id>
    <published>2020-02-12T16:00:00.000Z</published>
    <updated>2020-05-08T08:25:34.385Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。</p></blockquote><a id="more"></a><p>最近有小伙伴提醒我，Kotlin 官网更新了，我打开一看直接吓尿：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-34-00.png" alt=""></p><p>这是要干啥？我听说过的没听说过的您这是都要承包吗？</p><p>最有意思的是居然把 Android 放到了最后，hmmm，Kotlin 开发者里面搞 Android 的应该是最多的吧？这么不受待见？</p><p>所以我有个大胆的想法，Kotlin 团队肯定觉得 Android 大军切换 Kotlin 指日可待，基本上稳稳的，所以过河拆桥：Android 已经不再是 Kotlin 唯一的大腿啦，你们看看，最前面的是移动端跨平台，原来谷爸爸的大腿刚捂热乎，就又抱上了果爸爸，真是不得了哇：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-38-52.png" alt=""></p><p>其实很早之前我们就一直在聊到 Kotlin 2019 年的重心一定在 Native 上，当时觉得可能是盯上了 5G 时代的物联网的机会？不过一年过去了，5G 手机我还没用上，这不小米 10 刚发布，正琢磨要不要换个呢，嵌入式领域 C 称霸天下哪里会那么快换代，再说还有 Go 和 Rust 虎视眈眈，哪儿有 Kotlin 什么事儿。</p><p>不过从 Android 起家的 Kotlin 横向切入 iOS 这个路子真的是很合适，用户群体都不用怎么变，还让过去不会 iOS 的 Android 开发者有了更多更容易的机会扩展自己的技术栈，即可以扩大自己的影响力，又给开发者带来福利，真是双赢 666。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-17-54-20.png" alt=""></p><p>当然，这个移动端跨平台并不是什么特别新鲜的事儿，毕竟开源项目嘛，没事儿刷刷 Kotlin 的 <a href="https://kotl.in/slack" target="_blank" rel="noopener">Slack</a>，啥都能提前知道。而且本身 Kotlin 跨平台共享代码从 1.2 刚开始公测就理论上包含了 Kotlin-Jvm@Android 和 Kotlin-Native@iOS 的代码共享能力，所以我们似乎不应该意外，我只是想说 JetBrains 居然把移动端跨平台专门上升到了这么高的优先级，还专门做了 Kotlin Native 与 Objective-C &amp; Swift 的互调用的支持，真是任性~~</p><p>如果过一段时间 Dukat 这个项目逐渐成熟，Kotlin-Js 的编译工具也进一步完善，特别是对 npm 依赖的管理能更加灵活（目前 Kotlin-js 的 Gradle 依赖当中不会自动携带 npm 依赖这个让人非常难受），JavaScript 常见的框架都有了自己的 Kotlin 接口声明，那时候我估计写到最前面的也许还会发生一些变化，那时候也许叫 “Kotlin for 大前端”？</p><p>说到这里有人担心 Kotlin 这是不是在跟 Flutter 叫板。显然不是嘛，Kotlin 跨平台一直都声称自己只是为了逻辑代码的共享，UI 大家还是用原生的就好啦。于是乎 Android 原来该用 ConstraintLayout 你就用你的 XML 布局，iOS 呢就还是用你的 storyboard。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-02-29.png" alt=""></p><p>Flutter 抢的是 UI 的饭碗，UI 层跨平台的问题解决了，有人就说我们底层的逻辑也选一套跨平台的方案好不好？这要是放到几年前，怕是没有别的选择了，C++ 是最好的语言；而现在，你可以选择 Kotlin，最为神奇的是 Kotlin 的跨平台和 C++ 的机制非常不同，它在 Android 上使用 Kotlin-Jvm，iOS 上则使用 Kotlin-Native。你要是非想在 Android 上使用 JNI 的话，Kotlin-Native 也已经支持了绝大多数 Android 的 CPU 架构。所以很早就有人发文章报告 Flutter + Kotlin-Native 实现移动端跨平台开发的优秀体验，所以 Flutter 该学就学，不矛盾。</p><p>而且它俩的这基友关系嘛。。。依我看，这 Logo 就已经说明一切了。。。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-06-19.png" alt=""></p><p>还有一个比较引人注目的就是 <strong>Data science</strong> 了吧。毕竟 Python 因为这个都火的不得了了，过去的一年里我已经鼓动我们组好几个小伙伴上手 Python，要恰饭的嘛，艺多不压身，免得错过一些项目的机会。现在好了，Kotlin 也能搞科学计算了，目测大概的切入思路暂时还是依托于强大的 Jvm，Java 能用的框架 Kotlin 自然能用，Java 不能直接用的，例如 Python numpy，可以 JNI 直接搞一个封装 <a href="https://github.com/Kotlin/kotlin-numpy" target="_blank" rel="noopener">kotlin-numpy</a>；等 Kotlin Native 翅膀硬了之后就更省事儿了，直接跟 C 玩去，连 Jvm 都用不着了。这么发展着，最后也许是我的当然是我的，你的也是我的。。。</p><p>忘了说了，现在已经有了 Jupyter 的 Kotlin 内核，所以以前在 Jupyter Notebook 里用 Python 写的代码也可以用 Kotlin 写了，贴一张官网的效果图：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-16-54-47.png" alt=""></p><p>很美是吧，之前 KotlinConf 2019 期间官博就发了一篇文章介绍这个能力，也可以参考一下：Making Kotlin Ready for Data Science [<a href="https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/" target="_blank" rel="noopener">原文</a>] [<a href="https://www.kotliner.cn/2020/01/making-kotlin-ready-for-data-science/" target="_blank" rel="noopener">中文翻译</a>]。</p><p>顺便提一句，调用 GPU 其实也是 IO 操作，我看了几个 cuda 的程序都很有意思，要么是阻塞调用，要么就是异步调用之后在主流程里死循环等待结果返回。这似乎与我们的 Socket 读写类似，异步的 API 可能在大规模调用时性能更好，但代码编写起来更加复杂。前几天读到一篇论文讲的就是如何使用 C++ 的协程来降低 GPU 编程的复杂度(<a href="https://iopscience.iop.org/article/10.1088/1742-6596/681/1/012048/pdf" target="_blank" rel="noopener">Integrating GPGPU computations with CPU coroutines in C++</a>)，随着 Kotlin Native 的逐渐成熟稳定，我们可以直接通过 C 接口编写 GPU 相关程序，Kotlin 协程也许可以为 GPU 编程带来一定的便利。</p><p>这么看来，预计在 2020年春天发布的 Kotlin 1.4 的形势也比较明朗了，正如 Kotlin 之父 Andrey 说的，这个版本没有什么太多的新特性。因为作为一门语言本身，Kotlin 已经比较成熟，现在最应当关注的是开发体验，开发效率，稳定性，易用性以及应用场景等等语言生态的内容。</p><p>我之前还比较担心 Kotlin Multiplatform 和 Kotlin Native 会不会借此机会正式发布，从官网的这次改动来看，这样的担心应该是多余的了。我们来回顾一下过去 Kotlin 的重要版本的发布时间：</p><ul><li>Kotlin 1.0：2016.2</li><li>Kotlin 1.1：2017.3（13个月之后）</li><li>Kotlin 1.2：2017.11（8个月之后）</li><li>Kotlin 1.3：2018.10（11个月之后）</li></ul><p>多数情况下 Kotlin 的大版本都是保持一年左右一个的（1.2 这个版本估计是趁着热度努力冲了一波 KPI，毕竟 2017 年 Kotlin 出名了），小版本大概两个月一个，所以一般小版本到 1.x.7 的时候也就是下一个大版本发布的时间。现在 1.3.70 已经 EAP 了一个多月了，你们懂我意思吧。</p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有近 1000 位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="News" scheme="https://www.bennyhuo.com/tags/news/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(10) - Select 篇</title>
    <link href="https://www.bennyhuo.com/2020/02/03/coroutine-select/"/>
    <id>https://www.bennyhuo.com/2020/02/03/coroutine-select/</id>
    <published>2020-02-02T16:00:00.000Z</published>
    <updated>2020-05-08T08:25:34.382Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。</p></blockquote><a id="more"></a><h2 id="复用多个-await"><a href="#复用多个-await" class="headerlink" title="复用多个 await"></a>复用多个 await</h2><p>我们前面已经接触了很多挂起函数，那么如果我有这样一个场景，两个 API 分别从网络和本地缓存获取数据，期望哪个先返回就先用哪个做展示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">getUserFromApi</span><span class="params">(login: <span class="type">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class="line">    gitHubServiceApi.getUserSuspend(login)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">getUserFromLocal</span><span class="params">(login:<span class="type">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class="line">    File(localDir, login).takeIf &#123; it.exists() &#125;?.readText()?.let &#123; gson.fromJson(it, User::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管先调用哪个 API 返回的 <code>Deferred</code> 的 <code>await</code>，都会被挂起，如果想要实现这一需求就要启动两个协程来调用 <code>await</code>，这样反而将问题复杂化了。</p><p>接下来我们用 <code>select</code> 来解决这个问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> localDeferred = getUserFromLocal(login)</span><br><span class="line">    <span class="keyword">val</span> remoteDeferred = getUserFromApi(login)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userResponse = select&lt;Response&lt;User?&gt;&gt; &#123;</span><br><span class="line">        localDeferred.onAwait &#123; Response(it, <span class="literal">true</span>) &#125;</span><br><span class="line">        remoteDeferred.onAwait &#123; Response(it, <span class="literal">false</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><p>大家可以看到，我们没有直接调用 <code>await</code>，而是调用了 <code>onAwait</code> 在 <code>select</code> 当中注册了个回调，不管哪个先回调，<code>select</code> 立即返回对应回调中的结果。假设 <code>localDeferred.onAwait</code> 先返回，那么 <code>userResponse</code> 的值就是 <code>Response(it, true)</code>，当然由于我们的本地缓存可能不存在，因此 <code>select</code> 的结果类型是 <code>Response&lt;User?&gt;</code>。</p><p>对于这个案例本身，如果先返回的是本地缓存，那么我们还需要获取网络结果来展示最新结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    ...</span><br><span class="line">    userResponse.value?.let &#123; log(it) &#125;</span><br><span class="line">    userResponse.isLocal.takeIf &#123; it &#125;?.let &#123;</span><br><span class="line">        <span class="keyword">val</span> userFromApi = remoteDeferred.await()</span><br><span class="line">        cacheUser(login, userFromApi)</span><br><span class="line">        log(userFromApi)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure><h2 id="复用多个-Channel"><a href="#复用多个-Channel" class="headerlink" title="复用多个 Channel"></a>复用多个 Channel</h2><p>对于多个 <code>Channel</code> 的情况，也比较类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channels = List(<span class="number">10</span>) &#123; Channel&lt;<span class="built_in">Int</span>&gt;() &#125;</span><br><span class="line"></span><br><span class="line">select&lt;<span class="built_in">Int</span>?&gt; &#123;</span><br><span class="line">    channels.forEach &#123; channel -&gt;</span><br><span class="line">        channel.onReceive &#123; it &#125;</span><br><span class="line">        <span class="comment">// OR</span></span><br><span class="line">        channel.onReceiveOrNull &#123; it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>onReceive</code>，如果 <code>Channel</code> 被关闭，<code>select</code> 会直接抛出异常；而对于 <code>onReceiveOrNull</code> 如果遇到 <code>Channel</code> 被关闭的情况，<code>it</code> 的值就是 <code>null</code>。</p><h2 id="SelectClause"><a href="#SelectClause" class="headerlink" title="SelectClause"></a>SelectClause</h2><p>我们怎么知道哪些事件可以被 <code>select</code> 呢？其实所有能够被 <code>select</code> 的事件都是 <code>SelectClauseN</code> 类型，包括：</p><ul><li><p><code>SelectClause0</code>：对应事件没有返回值，例如 <code>join</code> 没有返回值，对应的 <code>onJoin</code> 就是这个类型，使用时 <code>onJoin</code> 的参数是一个无参函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    job.onJoin &#123; log(<span class="string">"Join resumed!"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>SelectClause1</code>：对应事件有返回值，前面的 <code>onAwait</code> 和 <code>onReceive</code> 都是此类情况。</p></li><li><p><code>SelectClause2</code>：对应事件有返回值，此外还需要额外的一个参数，例如 <code>Channel.onSend</code> 有两个参数，第一个就是一个 <code>Channel</code> 数据类型的值，表示即将发送的值，第二个是发送成功时的回调：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List(<span class="number">100</span>) &#123; element -&gt;</span><br><span class="line">    select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        channels.forEach &#123; channel -&gt;</span><br><span class="line">            channel.onSend(element) &#123; sentChannel -&gt; log(<span class="string">"sent on <span class="variable">$sentChannel</span>"</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消费者的消费效率较低时，数据能发给哪个就发给哪个进行处理，<code>onSend</code> 的第二个参数的参数是数据成功发送到的 <code>Channel</code> 对象。</p></li></ul><p>因此如果大家想要确认挂起函数是否支持 <code>select</code>，只需要查看其是否存在对应的 <code>SelectClauseN</code> 即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在协程当中，Select 的语义与 Java NIO 或者 Unix 的 IO 多路复用类似，它的存在使得我们可以轻松实现 1 拖 N，实现哪个先来就处理哪个。尽管 Select 和 Channel 比起标准库的协程 API 已经更接近业务开发了，不过个人认为它们仍属于相对底层的 API 封装，在实践当中多数情况下也可以使用 Flow API 来解决。</p><p>而这个 Flow API，完全就是响应式编程的协程版 API，我们简直可以照着 RxJava 来学习它，所以我们下一篇再见吧~~~</p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有近 1000 位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
      <category term="Select" scheme="https://www.bennyhuo.com/tags/select/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 最近怎么样了</title>
    <link href="https://www.bennyhuo.com/2019/12/23/kotlin-2019-whats-new/"/>
    <id>https://www.bennyhuo.com/2019/12/23/kotlin-2019-whats-new/</id>
    <published>2019-12-22T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 已经很成熟了。有多成熟呢？Kotlin Team 现在的重心已经是在为各个领域内的 Kotlin 实践提供支持了。</p></blockquote><a id="more"></a><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p>KotlinConf 在 12月5日前后的那几天开完了。Kotlin 1.4 有什么新特性吗？还真有一个，那就是 Kotlin 接口的 SAM 转换（KT-7770）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runAction</span><span class="params">(action: <span class="type">Action</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    runAction &#123;</span><br><span class="line">        <span class="comment">//action here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈，终于在新的类型推导到来时，这个特性被支持了。前不久我在录制 《Kotlin 入门到精通》这门课的时候讲到这个点的时候还说“我也不知道什么时候，会不会支持这个特性”，好了，Kotlin Team 终于听到了人民的呼声。</p><h2 id="新形势"><a href="#新形势" class="headerlink" title="新形势"></a>新形势</h2><p>Kotlin 1.0 发布到现在已经快 4 年了，我推广 Kotlin 差不多也 4 年多了。在 Google 开始决定扶持 Kotlin 之前，我们社区的小伙伴的内心感觉大概跟之前的 Rust 社区的小伙伴差不多吧，然后 Google 从 2017 年把 Kotlin 确定为 Android 的一级语言（表示会从官方提供支持，开发者可以使用）到 2019 年转变为首选语言（表示官方推荐你用 Kotlin），社区小伙伴们最初得到这样的消息大概也许相当于 Rust 社区的小伙伴们听到微软决定要用 Rust 来重写部分操作系统模块一样吧（激动）。</p><p>我们来看看现在 Kotlin 的排名情况，第一个是大家用的比较多的：</p><p><strong>TIOBE Index for December 2019</strong><br><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761917429814.jpg" alt=""></p><p>这个排名上 Kotlin 上升的还是比较缓慢的，不过也已经不错了，两年前的时候还在 50 名那儿呢。当然，这个排名其实也有一些争议，因为它是按照互联网上现有的某一门语言的网页数来计算排名的，排名前几的某些语言其实有很多网页都大概都没什么人访问。</p><p>第二个是我觉得比较能反映现在大家对待一门语言的态度的排名：</p><p><strong>PYPL PopularitY of Programming Language</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761920410684.jpg" alt=""></p><p>（我把图截得大了一些，主要是想把我同样也很喜欢的 Lua 截进来，(～￣▽￣)～）</p><p>这个索引比较科学的地方主要在于它关注的是大家搜索这门语言的教程的频次，这个表明今年 12月大家学习 Kotlin 的热度比起去年上升了 0.5%，名次上升了 4 位。</p><p>也就是说，这两个索引一个反应存量，一个反应增量，数据上就能看出 Kotlin 的潜力还是非常巨大的，尽管现在开发者群体还比不上当红的 Java Python 这类“发达”语言，但这个增速绝对就是“发展中”语言中一道亮丽的风景线。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15770731567913.jpg" alt=""><br>PYPL 的排名确实能够比较真实的反映时下大家的态度，Java 已经被唱衰了好几年，Python 近几年火热到一下冒出特别多新书。Kotlin 在 Native 领域存活自然需要直面 Go，在 JavaScript 上当然也离不开 TypeScript，正好我们也对比下它们各自的发展，Kotlin 作为后起之秀真实有后来居上的气势。</p><h2 id="新发展"><a href="#新发展" class="headerlink" title="新发展"></a>新发展</h2><p>事实上，Kotlin 的主要应用领域当然就是 Android 了。可以说 Kotlin 简直运气好到了极点（也可以说是 Kotlin Team 的决策高明），选择从 Android 撕开一道口子切入市场，道理很简单啊，搞后台的人选择面太广了，Android 端除了忍受 Java，实在没有什么办法，我当时尝试了 Groovy 和 Scala 写 Android，结果标准库方法数一个 3W ，一个 5W，几年前我们还在饱受方法数的折磨，大家应该懂我是什么意思。可是 Kotlin 就很聪明，我不造轮子，标准库方法数 7k ，而且一直到现在都没怎么增加太多，所以大家就开始尝试。到现在，很多人都还觉得 Kotlin 一定是给 Android 开发者准备的 —— 怎么会呢。不过要说支持的比较好的，当然还是 Android，<a href="https://developer.android.com/kotlin/ktx" target="_blank" rel="noopener">KTX 的库</a>已经非常丰富，<a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">Lifecycle</a>、<a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="noopener">Room</a> 这样的组件也已经支持协程（前者提供 scope，后者的 Dao 支持 suspend 函数），第三方的 <a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a> 早在 2.6.0 就支持 suspend 函数，<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a> 4.x 已经完全用 Kotlin 重写等等。就连我们公司年初开源的（实际上这个项目在内部也早就开源）插件化框架 <a href="https://github.com/Tencent/Shadow" target="_blank" rel="noopener">Shadow</a> 也有很多模块是使用 Kotlin 开发的。数不胜数。</p><p>其次自然就是 Java 所覆盖的其他领域。印象中 <a href="https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0" target="_blank" rel="noopener">Spring 5.0 就开始支持 Kotlin</a>，前不久试了下 <a href="https://www.baeldung.com/spring-boot-kotlin-coroutines" target="_blank" rel="noopener">WebFlux 都已经支持 <code>suspend</code> 函数作为 RestController 的 API </a>，也提供了各种 <code>Flux</code> 与 <code>Flow</code> 的互转操作，使用体验真实不要太赞。Kotlin Team 的亲儿子 <a href="https://ktor.io" target="_blank" rel="noopener">Ktor</a> 就更不用说了，函数式的 Route 声明，让我一度以为自己在写 Node.js，但又显然不是，Node.js 哪里会提示有什么 API 呢；原生的协程支持，让我们几乎处处可以写 <code>suspend</code> 调用，感觉空气都新鲜了。</p><p>不甘寂寞的 Kotlin Team 很早就开始支持 Js，不过工具链却一直没有跟上，今年还是重点迭代的 <a href="https://github.com/Kotlin/dukat" target="_blank" rel="noopener">Dukat</a> 项目就是为了解决 Kotlin 与 JavaScript 交互时，Kotlin 的强类型问题。这个项目可以把现有的 JavaScript 界类型的事实标准 *.d.ts 文件转成 Kotlin 声明，这样就很好的解决了类型问题，省得我们以前写 Kotlin 调用 JavaScript API 的时候要么自己手动在 Kotlin 源码中声明对应的 API，要么就是各种类型都声明为 dynamic 逃过编译器检查。听说 WASM 也要独立门户了，过去一直都在 Kotlin Native 当中，后面也许也是一个重点的发力方向。</p><p>Kotlin Native 最早比较让人难受的就是编译慢的问题了。最开始编译 Hello World 都需要 40s，后来终于缩短到了 10s 以内（我的笔记本是 2015 mbp），当然这个时间随着代码量的增加也并不会有特别显著的增长，所以对于大型项目来讲，编译时间已经不再是问题。还有就是调试麻烦的事儿，如果是写独立的 Kotlin Native 项目，可以直接 CLion 中调试，也可以在 IntelliJ 中安装 Native Debug 插件调试，可是最近很流行的 Kotlin Native 写 iOS 程序呢，貌似不太好办 —— Kotlin Team 宣布会在明年开始 preview 一款运行在 Android Studio 上的插件用来调试跑在 iOS 上的 Kotlin Native 代码，这就有点儿秀了。哦，对了，Kotlin Native 的协程只能跑在一个线程当中的问题也应该很快就能解决，期待一下。</p><p>还有 Kotlin 的脚本，在 3.0 时代就开始尝试支持 Kotlin 的 <a href="https://docs.gradle.org/5.0/release-notes.html" target="_blank" rel="noopener">Gradle 在 5.0 正式宣布支持 Kotlin</a>，并且官方文档都配备了 Kotlin 和 Groovy 两个版本，写过 Gradle 插件的都知道，Gradle API 本来就比较复杂，用 Groovy 写没有 IDE 提示的日子有多痛苦，用 Kotlin 就完全不同了。</p><p>更重磅的是，来看看新鲜出炉的 <a href="https://github.com/Kotlin/kotlin-jupyter" target="_blank" rel="noopener">kotlin-jupyter</a>，官方博客也刚刚更新了 <a href="https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/" target="_blank" rel="noopener">Kotlin 对科学计算支持的介绍文章</a>。看来，Kotlin Team 的野心真的不小啊，我现在就是有点儿担心 Kotlin Team 人手不够了 —— 玩笑话，Kotlin 已经不再是 Kotlin Team 自己的了，而是我们所有开发者的。</p><p>稍微提一下，在函数式编程方面，Kotlin Team 目前没有（明面儿上）专门支持，不过开源项目 <a href="https://github.com/arrow-kt/arrow" target="_blank" rel="noopener">Arrow</a> 已经颇具规模，由于 Kotlin 1.4 有公开编译器插件的 API 的计划，Arrow 团队也在积极引进编译器层面的支持来加强某些特性的实现（例如 typeclass，目前在 Java 平台上主要靠 APT）。</p><h2 id="一如既往的建议"><a href="#一如既往的建议" class="headerlink" title="一如既往的建议"></a>一如既往的建议</h2><p>尽管发展趋势日新月异，不过建议却一直没变。现如今的 Kotlin 的发展形势越来越好 ，如果现在你还没有趁早用起来，难道要等到几年后后悔吗？当然也有很多小伙伴说用 Kotlin 的时候“巨坑”，然后我问他们都哪儿坑了，说出来之后结果发现都是因为对 Kotlin 甚至是对 Java 不熟悉造成的。其实大家只要认真阅读官方文档，稍微练习上几天，一定会逐渐熟悉起来的，如果英文吃力，可以关注下<a href="https://www.kotlincn.net" target="_blank" rel="noopener">中文 Kotlin 官网</a>，有问题可以到<a href="https://discuss.kotliner.cn/" target="_blank" rel="noopener">Kotlin 中文论坛</a>提问。当然，如果大家喜欢通过视频学习，也可以在慕课网关注下 “<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">新版 Kotlin 从入门到精通</a>“ 这门课，我大概从国庆前后开始基于 Kotlin 1.3.50 制作了这套新版的视频教程，Kotlin 的知识点基本上都有覆盖，也结合了过去推广教学的经验对重难点进行了深入剖析，希望对大家在 Kotlin 入门或是进阶的过程中提供帮助。</p><p>Have a nice Kotlin!</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，大家可以在2019年12月26日之前联系慕课网客服索取价值 150 元的定向代金券，结合课程的限时优惠只需要 115 元即可升级新课。新课限时优惠同样截止于2019年12月26日，因此有需要的小伙伴们一定要抓紧了哟！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Kotlin 已经很成熟了。有多成熟呢？Kotlin Team 现在的重心已经是在为各个领域内的 Kotlin 实践提供支持了。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="News" scheme="https://www.bennyhuo.com/tags/news/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程 番外篇(2) - 协程的几类常见的实现</title>
    <link href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/"/>
    <id>https://www.bennyhuo.com/2019/12/01/coroutine-implementations/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。</p></blockquote><a id="more"></a><p>前面一篇文章我们大概讨论了协程是怎么一回事，也举了一些例子，不过整体上覆盖的细节比较少。这篇文章我们按照协程的经典论文 “Revisiting Coroutines” 的思路展开，详细的讨论下协程究竟是怎样的存在。当然由于涉及语言较多，个人水平有限，如有不恰当之处，欢迎大家指正。</p><h2 id="1-协程的分类"><a href="#1-协程的分类" class="headerlink" title="1. 协程的分类"></a>1. 协程的分类</h2><p>协程的主流实现虽然细节上差异较大，但总体来讲仍然有章可循。</p><h3 id="1-1-按调用栈分类"><a href="#1-1-按调用栈分类" class="headerlink" title="1.1 按调用栈分类"></a>1.1 按调用栈分类</h3><p>由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似地，线程会因为 CPU 调度权的切换而被中断，它的中断状态会保存在调用栈当中，因而协程的实现也按照是否开辟相应的调用栈存在以下两种类型：</p><ul><li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li><li>无栈协程 Stackless Coroutine：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法来实现。</li></ul><p>有栈协程的优点就是可以在任意函数调用层级的任意位置进行挂起，并转移调度权，例如 Lua 的协程，这方面多数无栈协程就显得力不从心了，例如 Python 的 Generator；通常来讲，有栈协程因为总是会给协程开辟一块儿栈内存，因此内存开销也相对可观，而无栈协程在内存方面就比较有优势了。</p><p>当然也有反例。</p><p>Go 语言的 go routine 可以认为是有栈协程的一个实现，不过 Go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB，相比之下线程的栈空间通常是 MB 级别，因而它在内存方面的表现也相对轻量。</p><p>Kotlin 的协程是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现的，不过 Kotlin 的协程可以在任意调用层次挂起，换句话说我们启动一个 Kotlin 协程，可以在其中任意嵌套 <code>suspend</code> 函数，而这又恰恰是有栈协程最重要的特性之一：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">level_0</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"I'm in level 0!"</span>)</span><br><span class="line">    level_1() <span class="comment">// ............ ①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">level_1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"I'm in level 1!"</span>)</span><br><span class="line">    suspendNow() <span class="comment">// ............ ②</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendNow</span><span class="params">()</span></span> </span><br><span class="line">        = suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中 ① 处并没有真正直接挂起，② 处的调用才会真正挂起，Kotlin 通过 <code>suspend</code> 函数嵌套调用的方式可以实现任意函数调用层次的挂起。</p><p>当然，想要在任意位置挂起，那就需要调用栈了，与开发者通过调用 API 显式地挂起协程相比，任意位置的挂起主要用于运行时对协程执行的干预，这种挂起方式对于开发者不可见，因而是一种隐式的挂起操作。Go 语言的 go routine 可以通过对 channel 的读写来实现挂起和恢复，除了这种显式地切换调度权之外，Go 运行时还会对长期占用调度权的 go routine 进行隐式挂起，并将调度权转移给其他 go routine，这实际上就是我们熟悉的线程的抢占式调度了。</p><h3 id="1-2-按调度方式分类"><a href="#1-2-按调度方式分类" class="headerlink" title="1.2 按调度方式分类"></a>1.2 按调度方式分类</h3><p>调度过程中，根据协程转移调度权的目标又将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>：</p><ul><li>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。</li><li>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li></ul><p>对称协程实际上已经非常接近线程的样子了，例如 Go 语言中的 go routine 可以通过读写不同的 channel 来实现控制权的自由转移。而非对称协程的调用关系实际上也更符合我们的思维方式，常见的语言对协程的实现大多是非对称实现，例如 Lua 的协程中当前协程调用 <code>yield</code> 总是会将调度权转移给 <code>resume</code> 它的协程；还有就是我们在前面提到的 <code>async</code>/<code>await</code>，<code>await</code> 时将调度权转移到异步调用中，异步调用返回结果或抛出异常时总是将调度权转移回 <code>await</code> 的位置。</p><p>从实现的角度来讲，非对称协程的实现更自然，也相对容易；不过，我们只要对非对称协程稍作修改，即可实现对称协程的能力。在非对称协程的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有的协程在挂起时都将控制权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，例如 Lua 的第三方库 <a href="https://luapower.com/coro" target="_blank" rel="noopener">coro</a>，以及 Kotlin 协程框架中基于 <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html" target="_blank" rel="noopener">Channel</a> 的通信等。</p><h2 id="2-协程的实现举例"><a href="#2-协程的实现举例" class="headerlink" title="2. 协程的实现举例"></a>2. 协程的实现举例</h2><p>我们已经介绍了非常多的协程相关的理论知识，简单来说协程需要关注的就是程序自己处理挂起和恢复，只不过在分类的时候又根据解决挂起和恢复时具体实现细节的不同又区分了按照<strong>栈</strong>的有无和<strong>调度权</strong>转移的对称性的分类。不管怎样，协程的关注点就是程序自己处理挂起和恢复，以下我们给出一些实现，请大家留意它们是如何做到这一点的。</p><h3 id="2-1-Python-的-Generator"><a href="#2-1-Python-的-Generator" class="headerlink" title="2.1 Python 的 Generator"></a>2.1 Python 的 Generator</h3><p>Python 的 Generator 也是协程，是一个典型的无栈协程的实现，我们可以在任意 Python 函数中调用 <code>yield</code> 来实现当前函数调用的挂起，<code>yield</code> 的参数作为对下一次 <code>next(num_generator)</code>调用的返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span>(i) <span class="comment"># ..................... ①</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">num_generator = numbers()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"[0] <span class="subst">&#123;next(num_generator)&#125;</span>"</span>) <span class="comment"># ... ②</span></span><br><span class="line">print(<span class="string">f"[1] <span class="subst">&#123;next(num_generator)&#125;</span>"</span>) <span class="comment"># ... ③</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_generator: <span class="comment"># ............... ④</span></span><br><span class="line">    print(<span class="string">f"[Loop] <span class="subst">&#123;i&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p>所以运行这段程序时，首先会在 ① 处 <code>yield</code>，并将 <code>0</code> 传出，在 ② 处输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0] 0</span><br></pre></td></tr></table></figure><p>接着自 ③ 处调用 <code>next</code>，将调度权从主流程转移到 <code>numbers</code> 函数当中，从上一次挂起的位置 ① 处继续执行，<code>i</code> 的值修改为 <code>1</code>，1s 后，再次通过 <code>yield(1)</code> 挂起，③ 处输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 1</span><br></pre></td></tr></table></figure><p>后续就以同样的逻辑在 <code>for</code> 循环中一直输出 <code>[Loop] n</code>，直到程序被终止。</p><p>我们看到，之所以称 Python 的 Generator 为协程，就是因为它具备了通过 <code>yield</code> 来挂起当前 Generator 函数的执行，通过 <code>next</code> 来恢复参数对应的 Generator 执行来实现挂起、恢复的协程调度权控制转移的。</p><p>当然，如果在 <code>numbers</code> 函数中嵌套调用 <code>yield</code>，就无法对 <code>numbers</code> 的调用进行中断了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        yield_here(i) <span class="comment"># ................. ①</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yield_here</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span>(i)</span><br></pre></td></tr></table></figure><p>这时候我们再调用 <code>numbers</code> 函数，就会陷入死循环而无法返回，因为这次 <code>yield_here</code> 的返回值才是 Generator。</p><blockquote><p><strong>说明</strong> Python 的 Generator 属于<strong>非对称无栈协程</strong>的一种实现。从 Python 3.5 开始也支持 <code>async</code>/<code>await</code>，原理与 JavaScript 的实现类似，与 Generator 的不同之处在于我们可以通过这一组关键字实现在函数嵌套调用挂起。</p></blockquote><h3 id="2-2-Lua-标准库的协程实现"><a href="#2-2-Lua-标准库的协程实现" class="headerlink" title="2.2 Lua 标准库的协程实现"></a>2.2 Lua 标准库的协程实现</h3><p>Lua 的协程实现可以认为是一个教科书式的案例了，它提供了几个 API 允许开发者灵活控制协程的执行：</p><ul><li><code>coroutine.create</code>：创建协程，参数为函数，作为协程的执行体，返回协程实例。</li><li><code>coroutine.yield</code>：挂起协程，第一个参数为被挂起的协程实例，后面的参数则作为外部调用 <code>resume</code> 来继续当前协程时的返回值，而它的返回值则又是外部下一次 <code>resume</code> 调用时传入的参数。</li><li><code>coroutine.resume</code>：继续协程，第一个参数为被继续的协程实例，后面的参数则作为协程内部 <code>yield</code> 时的返回值，返回值则为协程内部下一次 <code>yield</code> 时传出的参数；如果是第一次对该协程实例执行 <code>resume</code>，参数会作为协程函数的参数传入。</li></ul><p>Lua 的协程也有几个状态，挂起（suspended）、运行（running）、结束（dead）。其中，调用 <code>yield</code> 之后的协程处于挂起态，获得执行权而正在运行的协程则是处于运行态，协程对应的函数运行结束后，则处于结束态。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span> </span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>, <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"send "</span>..i)</span><br><span class="line">        coroutine.<span class="built_in">yield</span>(i) <span class="comment">-- ④</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"End Producer"</span>)</span><br><span class="line"><span class="keyword">end</span>            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(value)</span></span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"receive "</span>..value)</span><br><span class="line">        value = coroutine.<span class="built_in">yield</span>() <span class="comment">-- ⑤</span></span><br><span class="line">    <span class="keyword">until</span>(<span class="keyword">not</span> value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"End Consumer"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">producerCoroutine = coroutine.<span class="built_in">create</span>(producer) <span class="comment">-- ①</span></span><br><span class="line">consumerCoroutine = coroutine.<span class="built_in">create</span>(consumer) <span class="comment">-- ②</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">status</span>, product = coroutine.<span class="built_in">resume</span>(producerCoroutine) <span class="comment">-- ③</span></span><br><span class="line">    coroutine.<span class="built_in">resume</span>(consumerCoroutine, product) <span class="comment">-- ⑥</span></span><br><span class="line"><span class="keyword">until</span>(<span class="keyword">not</span> <span class="built_in">status</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"End Main"</span>)</span><br></pre></td></tr></table></figure><p>这段代码在 ①、②两处创建协程，③处开始执行，<code>producer</code> 在 ④ 处 <code>yield(0)</code>，意味着 ③ 的返回值 <code>product</code> 就是 <code>0</code>，我们把 <code>0</code> 作为参数又传给 <code>consumer</code>，第一次 <code>resume</code> 参数 <code>0</code> 会作为 <code>consumer</code> 的参数 <code>value</code> 传入，因此会打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">send 0</span><br><span class="line">receive 0</span><br></pre></td></tr></table></figure><p>接下来 <code>consumer</code> 通过 ⑤ 处的 <code>yield</code> 挂起，它的参数会作为 ⑥ 处的返回值，不过我们没有传任何参数。这时控制权又回到主流程，<code>status</code> 的值在对应的协程结束后会返回 <code>false</code>，这时候 <code>producer</code> 尚未结束，因此是 <code>true</code>，于是循环继续执行，后续流程类似，输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">send 1</span><br><span class="line">receive 1</span><br><span class="line">send 2</span><br><span class="line">receive 2</span><br><span class="line">send 3</span><br><span class="line">receive 3</span><br><span class="line">End Producer</span><br><span class="line">End Consumer</span><br><span class="line">End Main</span><br></pre></td></tr></table></figure><p>通过这个例子，希望大家能够对协程有一个更加具体的认识，我们看到对于协程来讲，它包括：</p><ul><li>协程的执行体，主要是指启动协程时对应的函数</li><li>协程的控制实例，我们可以通过协程创建时返回的实例控制协程的调用流转</li><li>协程的状态，在调用流程转移前后，协程的状态会发生相应的变化</li></ul><blockquote><p><strong>说明</strong> Lua 标准库的协程属于<strong>非对称有栈协程</strong>，不过第三方提供了基于标准库的<strong>对称协程</strong>的实现，有兴趣的话可以参考： <a href="https://luapower.com/coro" target="_blank" rel="noopener">coro</a>。有趣的是，这也恰恰是<strong>对称协程</strong>的实现可以基于<strong>非对称协程</strong>来实现的很好的例证。</p></blockquote><h3 id="2-3-Go-语言中的-go-routine"><a href="#2-3-Go-语言中的-go-routine" class="headerlink" title="2.3 Go 语言中的 go routine"></a>2.3 Go 语言中的 go routine</h3><p>go routine 的调度没有 Lua 那么明显，没有类似 <code>yield</code> 和 <code>resume</code> 的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// .......... ①</span></span><br><span class="line"><span class="keyword">var</span> readChannel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = channel</span><br><span class="line"><span class="keyword">var</span> writeChannel <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = channel</span><br><span class="line"></span><br><span class="line"><span class="comment">// reader</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// ........................ ②</span></span><br><span class="line">    fmt.Println(<span class="string">"wait for read"</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> readChannel &#123; <span class="comment">// ... ③</span></span><br><span class="line">        fmt.Println(<span class="string">"read"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"read end"</span>)</span><br><span class="line">&#125;()  <span class="comment">// ............................... ④</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// writer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">        fmt.Println(<span class="string">"write"</span>, i)</span><br><span class="line">        writeChannel &lt;- i <span class="comment">// .......... ⑤</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>我们先来简单介绍下 go routine 的启动方式。在任意函数调用前面加关键字 <code>go</code> 即可启动一个 go routine，并在该 go routine 中调用这个函数，例如 ② 处实际上是创建了一个匿名函数，并在后面 ④ 处立即调用了该函数。我们把这两个 go routine 依次称为 “reader” 和 “writer”。</p><p>① 处创建了一个双向的 <code>channel</code>，可读可写，接着创建的 <code>readChannel</code> 声明为只读类型，<code>writeChannel</code> 声明为只写类型，这二者实际上是同一个 <code>channel</code>，并且由于这个 <code>channel</code> 没有缓冲区，因此写操作会一直挂起直到读操作执行，反过来也是如此。</p><p>在 reader 中，③ 处的 <code>for</code> 循环会对 <code>readChannel</code> 进行读操作，如果此时还没有对饮的写操作，就会挂起，直到有数据写入；在 writer 中，⑤ 处表示向 <code>writeChannel</code> 中写入 <code>i</code>，同样，如果写入时尚未有对应的读操作，就会挂起，直到有数据读取。整段程序的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait for read</span><br><span class="line">write 0</span><br><span class="line">read 0</span><br><span class="line">write 1</span><br><span class="line">read 1</span><br><span class="line">write 2</span><br><span class="line">read 2</span><br><span class="line">read end</span><br></pre></td></tr></table></figure><p>如果我们有多个 go routine 对 <code>channel</code> 进行读写，或者有多个 <code>channel</code> 供多个 go routine 读写，那么这时的读写操作实际上就是在 go routine 之间平等的转移调度权，因此可以认为 go routine 是<strong>对称</strong>的协程实现。</p><p>这个示例看上去对于 <code>channel</code> 的读写操作有点儿类似两个线程中的阻塞式 IO 操作，不过 go routine 相对操作系统的内核线程来说要轻量得都，切换的成本也很低，因此在读写过程中挂起的成本也远比我们熟悉的线程阻塞的调用切换成本。实际上这两个 go routine 在切换时，很大概率不会有线程的切换，为了让示例更加能说明问题，我们为输出添加了当前的线程 id，同时将每次向 <code>writeChannel</code> 写入数据之后的 <code>Sleep</code> 操作去掉：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(windows.GetCurrentThreadId(), <span class="string">"wait for read"</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> readChannel &#123;</span><br><span class="line">        fmt.Println(windows.GetCurrentThreadId(), <span class="string">"read"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(windows.GetCurrentThreadId(), <span class="string">"read end"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">        fmt.Println(windows.GetCurrentThreadId(), <span class="string">"write"</span>, i)</span><br><span class="line">        writeChannel &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>修改后的运行结果可以看到程序在输出时所在的线程 id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">181808 write 0</span><br><span class="line">183984 wait for read</span><br><span class="line">181808 read 0</span><br><span class="line">181808 write 1</span><br><span class="line">181808 write 2</span><br><span class="line">181808 read 1</span><br><span class="line">181808 read 2</span><br><span class="line">181808 read end</span><br></pre></td></tr></table></figure><p>两个 go routine 除了开始运行时占用了两个线程，后续都在一个线程中转移调度权（不同场景的实际运行结果可能有细微差异，这取决于 Go 运行时的调度器）。</p><blockquote><p><strong>获取线程 id</strong> 本例在 windows 上调试，通过 <a href="https://github.com/golang/sys" target="_blank" rel="noopener">sys</a> 库的 windows 包下提供的 <code>GetCurrentThreadId</code> 函数来获取线程 id。Linux 系统可以通过 <code>syscall.Gettid</code> 来获取。</p></blockquote><blockquote><p><strong>说明</strong> 我们虽然一直在用 go routine 做例子，并把它称作为<strong>对称有栈协程</strong>的一种实现，但考虑到 Go 运行时本身做了足够多超出其他语言的能力，例如栈优化，调度优化等，特别是的调度器还支持特定场景下的抢占式调度，某种意义上已经超越了协程概念的讨论范围，因此也有很多人认为 go routine 不能简单的认为就是协程。</p></blockquote><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>本文整体上对协程的分类做了较为详细的探讨。不管怎么分类，协程的本质就是程序自己处理挂起和恢复。协程描述了多个程序之间如何通过相互出让运行调度权来完成执行，基于这一对基本的控制转移操作进而衍生出各种异步模型，并发模型例如 <code>async</code>/<code>await</code>，Channel 等。</p><p>相比之下，有朋友抱怨 Kotlin 的协程没有其他语言的 <code>async</code>/<code>await</code> 那么容易上手，也没有 go routine 那么容易使用，原因也很简单，Kotlin 的协程用一个最基本的 <code>suspend</code> 关键字来支持了最基本的挂起恢复逻辑，进而在上层封装，衍生出了以上提到的几乎所有的模型，让我们在 Kotlin 当中可以有机会使用 <code>async</code>/<code>await</code>、Channel，以及最新出的 Flow API，将来还会有更多（也许包括在 issue 中被提到想要重做的 Actor），它想做的事儿太多了，也确实在一步一步地做到。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 中文论坛的使用技巧</title>
    <link href="https://www.bennyhuo.com/2019/10/22/kotlin-forum-mobile/"/>
    <id>https://www.bennyhuo.com/2019/10/22/kotlin-forum-mobile/</id>
    <published>2019-10-21T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.421Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！</p></blockquote><a id="more"></a><p>欢迎访问 <a href="https://discuss.kotliner.cn/" target="_blank" rel="noopener">Kotlin 中文论坛</a> 讨论 Kotlin！为了能够有时间刷论坛，我卸载了知乎卸载了脉脉，来吧，抛出你的问题~~</p><p>大家知道，额，估计不知道吧。。。我们的 Kotlin 中文论坛实际上是采用了与官方论坛相同的框架 <a href="https://www.discourse.org/" target="_blank" rel="noopener">Discourse</a>，很厉害的项目呢。这个框架界面风格都非常的清爽，Github 的论坛、Gradle 论坛好多论坛都采用了这个项目搭建：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716995316308.jpg" alt=""></p><p>我其实一直以为它的优点就只有这么点儿，直到我发现用手机端的 Chrome 可以直接创建一个快捷方式：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716998152892.jpg" alt=""></p><p>之后呢？我们就可以在桌面上看到：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999181369.jpg" alt=""></p><p>点击这个 icon 进入之后，就好像原生 App 一样：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999799086.jpg" alt=""></p><p>浏览器的地址不见了有没有，使用体验也很不错，小伙伴们就可以随时随地刷论坛啦！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！</p><hr><p>经过小伙伴们之处，桌面也可以：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720452651204.jpg" alt=""></p><p>然后就得到了一个桌面 APP 有木有！</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720453054368.jpg" alt=""></p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Website" scheme="https://www.bennyhuo.com/tags/website/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程 番外篇(1) - 协程为什么被称为『轻量级线程』？</title>
    <link href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/"/>
    <id>https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/</id>
    <published>2019-10-18T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接触新概念，最好的办法就是先整体看个大概，再回过头来细细品味。</p></blockquote><a id="more"></a><p>文中如果没有特别说明，协程指编程语言级别的协程，线程则特指操作系统内核线程。</p><h2 id="1-协程到底是啥？"><a href="#1-协程到底是啥？" class="headerlink" title="1. 协程到底是啥？"></a>1. 协程到底是啥？</h2><p>Kotlin 的协程从 v1.1 开始公测(Experimental) 到现在，已经算是非常成熟了，但大家对它的看法却一直存在各种疑问，为什么呢？因为即便我们把 Kotlin 丢掉，单纯协程这个东西本身就已经长时间让大家感到疑惑了，不信的话可以单独搜一下协程或者 Coroutine，甚至连 Lua 之父在提到为什么协程鲜见于早期语言实现，就是因为这概念没有一个清晰的界定。</p><p>更有意思的是，在查阅资料的过程中，你会经常会陷入一种一会儿『啊，我懂了』，一会儿『啊，我懂个屁』的循环当中，不瞒各位说，我从七八年前刚开始学 Lua 的时候面对 Lua 的协程也是这个破感觉，后来接触 goroutine 又来了一遍，接触 Kotlin 的协程又来了一遍，习惯就好。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712859864288.jpg" alt=""></p><p>那么问题的关键在于，协程的概念是不是真的混乱呢？其实不是的，协程的概念最核心的点其实就是函数或者一段程序能够被挂起（说暂停其实也没啥问题），待会儿再恢复，挂起和恢复是开发者的程序逻辑自己控制的，协程是通过主动挂起出让运行权来实现协作的，就没了，一句话就能说明白的事儿是不是特简单？它跟线程最大的区别在于线程一旦开始执行，从任务的角度来看，就不会被暂停，直到任务结束这个过程都是连续的，线程之间是抢占式的调度，因此也不存在协作问题。</p><p>那么我们再来理一理协程的概念：</p><ul><li>挂起恢复</li><li>程序自己处理挂起恢复</li><li>程序自己处理挂起恢复来实现协程的协作运行</li></ul><p>关键核心就是协程是一个能挂起并且待会儿恢复执行的东西。任何时候自己产生疑惑的时候都回过来再想想这几句话，就算协程最终呈现给我们的样子可能『花里胡哨』，但万变不离其宗。</p><blockquote><p>有的朋友不理解什么叫挂起，挂起这个词其实还真是源于操作系统的叫法，直观的理解上，你就当做暂停理解吧。</p></blockquote><h2 id="2-为什么协程的概念会有混乱的感觉？"><a href="#2-为什么协程的概念会有混乱的感觉？" class="headerlink" title="2. 为什么协程的概念会有混乱的感觉？"></a>2. 为什么协程的概念会有混乱的感觉？</h2><p>我们前面提到，协程的概念其实并不混乱，那么混乱的是什么？是各家对它的实现。这就好像牛顿第二定律一样，看似很简单，F = ma，用起来就五花八门了，衍生的各种公式更是层出不穷。</p><p>协程不就是要挂起、恢复么，请问挂起恢复具体要怎么做？没有定义呀。既然没有定义是不是就可以随便？是的，抓住老鼠就是好猫~</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712868953541.jpg" alt=""></p><p>协程这一点儿跟线程真的是没法比啊，主流操作系统都有成熟的线程模型，应用层经常提到的线程的概念大多就是映射方式的差异，所以不同的编程语言一旦引入了线程，那么基本上就是照搬了系统线程的概念，线程本身也不是他们实现的——这很好理解，因为线程调度是操作系统做的嘛。</p><blockquote><p>Java 对线程做了很好的支持，这也是 Java 在高并发场景风生水起的一个关键支柱，不过如果你有兴趣去看下虚拟机底层对线程的支持，例如 Android 虚拟机，其实就是 pthread。Java 的 Object 还有一个 wait 方法，这个方法几乎支撑了各种锁的实现，它底层是 condition。</p></blockquote><p>绝大多数协程都是语言层面自己的实现，不同的编程语言有不同的使用场景，自然在实现上也看似有很大的差异，甚至还有的语言自己没有实现协程，但开发者通过第三方框架的方式提供了协程的能力，例如 Java 的框架 <a href="http://docs.paralleluniverse.co/quasar/" target="_blank" rel="noopener">Quasar</a>，加上协程实现本身在操作系统层面就有过一系列演进，因此出现了虽然理论上看起来很简单，但实现上却多样化的局面。</p><h2 id="3-协程有哪些主流的实现？"><a href="#3-协程有哪些主流的实现？" class="headerlink" title="3. 协程有哪些主流的实现？"></a>3. 协程有哪些主流的实现？</h2><p>我们在前面讲各个语言的实现有差异，说的是看似有很大的差异，主要是各自的关键字、类型命名不一样，但总结下来大家对于协程的分类更倾向于按照有没有栈来分，即：</p><ul><li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li><li>无栈协程 Stackless Coroutine：协程没有自己的调用栈。</li></ul><p>栈这个东西大家应该都很熟悉了，我们递归调用函数的层次太多就会导致 <code>StackOverflowException</code>，因为栈内存是有限的；我们的程序出现了异常我们总是希望看到异常点的调用关系，这样方便定位问题，这也需要栈。</p><p>有栈协程有什么好处呢？因为有栈，所以在任何一个调用的地方运行时都可以选择把栈保存起来，暂停这个协程，听起来就跟线程一样了，只不过挂起和恢复执行的权限在程序自己，而不是操作系统。缺点也是非常明显的，每创建一个协程不管有没有在运行都要为它开辟一个栈，这也是目前无栈协程流行的原因。</p><blockquote><p>goroutine 看上去似乎不像协程，因为开发者自己无法决定一个协程的挂起和恢复，这个工作是 go 运行时自己处理的。为了支持 goroutine 在任意位置能挂起，goroutine 其实是一个有栈协程，go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB。</p></blockquote><p>JavaScript、C# 还有 Python 的协程，或者干脆就说 async/await，相比之下就轻量多了，它们看起来更像是针对回调加了个语法糖的支持——它们其实就是无栈协程的实现了。无栈，顾名思义，每一个协程都不会单独开辟调用栈，那么问题来了，它的上下文是如何保存的？</p><p>这就要提到传说中的 CPS 了，即 continuation-passing-style。我们来想象一下，程序被挂起，或者说中断，最关键的是什么？是保存挂起点，或者中断点，对于线程被操作系统中断，中断点就是被保存在调用栈当中的，而我们的无栈协程要保存到哪儿呢？保存到 Continuation 对象当中，这个东西可能在不同的语言当中叫法不一样，但本质上都是一个 Continuation，它就是一个普通的对象，占用内存非常小，还是很抽象是吧，想想你常见的 Callback，它其实就是一个 Continuation 的实现。</p><blockquote><p>Kotlin 的协程的根基就是一个叫做 Continuation 的类。我在前面的文章不止一次提到，这家伙长得横看竖看就是一个回调，resume 就是 onSuccess，resumeWithException 就是 onFailure。</p></blockquote><p>Continuation 携带了协程继续执行所需要的上下文，同时它自己又是挂起点，因为待会儿恢复执行的时候只需要执行它回调的函数体就可以了。对于 Kotlin 来讲，每一个 <code>suspend</code> 函数都是一个挂起点，意味着对于当前协程来说，每遇到一个 <code>suspend</code> 函数的调用，它都有可能会被挂起。每一个 <code>suspend</code> 函数都被编译器插入了一个 Continuation 类型的参数用来保存当前的调用点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = suspendCoroutine&lt;<span class="built_in">Int</span>&gt;&#123; continuation -&gt;</span><br><span class="line">    println(<span class="string">"Hello"</span>)</span><br><span class="line">    continuation.resumeWith(Result.success(<span class="number">10086</span>))</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">我们定义了一个 `<span class="keyword">suspend</span>` 函数 `hello`，它看起来没有接收任何参数，如果真是这样，请问我们在后面调用 `resumeWith` 的 `continuation` 是哪里来的？</span><br><span class="line"></span><br><span class="line">都说挂起函数必须在协程内部调用，其实也不是，我们在前面讲挂起原理的时候就用 Java 代码直接去调用 `<span class="keyword">suspend</span>` 函数，大家也会发现这些 `<span class="keyword">suspend</span>` 函数都需要传入一个额外的 `Continuation`，就是这个意思。</span><br><span class="line"></span><br><span class="line">当然，Java 也不是必须的，我们只需要用点儿 Kotlin 反射，一样可以直接让 `<span class="keyword">suspend</span>` 函数现出原形：</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line"><span class="keyword">val</span> helloRef = ::hello</span><br><span class="line"><span class="keyword">val</span> result = helloRef.call(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"resumeWith: <span class="subst">$&#123;result.getOrNull()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这与我们在协程挂起原理那篇的做法如出一辙，我们虽然没有办法直接调用 <code>hello()</code>，但我们可以拿到它的函数引用，用发射调用它（这个做法后续可能也会被禁掉，但 1.3.50 目前仍然是可用的），调用的时候如果你什么参数都不传，编译器就会提示你它需要一个参数，呃，你看，它这么快就投降了——需要的这个参数正是 <code>Continuation</code>。</p><p>再强调一下，这段代码不需要运行在协程体内，或者其他的 <code>suspend</code> 函数中。现在请大家仔细想想，为什么官方要求 <code>suspend</code> 函数一定要运行在协程体内或者其他 <code>suspend</code> 函数中呢？</p><p>答案自然就是任何一个协程体或者 <code>suspend</code> 函数中都有一个隐含的 <code>Continuation</code> 实例，编译器能够对这个实例进行正确传递，并将这个细节隐藏在协程的背后，让我们的异步代码看起来像同步代码一样。</p><p>说到这里，我们已经接近 Kotlin 协程的本质了，它是一种无栈协程实现，它的本质就是一段代码 + Continuation 实例。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712876557532.jpg" alt=""></p><h2 id="4-Kotlin-协程真的只是一个线程框架吗？"><a href="#4-Kotlin-协程真的只是一个线程框架吗？" class="headerlink" title="4. Kotlin 协程真的只是一个线程框架吗？"></a>4. Kotlin 协程真的只是一个线程框架吗？</h2><p>这个说法其实是很奇怪的。我如果问你线程其实是一个 CPU 框架吗，你肯定会觉得这俩，啥啊？？？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712877286523.jpg" alt=""></p><p>Kotlin 协程确实在实现的过程中提供了切线程的能力，这是它的能力，不是它的身份，就好比拿着学位证非说这是身份证一样，学位证描述的是这人能干啥，不能描述这人是谁。</p><blockquote><p>杠精们可能会说学位证有照片有名字啊。你拿着学位证去买飞机票你看人家认不认呗。</p></blockquote><p>协程的世界可以没有线程，如果操作系统的 CPU 调度模型是协程的话；反过来也成立——这个应该不会有人反对吧。Kotlin 协程是不是可以没有线程呢？至少从 Java 虚拟机的实现上来看，好像。。。。不太行啊。没错，是不太行，不过这不是 Kotlin 协程的问题，是 Java 虚拟机的问题，谁让 Java 虚拟机的线程用起来没有那么难用呢，在它刚出来的时候简直吊打了当时其他语言对并发的支持（就像 goroutine 出来的时候吊打它一样）。</p><p>我们知道 Kotlin 除了支持 Java 虚拟机之外，还支持 JavaScript，还支持 Native。JavaScript 无论是跑在 Web 还是 Node.js 当中，都是单线程玩耍的；Kotlin Native 虽然可以调用 pthread，但官方表示我们有自己的并发模型（Worker），不建议直接使用线程。在这两个平台上跑，Kotlin 的协程其实都是单线程的，又怎么讲是个线程框架呢？</p><p>说到这儿可能又有人有疑问了，单线程要协程能做什么呢？这个前端同学可能会比较有感触，谁跟你们说的异步一定要多线程。。Android 开发的同学其实可以想想你在 <code>Activity</code> 刚创建的时候想要拿到一个 <code>View</code> 的大小一般返回都是 0，因为 <code>Activity</code> 的布局是在 <code>onResume</code> 方法调用之后完成的，所以 <code>handler.post</code> 一下就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    handler.post &#123;</span><br><span class="line">        <span class="keyword">val</span> width = myView.width</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是异步代码嘛，但这代码其实都运行在主线程的，我们当然可以用协程改写一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        <span class="keyword">val</span> width = handler.postSuspend &#123;</span><br><span class="line">            myView.width</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(<span class="string">"MyView"</span>, width.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Handler.<span class="title">postSuspend</span><span class="params">(block: () -&gt; <span class="type">T</span>)</span></span> = suspendCoroutine&lt;T&gt; &#123;</span><br><span class="line">    post &#123;</span><br><span class="line">        it.resume(block())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我个人觉得如果 Kotlin 协程的默认的调度器是 <code>Main</code>，并且这个 <code>Main</code> 会根据各自平台选择一个合适的事件循环，这样更能体现 Kotlin 协程在不同平台的一致性，例如对于 Android 来说 <code>Main</code> 就是 UI 线程上的事件循环，对于 Swing 同样是 Swing 的 UI 事件循环，只要是有事件循环的平台就默认基于这个循环来一个调度器，没有默认事件循环的也好办，Kotlin 协程本身就有 <code>runBlocking</code> 嘛，对于普通 Java 程序来说没有事件循环就给它构造一个就行了。</p><p>Kotlin 协程的设计者没有这样做，他们当然也有他们的道理，毕竟他们不愿意强迫开发者一定要用协程，甚至立刻马上就得对原有的代码进行改造，他们希望 Kotlin 只是一门编程语言，一门提供足够安全保障和灵活语法的编程语言，剩下的交给开发者去选择。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712879342461.jpg" alt=""></p><h2 id="5-协程真的比线程有优势吗？"><a href="#5-协程真的比线程有优势吗？" class="headerlink" title="5. 协程真的比线程有优势吗？"></a>5. 协程真的比线程有优势吗？</h2><p>这可不是一个很容易回答的问题。</p><p>Kotlin 协程刚出来的时候，有人就做过性能对比，觉得协程没有任何性能优势。我们完全可以认为他的测试方法是专业的，在一些场景确实用协程不会有任何性能上的优势，这就好比我们需要在一个单核 CPU 上跑一个计算密集型的程序还要开多个线程跑一样，任何特性都有适合它的场景和不适合它的领域。</p><p>想必大家看各类讲解协程的文章都会提到协程比线程轻量，这个其实我们前面也解释过了，编程语言级别实现的协程就是程序内部的逻辑，不会涉及操作系统的资源之间的切换，操作系统的内核线程自然会重一些，且不说每创建一个线程就会开辟的栈带来的内存开销，线程在上下文切换的时候需要 CPU 把高速缓存清掉并从内存中替换下一个线程的内存数据，并且处理上一个内存的中断点保存就是一个开销很大的事儿。如果没有直观的感受的话，就尽情想象一下你正要拿五杀的时候公司领导在微信群里发消息问你今天的活跃怎么跌了的场景。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712882561417.jpg" alt=""></p><p>线程除了包含内核线程本身执行代码能力的含义以外，通常也被赋予了逻辑任务的概念，所以协程是一种轻量级的『线程』的说法，更多描述的是它的使用场景，这句话也许这样说更贴切一些：</p><p><strong>协程更像一种轻量级的『线程』。</strong></p><p>线程自然可以享受到并行计算的优待，协程则只能依赖程序内部的线程来实现并行计算。协程的优势其实更多是体现在 IO 密集型程序上，这对于 Java 开发者来说可能又是一个很迷惑的事情，因为大家写 Java 这么多年，很少有人用上 NIO，绝大多数都是用 BIO 来读写 IO，因此不管开线程还是开协程，读写 IO 的时候总是要有一个线程在等待 IO，所以看上去似乎也没有什么区别。但用 NIO 就不一样了，IO 不阻塞，通过开一个或很少的几个线程来 select IO 的事件，有 IO 事件到达时再分配相应的线程去读写 IO，比起传统的 IO 就已经有了很大的提升。</p><p>欸？没有写错吗？你写的可是线程啊？</p><p>对啊，用了 NIO 以后，本身就可以减少线程的使用，没错的。可是协程呢？协程可以基于这个思路进一步简化代码的组织，虽然线程就能解决问题，但写起来其实是很累的，协程可以让你更轻松，特别是遇到多个任务需要访问公共资源时，如果每个任务都分配一个线程去处理，那么少不了就有线程会花费大量的时间在等待获取锁上，但如果我们用协程来承载任务，用极少量的线程来承载协程，那么锁优化就变得简单了：协程如果无法获取到锁，那么协程挂起，对应的线程就可以让出去运行其他协程了。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712887435643.jpg" alt=""></p><p>我更愿意把协程作为更贴近业务逻辑甚至人类思考层面的一种抽象，这个抽象层次其实已经比线程更高了。线程可以让我们的程序并发的跑，协程可以让并发程序跑得看起来更美好。</p><blockquote><p>线程本身就可以，为什么要用协程呢？这就像我们经常被人问起 Java 就可以解决问题，我为什么要用 Kotlin 呢？为什么你说呢？</p></blockquote><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712891180933.jpg" alt=""></p><p>总的来说，不管是异步代码同步化，还是并发代码简洁化，协程的出现其实是为代码从计算机向人类思维的贴近提供了可能。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;接触新概念，最好的办法就是先整体看个大概，再回过头来细细品味。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(9) - Channel 篇</title>
    <link href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/"/>
    <id>https://www.bennyhuo.com/2019/09/16/coroutine-channel/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Channel</code> 实际上就是协程在生产消费者模型上的应用，把过去你用 <code>BlockingQueue</code> 实现的功能替换成 <code>Channel</code>，也许会有新的发现~</p></blockquote><a id="more"></a><h2 id="1-认识-Channel"><a href="#1-认识-Channel" class="headerlink" title="1. 认识 Channel"></a>1. 认识 Channel</h2><p>Channel 实际上就是一个队列，而且是并发安全的，它可以用来连接协程，实现不同协程的通信。废话不多说，直接看例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            channel.send(i++)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> element = channel.receive()</span><br><span class="line">            Logger.debug(element)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    producer.join()</span><br><span class="line">    consumer.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们构造了两个协程，分别叫他们 producer 和 consumer，我们没有明确的指定调度器，所以他们的调度器都是默认的，在 Java 虚拟机上就是那个大家都很熟悉的线程池：他们可以运行在不同的线程上，当然也可以运行在同一个线程上。</p><p>例子的运行机制是，producer 当中每隔 1s 向 <code>Channel</code> 中发送一个数字，而 consumer 那边则是一直在读取 Channel 来获取这个数字并打印，我们能够发现这里发端是比收端慢的，在没有值可以读到的时候，receive 是挂起的，直到有新元素 send 过来——所以你知道了 receive 是一个挂起函数，那么 send 呢？</p><h2 id="2-Channel-的容量"><a href="#2-Channel-的容量" class="headerlink" title="2. Channel 的容量"></a>2. Channel 的容量</h2><p>如果你自己去 IDE 写了这段代码，你会发现 send 也是挂起函数。额，发端为什么会挂起？想想我们以前熟知的 <code>BlockingQueue</code>，我们往里面添加元素的时候，元素在队列里实际上是占用了空间的，如果这个队列空间不足，那么再往里面添加的时候就是两种情况：1. 阻塞，等待队列腾出空间；2. 抛异常，拒绝添加元素。send 也会面临同样的问题，我们说 Channel 实际上就是一个队列嘛，队列不应该有缓冲区吗，那么这个缓冲区一旦满了，并且也一直没有人调用 receive 取走元素的话，send 不就挂起了嘛。那么接下来我们看下 <code>Channel</code> 的缓冲区的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> <span class="title">Channel</span><span class="params">(capacity: <span class="type">Int</span> = RENDEZVOUS)</span></span>: Channel&lt;E&gt; =</span><br><span class="line">    <span class="keyword">when</span> (capacity) &#123;</span><br><span class="line">        RENDEZVOUS -&gt; RendezvousChannel()</span><br><span class="line">        UNLIMITED -&gt; LinkedListChannel()</span><br><span class="line">        CONFLATED -&gt; ConflatedChannel()</span><br><span class="line">        <span class="keyword">else</span> -&gt; ArrayChannel(capacity)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们构造 <code>Channel</code> 的时候调用了一个叫 <code>Channel</code> 的函数，hmm，这玩意儿确实不是它的构造器，在 Kotlin 当中我们可以随便定义一个顶级函数跟某些类名一样来伪装成构造器，这本质上就是个工厂方法。</p><blockquote><p>类似的还有 String，不信你去试试</p></blockquote><p>它有一个参数叫 capacity，指定缓冲区的容量，默认值 <code>RENDEZVOUS</code> 就是 0，这个词本意就是描述“不见不散”的场景，所以你不来 receive，我这 send 就一直搁这儿挂起等着。换句话说，我们开头的例子里面，如果 consumer 不 receive，producer 里面的第一个 send 就给挂起了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        i++ <span class="comment">//为了方便输出日志，我们将自增放到前面</span></span><br><span class="line">        Logger.debug(<span class="string">"before send <span class="variable">$i</span>"</span>)</span><br><span class="line">        channel.send(i)</span><br><span class="line">        Logger.debug(<span class="string">"before after <span class="variable">$i</span>"</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        delay(<span class="number">2000</span>) <span class="comment">//receive 之前延迟 2s</span></span><br><span class="line">        <span class="keyword">val</span> element = channel.receive()</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们故意让收端的节奏放慢，你就会发现，send 总是会挂起，直到 receive 之后才会继续往下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">07:11:23:119 [DefaultDispatcher-worker-2 @coroutine#1]  before send 1</span><br><span class="line">07:11:24:845 [DefaultDispatcher-worker-2 @coroutine#2]  1</span><br><span class="line">07:11:24:846 [DefaultDispatcher-worker-2 @coroutine#1]  before after 1</span><br><span class="line">07:11:25:849 [DefaultDispatcher-worker-4 @coroutine#1]  before send 2</span><br><span class="line">07:11:26:850 [DefaultDispatcher-worker-2 @coroutine#2]  2</span><br><span class="line">07:11:26:850 [DefaultDispatcher-worker-3 @coroutine#1]  before after 2</span><br></pre></td></tr></table></figure><p><code>UNLIMITED</code> 比较好理解，来者不拒，从它给出的实现 <code>LinkedListChannel</code> 来看，这一点也与我们的 <code>LinkedBlockingQueue</code> 有异曲同工之妙。</p><p><code>CONFLATED</code>，这个词是合并的意思，跟 inflate 是同一个词根，con- 前缀表示反着来，那是不是说我发了个 1、2、3、4、5 那边收的时候就会收到一个 [1,2,3,4,5] 的集合呢？毕竟字面意思是合并嘛。但实际上这个的效果是只保留最后一个元素，不是合并，应该是置换，换句话说，这个类型的 Channel 有一个元素大小的缓冲区，但每次有新元素过来，都会用新的替换旧的，也就是说我发了个 1、2、3、4、5 之后收端才接收的话，就只能收到 5 了。</p><p>剩下的就是 <code>ArrayChannel</code> 了，它接收一个值作为缓冲区容量的大小，这也比较类似于 <code>ArrayBlockingQueue</code>。</p><h2 id="3-迭代-Channel"><a href="#3-迭代-Channel" class="headerlink" title="3. 迭代 Channel"></a>3. 迭代 Channel</h2><p>前面我们在发送和读取 <code>Channel</code> 的时候用了 <code>while(true)</code>，因为我们想要去不断的进行读写操作，<code>Channel</code> 本身实际上也有点儿像序列，可以一个一个读，所以我们在读取的时候也可以直接获取一个 <code>Channel</code> 的 iterator：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> iterator = channel.iterator()</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123; <span class="comment">// 挂起点</span></span><br><span class="line">        <span class="keyword">val</span> element = iterator.next()</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个时候，iterator.hasNext() 是挂起函数，在判断是否有下一个元素的时候实际上就需要去 <code>Channel</code> 当中读取元素了。</p><p>这个写法自然可以简化成 for each：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> channel) &#123;</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-produce-和-actor"><a href="#4-produce-和-actor" class="headerlink" title="4. produce 和 actor"></a>4. produce 和 actor</h2><p>前面我们在协程外部定义 <code>Channel</code>，并在协程当中访问它，实现了一个简单的生产-消费者的示例，那么有没有便捷的办法构造生产者<br>和消费者呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> receiveChannel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = GlobalScope.produce &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        send(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>produce</code> 这个方法启动一个生产者协程，并返回一个 <code>ReceiveChannel</code>，其他协程就可以拿着这个 <code>Channel</code> 来接收数据了。反过来，我们可以用 <code>actor</code> 启动一个消费者协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sendChannel: SendChannel&lt;<span class="built_in">Int</span>&gt; = GlobalScope.actor&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> element = receive()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ReceiveChannel 和 SendChannel 都是 Channel 的父接口，前者定义了 receive，后者定义了 send，Channel 也因此既可以 receive 又可以 send。</p></blockquote><p><code>produce</code> 和 <code>actor</code> 与 <code>launch</code> 一样都被称作“协程启动器”。通过这两个协程的启动器启动的协程也自然的与返回的 <code>Channel</code> 绑定到了一起，因此 <code>Channel</code> 的关闭也会在协程结束时自动完成，以 <code>produce</code> 为例，它构造出了一个 <code>ProducerCoroutine</code> 的对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerCoroutine</span>&lt;<span class="type">E</span>&gt;</span>(</span><br><span class="line">    parentContext: CoroutineContext, channel: Channel&lt;E&gt;</span><br><span class="line">) : ChannelCoroutine&lt;E&gt;(parentContext, channel, active = <span class="literal">true</span>), ProducerScope&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCompleted</span><span class="params">(value: <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        _channel.close() <span class="comment">// 协程完成时</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancelled</span><span class="params">(cause: <span class="type">Throwable</span>, handled: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> processed = _channel.close(cause) <span class="comment">// 协程取消时</span></span><br><span class="line">        <span class="keyword">if</span> (!processed &amp;&amp; !handled) handleCoroutineException(context, cause)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在协程完成和取消的方法调用中，对应的 <code>_channel</code> 都会被关闭。</p><p>这样看上去还是挺有用的。不过截止这俩 API <code>produce</code> 和 <code>actor</code> 目前都没有稳定，前者仍被标记为 <code>ExperimentalCoroutinesApi</code>，后者则标记为 <code>ObsoleteCoroutinesApi</code>，这就比较尴尬了，明摆着不让用嘛。<code>actor</code> 的文档中提到的 issue 的讨论也说明相比基于 Actor 模型的并发框架，Kotlin 协程提供的这个 <code>actor</code> API 也不过就是提供了一个 <code>SendChannel</code> 的返回值而已。当然，协程的负责人也有实现一套更复杂的 Actor 的想法，只是这一段时间的高优明显是 <code>Flow</code>——这货从协程框架的 v1.2 开始公测，到协程 v1.3 就稳定，真是神速，我们后面的文章会介绍它。</p><p>虽然 <code>produce</code> 没有被标记为 <code>ObsoleteCoroutinesApi</code>，显然它作为 <code>actor</code> 的另一半，不可能单独转正的，这俩 API 我的建议是看看就好了。</p><h2 id="5-Channel-的关闭"><a href="#5-Channel-的关闭" class="headerlink" title="5. Channel 的关闭"></a>5. Channel 的关闭</h2><p>前我们提到了 <code>produce</code> 和 <code>actor</code> 返回的 <code>Channel</code> 都会伴随着对应的协程执行完毕而关闭。哦，原来 <code>Channel</code> 还有一个关闭的概念。</p><p><code>Channel</code> 和我们后面的文章即将要探讨的 <code>Flow</code> 不同，它是在线的，是一个热数据源，换句话说就是有想要收数据，就要有人在对面给他发，就像发微信一样。既然这样，就难免曲终人散，对于一个 <code>Channel</code>，如果我们调用了它的 <code>close</code>，它会立即停止接受新元素，也就是说这时候它的 <code>isClosedForSend</code> 会立即返回 <code>true</code>，而由于 <code>Channel</code> 缓冲区的存在，这时候可能还有一些元素没有被处理完，所以要等所有的元素都被读取之后 <code>isClosedForReceive</code> 才会返回 <code>true</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    List(<span class="number">5</span>)&#123;</span><br><span class="line">        channel.send(it)</span><br><span class="line">        Logger.debug(<span class="string">"send <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">    Logger.debug(<span class="string">"close channel. ClosedForSend = <span class="subst">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class="subst">$&#123;channel.isClosedForReceive&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> channel) &#123;</span><br><span class="line">        Logger.debug(<span class="string">"receive: <span class="variable">$element</span>"</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Logger.debug(<span class="string">"After Consuming. ClosedForSend = <span class="subst">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class="subst">$&#123;channel.isClosedForReceive&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把例子稍作修改，开了一个缓冲区大小为 3 的 <code>Channel</code>，在 producer 协程里面快速的发送元素出去，发送5个之后关闭 <code>Channel</code>，而在 consumer 协程当中每秒读取一个， 结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 0</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-3]  receive: 0</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 1</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 2</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 3</span><br><span class="line">11:05:21:688 [DefaultDispatcher-worker-3]  receive: 1</span><br><span class="line">11:05:21:688 [DefaultDispatcher-worker-3]  send 4</span><br><span class="line">11:05:21:689 [DefaultDispatcher-worker-3]  close channel. ClosedForSend &#x3D;true ClosedForReceive &#x3D; false</span><br><span class="line">11:05:22:693 [DefaultDispatcher-worker-3]  receive: 2</span><br><span class="line">11:05:23:694 [DefaultDispatcher-worker-4]  receive: 3</span><br><span class="line">11:05:24:698 [DefaultDispatcher-worker-4]  receive: 4</span><br><span class="line">11:05:25:700 [DefaultDispatcher-worker-4]  After Consuming. ClosedForSend &#x3D;true ClosedForReceive &#x3D; true</span><br></pre></td></tr></table></figure><p>下面我们来探讨下 <code>Channel</code> 关闭的意义。</p><p>一说起关闭，我们就容易想到 IO，如果不关闭可能造成资源泄露，那么 <code>Channel</code> 的关闭是个什么概念呢？我们前面提到过，<code>Channel</code> 其实内部的资源就是个缓冲区，这个东西本质上就是个线性表，就是一块儿内存，所以如果我们开了一个 <code>Channel</code> 而不去关闭它，其实也不会造成什么资源泄露，发端如果自己已经发完，它就可以不理会这个 <code>Channel</code> 了。嗯，看上去好像没什么问题是吧？</p><p>But，这时候在接收端就比较尴尬了，它不知道会不会有数据发过来，如果 <code>Channel</code> 是微信，那么接收端打开微信的窗口可能一直看到的是『对方正在输入』，然后它就一直这样了，孤独终老。所以这里的关闭更多像是一种约定：</p><blockquote><p>女：咱俩没戏，你别傻等了。<br>男：哦。（您的消息未发送成功）</p></blockquote><p>那么 <code>Channel</code> 的关闭究竟应该有谁来处理呢？正常的通信，如果是单向的，就好比领导讲话，讲完都会说『我讲完了』，你不能在领导还没讲完的时候就说『我听完了』，所以单向通信的情况比较推荐由发端处理关闭；而对于双向通信的情况，就要考虑协商了，双向通信从技术上两端是对等的，但业务场景下通常来说不是，建议由主导的一方处理关闭。</p><p>还有一些复杂的情况，前面我们看到的例子都是一对一的收发，其实还有一对多，多对多的情况，这种也仍然存在主导一方，<code>Channel</code> 的生命周期最好由主导方来维护。官方文档给出的扇入(fan-in)和扇出(fan-out)，其实就是这种情况。</p><blockquote><p>扇入和扇出的概念可能大家不是很熟悉，网上的说法不是很通俗，大家就想象它是一把折扇，折扇的边射向圆心就是扇入，这种情况圆心如果是通信的一端，那它就是接收方，如果是一个函数，那它就是被调用方。扇入越大，说明模块的复用程度越高，以函数为例，如果一个函数被调用的次数越多，那说明复用的程度越高。扇出就是反过来的情况，描述的是复杂度高的情形，例如一个 Model，负责调用网络模块、数据库、文件等很多模块。</p></blockquote><h2 id="6-BroadcastChannel"><a href="#6-BroadcastChannel" class="headerlink" title="6. BroadcastChannel"></a>6. BroadcastChannel</h2><p>前面提到了一对多的情形，从数据处理的本身来讲，虽然有多个接收端，同一个元素只会被一个接收端读到。广播则不然，多个接收端不存在互斥行为。</p><p>直接创建 <code>broadcastChannel</code> 的方法跟普通的 <code>Channel</code> 似乎也没什么太多的不一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> broadcastChannel = broadcastChannel&lt;<span class="built_in">Int</span>&gt;(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>如果要订阅，那么只需要调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> receiveChannel = broadcastChannel.openSubscription()</span><br></pre></td></tr></table></figure><p>这样我们就得到了一个 <code>ReceiveChannel</code>，获取订阅的消息，只需要调用它的 <code>receive</code>。</p><p>我们看一个完整一点儿的例子，例子中我们在发端发送 1 - 5，并启动 3 个协程同时接收广播：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    List(<span class="number">5</span>) &#123;</span><br><span class="line">        broadcastChannel.send(it)</span><br><span class="line">        Logger.debug(<span class="string">"send <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">List(<span class="number">3</span>) &#123; index -&gt;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> receiveChannel = broadcast.openSubscription()</span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> receiveChannel) &#123;</span><br><span class="line">            Logger.debug(<span class="string">"[<span class="variable">$index</span>] receive: <span class="variable">$element</span>"</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.forEach &#123; it.join() &#125;</span><br><span class="line">    </span><br><span class="line">producer.join()</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">12:34:59:656 [DefaultDispatcher-worker-6]  [2] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-3]  [1] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-5]  [0] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-7]  send 0</span><br><span class="line">12:34:59:657 [DefaultDispatcher-worker-7]  send 1</span><br><span class="line">12:34:59:658 [DefaultDispatcher-worker-7]  send 2</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-3]  [0] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-5]  [1] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-6]  [2] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-8]  send 3</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-8]  [0] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-3]  [1] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-6]  [2] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-8]  send 4</span><br><span class="line">12:35:02:674 [DefaultDispatcher-worker-8]  [0] receive: 3</span><br><span class="line">12:35:02:674 [DefaultDispatcher-worker-7]  [1] receive: 3</span><br><span class="line">12:35:02:675 [DefaultDispatcher-worker-3]  [2] receive: 3</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-8]  [1] receive: 4</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-3]  [0] receive: 4</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-1]  [2] receive: 4</span><br></pre></td></tr></table></figure><p>这里请大家重点关注每一个收端协程都可以读取到每一个元素。</p><blockquote><p>日志顺序不能非常直观的反映数据的读写顺序，如果大家自己再次运行，顺序上可能也有出入。</p></blockquote><p>除了直接创建以外，我们也可以直接用前面定义的普通的 <code>Channel</code> 来做个转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> broadcast = channel.broadcast(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>其中，参数表示缓冲区的大小。</p><p>实际上这里得到的这个 <code>broadcastChannel</code> 可以认为与原 <code>Channel</code> 是级联关系，这个扩展方法的源码其实很清晰的为我们展示了这一点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> ReceiveChannel<span class="type">&lt;E&gt;</span>.<span class="title">broadcast</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    capacity: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.LAZY</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: broadcastChannel&lt;E&gt; =</span><br><span class="line">    GlobalScope.broadcast(Dispatchers.Unconfined, capacity = capacity, start = start, onCompletion = consumes()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (e <span class="keyword">in</span> <span class="keyword">this</span><span class="symbol">@broadcast</span>) &#123;  <span class="comment">//这实际上就是在读取原 Channel</span></span><br><span class="line">            send(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>哦~原来对于 <code>BroadcastChannel</code>，官方也提供类似于 <code>produce</code> 和 <code>actor</code> 的方式，我们可以通过 <code>CoroutineScope.broadcast</code> 来直接启动一个协程，并返回一个 <code>BroadcastChannel</code>。</p><p>需要注意的是，从原始的 <code>Channel</code> 转换到 <code>BroadcastChannel</code> 其实就是对原 <code>Channel</code> 的一个读取操作，如果还有其他协程也在读这个原始的 <code>Channel</code>，那么会与 <code>BroadcastChannel</code> 产生互斥关系。</p><p>另外，<code>BroadcastChannel</code> 相关的 API 大部分被标记为 <code>ExperimentalCoroutinesApi</code>，后续也许还会有调整。</p><h2 id="7-Channel-版本的序列生成器"><a href="#7-Channel-版本的序列生成器" class="headerlink" title="7. Channel 版本的序列生成器"></a>7. Channel 版本的序列生成器</h2><p>前面的文章我们讲到过 <code>Sequence</code>，它的生成器是基于标准库的协程的 API 实现的，实际上 <code>Channel</code> 本身也可以用来生成序列，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class="line">    Logger.debug(<span class="string">"A"</span>)</span><br><span class="line">    send(<span class="number">1</span>)</span><br><span class="line">    Logger.debug(<span class="string">"B"</span>)</span><br><span class="line">    send(<span class="number">2</span>)</span><br><span class="line">    Logger.debug(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> channel) &#123;</span><br><span class="line">    Logger.debug(<span class="string">"Got <span class="variable">$item</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了前面的基础这个就很容易看懂了，<code>produce</code> 创建的协程返回了一个缓冲区大小为 0 的 <code>Channel</code>，为了问题描述起来比较容易，我们传入了一个 <code>Dispatchers.Unconfined</code> 调度器，意味着协程会立即在当前协程执行到第一个挂起点，所以会立即输出 <code>A</code> 并在 <code>send(1)</code> 处挂起，直到后面的 for 循环读到第一个值时，实际上就是 <code>channel</code> 的 <code>iterator</code> 的 <code>hasNext</code> 方法的调用，这个 <code>hasNext</code> 方法会检查是否有下一个元素，是一个挂起函数，在检查的过程中就会让前面启动的协程从 <code>send(1)</code> 挂起的位置继续执行，因此会看到日志 <code>B</code> 输出，然后再挂起到 <code>send(2)</code> 这里，这时候 <code>hasNext</code> 结束挂起，for 循环终于输出第一个元素，依次类推。输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">22:33:56:073 [main @coroutine#1]  A</span><br><span class="line">22:33:56:172 [main @coroutine#1]  B</span><br><span class="line">22:33:56:173 [main]  Got 1</span><br><span class="line">22:33:56:173 [main @coroutine#1]  Done</span><br><span class="line">22:33:56:176 [main]  Got 2</span><br></pre></td></tr></table></figure><p>我们看到 <code>B</code> 居然比 <code>Got 1</code> 先输出，同样，<code>Done</code> 也比 <code>Got 2</code> 先输出，这个看上去比较不符合直觉，不过挂起恢复的执行顺序确实如此，关键点就是我们前面提到的 <code>hasNext</code> 方法会挂起并触发了协程内部从挂起点继续执行的操作。如果你选择了其他调度器，当然也会有其他合理的结果输出。不管怎么样，我们体验了一把用 <code>Channel</code> 模拟 <code>sequence</code>。如果类似的代码换作 <code>sequence</code>，是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sequence = sequence &#123;</span><br><span class="line">    Logger.debug(<span class="string">"A"</span>)</span><br><span class="line">    yield(<span class="number">1</span>)</span><br><span class="line">    Logger.debug(<span class="string">"B"</span>)</span><br><span class="line">    yield(<span class="number">2</span>)</span><br><span class="line">    Logger.debug(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger.debug(<span class="string">"before sequence"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> sequence) &#123;</span><br><span class="line">    Logger.debug(<span class="string">"Got <span class="variable">$item</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sequence</code> 的执行顺序要直观的多，它没有调度器的概念，而且 <code>sequence</code> 的 <code>iterator</code> 的 <code>hasNext</code> 和 <code>next</code> 都不是挂起函数，在 <code>hasNext</code> 的时候同样会触发元素的查找，这时候就会触发 <code>sequence</code> 内部逻辑的执行，因此这次实际上是先触发了 <code>hasNext</code> 才会输出 A，<code>yield</code> 把 1 传出来作为 <code>sequence</code> 的第一个元素，这样就会有 Got 1 这样的输出，完整输出如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">600</span> [main]  A</span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">603</span> [main]  Got <span class="number">1</span></span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  B</span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  Got <span class="number">2</span></span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  Done</span><br></pre></td></tr></table></figure><p><code>sequence</code> 本质上就是基于标准库的协程 API 实现的，没有上层协程框架的作用域以及 Job 这样的概念。</p><p>所以我们可以在 <code>Channel</code> 的例子里面切换不同的调度器来生成元素，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class="line">    Logger.debug(<span class="number">1</span>)</span><br><span class="line">    send(<span class="number">1</span>)</span><br><span class="line">    withContext(Dispatchers.IO)&#123;</span><br><span class="line">        Logger.debug(<span class="number">2</span>)</span><br><span class="line">        send(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Logger.debug(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sequence 就不行了。</p><p>当然，单纯的用 <code>Channel</code> 当做序列生成器来使用有点儿小题大做，这里更多的是告诉大家存在这样的可能性，大家在将来遇到合适的场景时，就可以灵活运用了。</p><h2 id="8-Channel-的内部结构"><a href="#8-Channel-的内部结构" class="headerlink" title="8. Channel 的内部结构"></a>8. Channel 的内部结构</h2><p>前面我们提到 <code>sequence</code> 无法享受更上层的协程框架概念下的各种能力，还有一点 <code>sequence</code> 显然不是线程安全的，而 <code>Channel</code> 可以在并发场景下使用。</p><p><code>Channel</code> 内部结构我们主要说下缓冲区分别是链表和数组的版本。链表版本的定义主要是在 <code>AbstractSendChannel</code> 当中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSendChannel</span>&lt;<span class="type">E</span>&gt; : <span class="type">SendChannel</span>&lt;<span class="type">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> queue = LockFreeLinkedListHead()</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LockFreeLinkedListHead</code> 本身其实就是一个双向链表的节点，实际上 <code>Channel</code> 把它首尾相连成为了循环链表，而这个 <code>queque</code> 就是哨兵(sentinel)节点。有新的元素添加时，就在 <code>queue</code> 的前面插入，实际上就相当于在整个队列的最后插入元素了。</p><p>它所谓的 <code>LockFree</code> 在 Java 虚拟机上其实是通过原子读写来实现的， 对于链表来说，需要修改的无非就是前后节点的引用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeLinkedListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _next = atomic&lt;Any&gt;(<span class="keyword">this</span>) <span class="comment">// Node | Removed | OpDescriptor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _prev = atomic&lt;Any&gt;(<span class="keyword">this</span>) <span class="comment">// Node | Removed</span></span><br><span class="line">    ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现基于一篇论文中提到的无锁链表的实现，由于 CAS 原子操作通常只能修改一个引用，对于需要原子同时修改前后节点引用的情形是不适用的，例如单链表插入节点时需要修改两个引用，分别是操作节点的前一个节点的 next 和自己的 next，即 Head -&gt; A -&gt; B -&gt; C 在 A 、B 之间插件 X 时会需要先修改 X -&gt; B 再修改 A -&gt; X，如果这个过程中 A 被删除，那么可能的结果是 X 一并被删除，得到的链表是 Head -&gt; B -&gt; C。</p><p>这个无锁链表的实现通过引入 prev 来辅助解决这个问题，即在 A 被删除的问题发生的同时，其实我们是可以做到 X.next = B，X.prev = A 的，这时候判断如果 A 已经被移除了，那么 B.prev 本来是 A，结果就变成了 Head，这时候就可以将 X.prev 再次赋值为 B.prev 来修复，当然这个过程稍稍有些复杂，有兴趣的同学也可以参考 <code>LockFreeLinkedListNode</code> 在 Jvm 上的实现。</p><p>而对于数组版本，<code>ArrayChannel</code> 就相对粗暴了，内部就是一个数组：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓冲区大小大于 8，会先分配大小为 8 的数组，在后续进行扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> buffer: Array&lt;Any?&gt; = arrayOfNulls&lt;Any?&gt;(min(capacity, <span class="number">8</span>))</span><br></pre></td></tr></table></figure><p>对这个数组读写时则直接用了一个 <code>ReentrantLock</code> 进行加锁。</p><p>这里是不是有优化的空间呢？其实对于数组的元素，我们同样可以进行 CAS 读写，如果大家有兴趣，可以参考下 <code>ConcurrentHashMap</code> 的实现，JDK 7 的实现中对于段数组的读写采用了 <code>UnSafe</code> 的 CAS 读写，JDK 1.8 直接干掉了分段，对于桶的读写也采用了 <code>UnSafe</code> 的 CAS。</p><blockquote><p>协程在 Js 和 Native 上的实现就要简单得多，因为它们的协程都只是在单线程上运行，基本不需要处理并发问题。</p></blockquote><h2 id="9-小结"><a href="#9-小结" class="headerlink" title="9. 小结"></a>9. 小结</h2><p><code>Channel</code> 的出现，应该说为协程注入了灵魂。每一个独立的协程不再是孤独的个体，<code>Channel</code> 可以让他们更加方便的协作起来。实际上 <code>Channel</code> 的概念并不是 Kotlin 原创的，且不说 Golang 里面的 <code>channel</code>，就说 Java NIO 当中也存在 <code>Channel</code> 这样的概念，其实这时候大家很容易就应该想到多路复用，多路复用的时候我们还能像前面那样简单的挂起吗？或者不挂起我们该怎么办呢？且看下回分解。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;code&gt;Channel&lt;/code&gt; 实际上就是协程在生产消费者模型上的应用，把过去你用 &lt;code&gt;BlockingQueue&lt;/code&gt; 实现的功能替换成 &lt;code&gt;Channel&lt;/code&gt;，也许会有新的发现~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(8) - Android 篇</title>
    <link href="https://www.bennyhuo.com/2019/05/27/coroutine-android/"/>
    <id>https://www.bennyhuo.com/2019/05/27/coroutine-android/</id>
    <published>2019-05-26T16:00:00.000Z</published>
    <updated>2020-05-08T08:25:34.385Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~</p></blockquote><a id="more"></a><p>本文涉及的 MainScope 以及 AutoDispose 源码：<a href="https://github.com/enbandari/kotlin-coroutines-android" target="_blank" rel="noopener">kotlin-coroutines-android</a></p><h2 id="1-配置依赖"><a href="#1-配置依赖" class="headerlink" title="1. 配置依赖"></a>1. 配置依赖</h2><p>我们曾经提到过，如果在 Android 上做开发，那么我们需要引入</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutine_version'</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这个框架里面包含了 Android 专属的 `Dispatcher`，我们可以通过 `Dispatchers.Main` 来拿到这个实例；也包含了 `MainScope`，用于与 Android 作用域相结合。</span><br><span class="line"></span><br><span class="line">~~Anko 也提供了一些比较方便的方法，例如 `onClick` 等等，如果需要，也可以引入它的依赖：~~（Anko 已经停止维护）</span><br><span class="line"></span><br><span class="line">```gradle</span><br><span class="line"><span class="comment">//提供 onClick 类似的便捷的 listener，接收 suspend Lambda 表达式</span></span><br><span class="line">implementation <span class="string">"org.jetbrains.anko:anko-sdk27-coroutines:$anko_version"</span></span><br><span class="line"><span class="comment">//提供 bg 、asReference，未跟进 kotlin 1.3 的正式版协程，不过代码比较简单，如果需要可以自己改造</span></span><br><span class="line">implementation <span class="string">"org.jetbrains.anko:anko-coroutines:$anko_version"</span></span><br></pre></td></tr></table></figure><p>简单来说：</p><ul><li>kotlinx-coroutines-android 这个框架是必选项，主要提供了专属调度器</li><li><del>anko-sdk27-coroutines 是可选项，提供了一些 UI 组件更为简洁的扩展，例如 onClick，但它也有自己的问题，我们后面详细探讨</del></li><li><del>anko-coroutines 仅供参考，未跟进 1.3 正式版协程，因此在 1.3 之后的版本中尽量不要使用，提供的两个方法都比较简单，如果需要，可自行改造使用。</del></li></ul><p>协程的原理和用法我们已经探讨了很多了，关于 Android 上面的协程使用，我们就只给出几点实践的建议。</p><h2 id="2-UI-生命周期作用域"><a href="#2-UI-生命周期作用域" class="headerlink" title="2. UI 生命周期作用域"></a>2. UI 生命周期作用域</h2><p>Android 开发经常想到的一点就是让发出去的请求能够在当前 UI 或者 Activity 退出或者销毁的时候能够自动取消，我们在用 RxJava 的时候也有过各种各样的方案来解决这个问题。</p><h3 id="2-1-使用-MainScope"><a href="#2-1-使用-MainScope" class="headerlink" title="2.1 使用 MainScope"></a>2.1 使用 MainScope</h3><p>协程有一个很天然的特性能刚够支持这一点，那就是作用域。官方也提供了 <code>MainScope</code> 这个函数，我们具体看下它的使用方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line">launchButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        textView.text = async(Dispatchers.IO) &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">3</span>)</span><br><span class="line">            <span class="string">"Hello1111"</span></span><br><span class="line">        &#125;.await()</span><br><span class="line">        log(<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现它其实与其他的 <code>CoroutineScope</code> 用起来没什么不一样的地方，通过同一个叫 <code>mainScope</code> 的实例启动的协程，都会遵循它的作用域定义，那么 <code>MainScope</code> 的定义时怎样的呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">MainScope</span><span class="params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)</span><br></pre></td></tr></table></figure><p>原来就是 <code>SupervisorJob</code> 整合了 <code>Dispatchers.Main</code> 而已，它的异常传播是自上而下的，这一点与 <code>supervisorScope</code> 的行为一致，此外，作用域内的调度是基于 Android 主线程的调度器的，因此作用域内除非明确声明调度器，协程体都调度在主线程执行。因此上述示例的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-04-29 06:51:00.657 D: [main] 1</span><br><span class="line">2019-04-29 06:51:00.659 D: [DefaultDispatcher-worker-1] 2</span><br><span class="line">2019-04-29 06:51:01.662 D: [DefaultDispatcher-worker-2] 3</span><br><span class="line">2019-04-29 06:51:01.664 D: [main] 4</span><br></pre></td></tr></table></figure><p>如果我们在触发前面的操作之后立即在其他位置触发作用域的取消，那么该作用域内的协程将不再继续执行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line"></span><br><span class="line">launchButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cancelButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.cancel()</span><br><span class="line">    log(<span class="string">"MainScope is cancelled."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们快速依次点击上面的两个按钮，结果就显而易见了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-04-29 07:12:20.625 D: [main] 1</span><br><span class="line">2019-04-29 07:12:20.629 D: [DefaultDispatcher-worker-2] 2</span><br><span class="line">2019-04-29 07:12:21.046 D: [main] MainScope is cancelled.</span><br></pre></td></tr></table></figure><h3 id="2-2-构造带有作用域的抽象-Activity"><a href="#2-2-构造带有作用域的抽象-Activity" class="headerlink" title="2.2 构造带有作用域的抽象 Activity"></a>2.2 构造带有作用域的抽象 Activity</h3><p>尽管我们前面体验了 <code>MainScope</code> 发现它可以很方便的控制所有它范围内的协程的取消，以及能够无缝将异步任务切回主线程，这都是我们想要的特性，不过写法上还是不够美观。</p><p>官方推荐我们定义一个抽象的 <code>Activity</code>，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopedActivity</span>: <span class="type">Activity</span></span>(), CoroutineScope <span class="keyword">by</span> MainScope()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在 <code>Activity</code> 退出的时候，对应的作用域就会被取消，所有在该 <code>Activity</code> 中发起的请求都会被取消掉。使用时，只需要继承这个抽象类即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineActivity</span> : <span class="type">ScopedActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_coroutine)</span><br><span class="line">        launchButton.setOnClickListener &#123;</span><br><span class="line">            launch &#123; <span class="comment">// 直接调用 ScopedActivity 也就是 MainScope 的方法</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">anotherOps</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了在当前 <code>Activity</code> 内部获得 <code>MainScope</code> 的能力外，还可以将这个 Scope 实例传递给其他需要的模块，例如 <code>Presenter</code> 通常也需要与 <code>Activity</code> 保持同样的生命周期，因此必要时也可以将该作用域传递过去：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutinePresenter</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> scope: CoroutineScope): CoroutineScope <span class="keyword">by</span> scope&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        launch &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多数情况下，<code>Presenter</code> 的方法也会被 <code>Activity</code> 直接调用，因此也可以将 <code>Presenter</code> 的方法生命成 <code>suspend</code> 方法，然后用 <code>coroutineScope</code> 嵌套作用域，这样 <code>MainScope</code> 被取消后，嵌套的子作用域一样也会被取消，进而达到取消全部子协程的目的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutinePresenter</span> </span>&#123;</span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">        launch &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-更友好地为-Activity-提供作用域"><a href="#2-3-更友好地为-Activity-提供作用域" class="headerlink" title="2.3 更友好地为 Activity 提供作用域"></a>2.3 更友好地为 Activity 提供作用域</h3><p>抽象类很多时候会打破我们的继承体系，这对于开发体验的伤害还是很大的，因此我们是不是可以考虑构造一个接口，只要 <code>Activity</code> 实现这个接口就可以拥有作用域以及自动取消的能力呢？</p><p>首先我们定义一个接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ScopedActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> scope: CoroutineScope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个朴实的愿望就是希望实现这个接口就可以自动获得作用域，不过问题来了，这个 <code>scope</code> 成员要怎么实现呢？留给接口实现方的话显然不是很理想，自己实现吧，又碍于自己是个接口，因此我们只能这样处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> scopeMap = IdentityHashMap&lt;MainScoped, MainScope&gt;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> mainScope: CoroutineScope</span><br><span class="line">        <span class="keyword">get</span>() = scopeMap[<span class="keyword">this</span> <span class="keyword">as</span> Activity]!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的事情就是在合适的实际去创建和取消对应的作用域了，我们接着定义两个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createScope</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//或者改为 lazy 实现，即用到时再创建</span></span><br><span class="line">        <span class="keyword">val</span> activity = <span class="keyword">this</span> <span class="keyword">as</span> Activity</span><br><span class="line">        scopeMap[activity] ?: MainScope().also &#123; scopeMap[activity] = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroyScope</span><span class="params">()</span></span>&#123;</span><br><span class="line">        scopeMap.remove(<span class="keyword">this</span> <span class="keyword">as</span> Activity)?.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们需要 <code>Activity</code> 去实现这个接口，因此直接强转即可，当然如果考虑健壮性，可以做一些异常处理，这里作为示例仅提供核心实现。</p><p>接下来就是考虑在哪儿完成创建和取消呢？显然这件事儿用 <code>Application.ActivityLifecycleCallbacks</code> 最合适不过了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityLifecycleCallbackImpl</span>: <span class="type">Application.ActivityLifecycleCallbacks &#123;</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(activity: <span class="type">Activity</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        (activity <span class="keyword">as</span>? MainScoped)?.createScope()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        (activity <span class="keyword">as</span>? MainScoped)?.destroyScope()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是在 <code>Application</code> 里面注册一下这个监听了，这个大家都会，我就不给出代码了。</p><p>我们看下如何使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineActivity</span> : <span class="type">Activity</span></span>(), MainScoped &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        launchButton.setOnClickListener &#123;            </span><br><span class="line">            scope.launch &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以增加一些有用的方法来简化这个操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">withScope</span><span class="params">(block: <span class="type">CoroutineScope</span>.()</span></span> -&gt; T) = with(scope, block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在 <code>Activity</code> 当中还可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">withScope &#123;</span><br><span class="line">    launch &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，示例当中用到了 <code>IdentityHashMap</code>，这表明对于 scope 的读写是非线程安全的，因此不要在其他线程试图去获取它的值，除非你引入第三方或者自己实现一个 <code>IdentityConcurrentHashMap</code>，即便如此，从设计上 <code>scope</code> 也不太应该在其他线程访问。</p></blockquote><p>按照这个思路，我提供了一套更加完善的方案，不仅支持 <code>Activity</code> 还支持 support-fragment 版本在 25.1.0 以上的版本的 <code>Fragment</code>，并且类似于 Anko 提供了一些有用的基于 <code>MainScope</code> 的 listener 扩展，引入这个框架即可使用：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api <span class="string">'com.bennyhuo.kotlin:coroutines-android-mainscope:1.0'</span></span><br></pre></td></tr></table></figure><h3 id="2-4-Androidx-的协程支持"><a href="#2-4-Androidx-的协程支持" class="headerlink" title="2.4 Androidx 的协程支持"></a>2.4 Androidx 的协程支持</h3><p>Android 官方对于协程的支持也是非常积极的。</p><p>KTX 为 Jetpack 的 Lifecycle 相关的组件都提供了已经绑定了生命周期的作用域供我们直接使用，添加 Lifecycle 相应的基础组件之后，再添加以下组件即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-runtime-ktx:<span class="variable">$ktx_version</span>"</span></span><br></pre></td></tr></table></figure><p><code>lifecycle-runtime-ktx</code> 提供了 <code>LifecycleCoroutineScope</code> 类以及其获得方式，例如我们可以直接在 <code>MainActivity</code> 中使用 <code>lifecycleScope</code> 来获取这个实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            lifecycleScope.launch &#123;</span><br><span class="line">                ...<span class="comment">// 执行协程体</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这当然是因为 <code>MainActivity</code> 的父类实现了 <code>LifecycleOwner</code> 这个接口，而 <code>lifecycleScope</code> 则正是它的扩展成员。</p><p>如果想要在 <code>ViewModel</code> 当中使用作用域，我们需要再添加以下依赖：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-ktx:<span class="variable">$ktx_version</span>"</span></span><br></pre></td></tr></table></figure><p>使用方法类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            ... <span class="comment">// 执行协程体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewModel</code> 的作用域会在它的 <code>clear</code> 函数调用时取消。</p><h2 id="3-谨慎使用-GlobalScope"><a href="#3-谨慎使用-GlobalScope" class="headerlink" title="3. 谨慎使用 GlobalScope"></a>3. 谨慎使用 GlobalScope</h2><h3 id="3-1-GlobalScope-存在什么问题"><a href="#3-1-GlobalScope-存在什么问题" class="headerlink" title="3.1 GlobalScope 存在什么问题"></a>3.1 GlobalScope 存在什么问题</h3><p>我们之前做例子经常使用 <code>GlobalScope</code>，但 <code>GlobalScope</code> 不会继承外部作用域，因此大家使用时一定要注意，如果在使用了绑定生命周期的 <code>MainScope</code> 之后，内部再使用 <code>GlobalScope</code> 启动协程，意味着 <code>MainScope</code> 就不会起到应有的作用。</p><p>这里需要小心的是如果使用了一些没有依赖作用域的构造器，那么一定要小心。例如 Anko 当中的 <code>onClick</code> 扩展：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClick</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>)</span></span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许我们也就是图个方便，毕竟 <code>onClick</code> 写起来可比 <code>setOnClickListener</code> 要少很多字符，同时名称上看也更加有事件机制的味道，但隐藏的风险就是通过 <code>onClick</code> 启动的协程并不会随着 <code>Activity</code> 的销毁而被取消，其中的风险需要自己思考清楚。</p><p>当然，Anko 会这么做的根本原因在于 <code>OnClickListener</code> 根本拿不到有生命周期加持的作用域。不用 <code>GlobalScope</code> 就无法启动协程，怎么办？结合我们前面给出的例子，其实这个事儿完全有别的解法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainScoped</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> View.<span class="title">onClickSuspend</span><span class="params">(handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">        setOnClickListener &#123; v -&gt;</span><br><span class="line">            scope.launch &#123;   handler(v)   &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在前面定义的 <code>MainScoped</code> 接口中，可以通过 <code>scope</code> 拿到有生命周期加持的 <code>MainScope</code> 实例，那么直接用它启动协程来运行 <code>OnClickListener</code> 问题不就解决了嘛。所以这里的关键点在于如何拿到作用域。</p><p>这样的 listener 我已经为大家在框架中定义好啦，请参见 2.3。</p><p>当然，如果项目已经集成了 AndroidX，还是更加推荐大家直接使用官方的作用域扩展。另外需要注意的是，Anko 已经停止维护，不再建议使用了。</p><h3 id="3-2-协程版-AutoDisposable"><a href="#3-2-协程版-AutoDisposable" class="headerlink" title="3.2 协程版 AutoDisposable"></a>3.2 协程版 AutoDisposable</h3><p>当然除了直接使用一个合适的作用域来启动协程之外，我们还有别的办法来确保协程及时被取消。</p><p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p><p>因此大家一定会用到 Uber 的开源框架 <a href="https://github.com/uber/AutoDispose" target="_blank" rel="noopener">AutoDispose</a>。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">extends</span> <span class="title">MainThreadDisposable</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnAttachStateChangeListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View view;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CompletableObserver observer;</span><br><span class="line"></span><br><span class="line">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.view = view;</span><br><span class="line">    <span class="keyword">this</span>.observer = observer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">    <span class="comment">//看到没看到没看到没？</span></span><br><span class="line">      observer.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    view.removeOnAttachStateChangeListener(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到前面提到的 Anko 扩展 <code>onClick</code> 无法取消协程的问题，我们也可以搞一个 <code>onClickAutoDisposable</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClickAutoDisposable</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>)</span></span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;.asAutoDisposable(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 <code>launch</code> 会启动一个 <code>Job</code>，因此我们可以通过 <code>asAutoDisposable</code> 来将其转换成支持自动取消的类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Job.<span class="title">asAutoDisposable</span><span class="params">(view: <span class="type">View</span>)</span></span> = AutoDisposableJob(view, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>那么 <code>AutoDisposableJob</code> 的实现只要参考 AutoDisposable 的实现依样画葫芦就好了 ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoDisposableJob</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View, <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Job)</span><br><span class="line">    <span class="comment">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class="line">     : Job <span class="keyword">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> = <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//当 View 被移除的时候，取消协程</span></span><br><span class="line">        cancel()</span><br><span class="line">        view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isViewAttached</span><span class="params">()</span></span> =</span><br><span class="line">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        <span class="keyword">if</span>(isViewAttached()) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class="line">        invokeOnCompletion() &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就可以使用这个扩展了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.onClickAutoDisposable&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令，尽管这种情况下协程的执行不会跟随 <code>Activity</code> 的 <code>onDestroy</code> 而取消，但它与 <code>View</code> 的点击事件紧密结合，即便 <code>Activity</code> 没有被销毁，<code>View</code> 本身被移除时也会直接将监听中的协程取消掉。</p><p>如果大家想要用这个扩展，我已经帮大家放到 jcenter 啦，直接使用：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api <span class="string">"com.bennyhuo.kotlin:coroutines-android-autodisposable:1.0"</span></span><br></pre></td></tr></table></figure><p>添加到依赖当中即可使用。</p><h2 id="4-合理使用调度器"><a href="#4-合理使用调度器" class="headerlink" title="4. 合理使用调度器"></a>4. 合理使用调度器</h2><p>在 Android 上使用协程，更多的就是简化异步逻辑的写法，使用场景更多与 RxJava 类似。在使用 RxJava 的时候，我就发现有不少开发者仅仅用到了它的切线程的功能，而且由于本身 RxJava 切线程 API 简单易用，还会造成很多无脑线程切换的操作，这样实际上是不好的。那么使用协程就更要注意这个问题了，因为协程切换线程的方式被 RxJava 更简洁，更透明，本来这是好事情，就怕被滥用。</p><p>比较推荐的写法是，绝大多数 UI 逻辑在 UI 线程中处理，即使在 UI 中用 <code>Dispatchers.Main</code> 来启动协程，如果涉及到一些 io 操作，使用 <code>async</code> 将其调度到 <code>Dispatchers.IO</code> 上，结果返回时协程会帮我们切回到主线程——这非常类似 Nodejs 这样的单线程的工作模式。</p><p>对于一些 UI 不相关的逻辑，例如批量离线数据下载任务，通常默认的调度器就足够使用了。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>这一篇文章，主要是基于我们前面讲了的理论知识，进一步往 Android 的具体实战角度迁移，相比其他类型的应用，Android 作为 UI 程序最大的特点就是异步要协调好 UI 的生命周期，协程也不例外。一旦我们把协程的作用域规则以及协程与 UI 生命周期的关系熟稔于心，那么相信大家使用协程时一定会得心应手的。</p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课，课程第一版曾帮助3000多名同学掌握 Kotlin，这次更新回归内容更精彩：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识，目前已经有近 1000 位同学在学习：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
      <category term="Android" scheme="https://www.bennyhuo.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(7) - 序列生成器篇</title>
    <link href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/"/>
    <id>https://www.bennyhuo.com/2019/05/26/coroutine-sequence/</id>
    <published>2019-05-25T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说出来你可能不信，Kotlin 1.1 协程还在吃奶的时候，Sequence 就已经正式推出了，然而，Sequence 生成器的实现居然有协程的功劳。</p></blockquote><a id="more"></a><h2 id="1-认识-Sequence"><a href="#1-认识-Sequence" class="headerlink" title="1. 认识 Sequence"></a>1. 认识 Sequence</h2><p>在 Kotlin 当中，Sequence 这个概念确切的说是“懒序列”，产生懒序列的方式可以有多种，下面我们介绍一种由基于协程实现的序列生成器。需要注意的是，这个功能内置于 Kotlin 标准库当中，不需要额外添加依赖。</p><p>下面我们给出一个斐波那契数列生成的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">val</span> fibonacci = sequence &#123;</span><br><span class="line">    yield(<span class="number">1L</span>) <span class="comment">// first Fibonacci number</span></span><br><span class="line">    <span class="keyword">var</span> cur = <span class="number">1L</span></span><br><span class="line">    <span class="keyword">var</span> next = <span class="number">1L</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        yield(next) <span class="comment">// next Fibonacci number</span></span><br><span class="line">        <span class="keyword">val</span> tmp = cur + next</span><br><span class="line">        cur = next</span><br><span class="line">        next = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fibonacci.take(<span class="number">5</span>).forEach(::log)</span><br></pre></td></tr></table></figure><p>这个 <code>sequence</code> 实际上也是启动了一个协程，<code>yield</code> 则是一个挂起点，每次调用时先将参数保存起来作为生成的序列迭代器的下一个值，之后返回 <code>COROUTINE_SUSPENDED</code>，这样协程就不再继续执行，而是等待下一次 <code>resume</code> 或者 <code>resumeWithException</code> 的调用，而实际上，这下一次的调用就在生成的序列的迭代器的 <code>next()</code> 调用时执行。如此一来，外部在遍历序列时，每次需要读取新值时，协程内部就会执行到下一次 <code>yield</code> 调用。</p><p>程序运行输出的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10:44:34:071 [main] 1</span><br><span class="line">10:44:34:071 [main] 1</span><br><span class="line">10:44:34:071 [main] 2</span><br><span class="line">10:44:34:071 [main] 3</span><br><span class="line">10:44:34:071 [main] 5</span><br></pre></td></tr></table></figure><p>除了使用 <code>yield(T)</code> 生成序列的下一个元素以外，我们还可以用 <code>yieldAll()</code> 来生成多个元素：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> seq = sequence &#123;</span><br><span class="line">    log(<span class="string">"yield 1,2,3"</span>)</span><br><span class="line">    yieldAll(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    log(<span class="string">"yield 4,5,6"</span>)</span><br><span class="line">    yieldAll(listOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">    log(<span class="string">"yield 7,8,9"</span>)</span><br><span class="line">    yieldAll(listOf(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">seq.take(<span class="number">5</span>).forEach(::log)</span><br></pre></td></tr></table></figure><p>从运行结果我们可以看到，在读取 4 的时候才会去执行到 <code>yieldAll(listOf(4, 5, 6))</code>，而由于 7 以后都没有被访问到，<code>yieldAll(listOf(7, 8, 9))</code> 并不会被执行，这就是所谓的“懒”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10:44:34:029 [main] yield 1,2,3</span><br><span class="line">10:44:34:060 [main] 1</span><br><span class="line">10:44:34:060 [main] 2</span><br><span class="line">10:44:34:060 [main] 3</span><br><span class="line">10:44:34:061 [main] yield 4,5,6</span><br><span class="line">10:44:34:061 [main] 4</span><br><span class="line">10:44:34:066 [main] 5</span><br></pre></td></tr></table></figure><h2 id="2-深入序列生成器"><a href="#2-深入序列生成器" class="headerlink" title="2. 深入序列生成器"></a>2. 深入序列生成器</h2><p>前面我们已经不止一次提到 <code>COROUTINE_SUSPENDED</code> 了，我们也很容易就知道 <code>yield</code> 和 <code>yieldAll</code> 都是 suspend 函数，既然能做到”懒“，那么必然在 <code>yield</code> 和 <code>yieldAll</code> 处是挂起的，因此它们的返回值一定是 <code>COROUTINE_SUSPENDED</code>，这一点我们在本文的开头就已经提到，下面我们来见识一下庐山真面目：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    nextValue = value</span><br><span class="line">    state = State_Ready</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c -&gt;</span><br><span class="line">        nextStep = c</span><br><span class="line">        COROUTINE_SUSPENDED</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>yield</code> 的实现，我们看到了老朋友 <code>suspendCoroutineUninterceptedOrReturn</code>，还看到了 <code>COROUTINE_SUSPENDED</code>，那么挂起的问题就很好理解了。而 <code>yieldAll</code> 是如出一辙：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yieldAll</span><span class="params">(iterator: <span class="type">Iterator</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!iterator.hasNext()) <span class="keyword">return</span></span><br><span class="line">    nextIterator = iterator</span><br><span class="line">    state = State_ManyReady</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c -&gt;</span><br><span class="line">        nextStep = c</span><br><span class="line">        COROUTINE_SUSPENDED</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的不同在于 <code>state</code> 的值，一个流转到了 <code>State_Ready</code>，一个是 <code>State_ManyReady</code>，也倒是很好理解嘛。</p><p>那么现在就剩下一个问题了，既然有了挂起，那么什么时候执行 <code>resume</code> ？这个很容易想到，我们在迭代序列的时候呗，也就是序列迭代器的 <code>next()</code> 的时候，那么这事儿就好办了，找下序列的迭代器实现即可，这个类型我们也很容易找到，显然 <code>yield</code> 就是它的方法，我们来看看 <code>next</code> 方法的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">when</span> (state) &#123;</span><br><span class="line">        State_NotReady, State_ManyNotReady -&gt; <span class="keyword">return</span> nextNotReady() <span class="comment">// ①</span></span><br><span class="line">        State_ManyReady -&gt; &#123; <span class="comment">// ②</span></span><br><span class="line">            state = State_ManyNotReady</span><br><span class="line">            <span class="keyword">return</span> nextIterator!!.next()</span><br><span class="line">        &#125;</span><br><span class="line">        State_Ready -&gt; &#123; <span class="comment">// ③</span></span><br><span class="line">            state = State_NotReady</span><br><span class="line">            <span class="keyword">val</span> result = nextValue <span class="keyword">as</span> T</span><br><span class="line">            nextValue = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> exceptionalState()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来依次看下这三个条件：</p><ul><li>① 是下一个元素还没有准备好的情况，调用 <code>nextNotReady</code> 会首先调用 <code>hasNext</code> 检查是否有下一个元素，检查的过程其实就是调用 <code>Continuation.resume</code>，如果有元素，就会再次调用 <code>next</code>，否则就抛异常</li><li>② 表示我们调用了 <code>yieldAll</code>，一下子传入了很多元素，目前还没有读取完，因此需要继续从传入的这个元素集合当中去迭代</li><li>③ 表示我们调用了一次 <code>yield</code>，而这个元素的值就存在 <code>nextValue</code> 当中</li></ul><p><code>hasNext</code> 的实现也不是很复杂：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            State_NotReady -&gt; &#123;&#125; <span class="comment">// ①</span></span><br><span class="line">            State_ManyNotReady -&gt; <span class="comment">// ②</span></span><br><span class="line">                <span class="keyword">if</span> (nextIterator!!.hasNext()) &#123;</span><br><span class="line">                    state = State_ManyReady</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextIterator = <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            State_Done -&gt; <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// ③</span></span><br><span class="line">            State_Ready, State_ManyReady -&gt; <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// ④</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> exceptionalState()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        state = State_Failed</span><br><span class="line">        <span class="keyword">val</span> step = nextStep!!</span><br><span class="line">        nextStep = <span class="literal">null</span></span><br><span class="line">        step.resume(<span class="built_in">Unit</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在通过 <code>next</code> 读取完一个元素之后，如果已经传入的元素已经没有剩余，状态会转为 <code>State_NotReady</code>，下一次取元素的时候就会在 <code>next</code> 中触发到 <code>hasNext</code> 的调用，① 处什么都没有干，因此会直接落到后面的 <code>step.resume()</code>，这样就会继续执行我们序列生成器的代码，直到遇到 <code>yield</code> 或者 <code>yieldAll</code>。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>序列生成器很好的利用了协程的状态机特性，将序列生成的过程从形式上整合到了一起，让程序更加紧凑，表现力更强。本节讨论的序列，某种意义上更像是生产 - 消费者模型中的生产者，而迭代序列的一方则像是消费者，其实在 kotlinx.coroutines 库中提供了更为强大的能力来实现生产 - 消费者模式，我们将在后面的文章当中展示给大家看。</p><p>协程的回调特性可以让我们在实践当中很好的替代传统回调的写法，同时它的状态机特性也可以让曾经的状态机实现获得新的写法，除了序列之外，也许还会有更多有趣的适用场景等待我们去发掘~</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;说出来你可能不信，Kotlin 1.1 协程还在吃奶的时候，Sequence 就已经正式推出了，然而，Sequence 生成器的实现居然有协程的功劳。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>如何看待 Google 将 Kotlin 作为 Android 开发首选语言？</title>
    <link href="https://www.bennyhuo.com/2019/05/10/google-preferred-kotlin/"/>
    <id>https://www.bennyhuo.com/2019/05/10/google-preferred-kotlin/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你觉得天气热不舒服，那一定是享受过凉爽之后才会有的感觉。你没有意识到 Java 的问题，那正说明你应该试试 Kotlin。</p></blockquote><a id="more"></a><p>相比两年前第一次大范围的出现在公众面前，Kotlin 这一次其实有点儿顺其自然了，成为首选是情理之中的事儿，没什么大惊小怪的。</p><p>Kotlin 从 2016.2.19 发了 1.0 以来，基本上一年一个大版本的速度在发展，短短数年时间在行业内立足，并且向全平台推进，雄心可见一斑。不过观察来观察去，以前 Java 服务端的同学也许也开始慢慢尝试，但它的使用者仍然是 Android 开发者为主，这与 Google 的大力推荐有很大的关系，用群里一个小伙伴的说法就是：都是你们这些人闹得，整这么多技术学都学不过来——虽然这话有点儿小牢骚，但至少说明大家最开始都是被逼上梁山的。</p><p>我从16年就在公司项目的线上代码中各种尝试 Kotlin 的特性了，目前我自己基本上除非必须很少写 Java 代码，但这么长时间下来同组其他同学大多并没有表现出对 Kotlin 的热情，为什么？因为 Java 够用啊，能实现我的需求就可以了啊。我本也是想推动一下大家去使用的，但我偏偏又不爱干强人所难的事儿，因为如果我刻意去推大家转 Kotlin，会让 Kotlin 的切入变成是对现状的屈从、充满了来自行业的压迫感，这样会往往让大家忽略掉来自体验语言本身优秀特性的幸福感。所以我觉得没必要让语言的切换变成某种“政治”意义上的东西，它不应该是一种自上而下的做法，而应该是一种自下而上的革命。</p><p>我已经从事了好几年的 Kotlin 布道，Kotlin 对于我而言已经超出了工具的范畴，我会像追星一样关注它的发展，关注 Slack 上面的聊天，关注 GitHub 仓库的提交，这一切都来自曾经的不情愿和后来的“真香”。Kotlin 第一次进入我的视野源自一次 IntelliJ Community 源码的构建，当时看到后缀为 kt 的文件，我就崩溃了，Groovy 和 Scala 我还没学明白，怎么又来一门新语言——相信大家最初的想法都跟我一样，我当年不知道是有多么喜欢 Java——然而逼着自己学了几天 Kotlin 之后，就收到了“真香”警告，网上流传很久的一篇来自 Bugly 公众号的文章 <a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=404087761&amp;idx=1&amp;sn=d80625ee52f860a7a2ed4c238d2151b6" target="_blank" rel="noopener">Android开发必备知识：为什么说Kotlin值得一试</a> 就是之后没过多久我在公司内部发表的一篇文章，后面又被 Bugly 公众号转载了出来。</p><p>Kotlin 究竟有多香呢？</p><p>讲个故事：我大学四年在重庆读书宿舍没有空调，而重庆的夏天有多热呢？据说在石头上打一颗鸡蛋都可以熟，上午下暴雨下午太阳出来半个小时就看不出任何暴雨痕迹，每年夏天总有那么几天不用上课是因为高温。。。十年前校内还是很流行的，一张全城热死的海报被疯狂转载。。。</p><p><strong>解放碑 50° 么，我的天！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15574446261266.jpg" alt=""></p><p>后来毕业后，终于可以自己装空调了，发现原来夏天还可以这么爽。现在倒好，出门热一会儿我都觉得难受。</p><p>那这跟 Kotlin 有什么关系呢？这就是用 Java 与用 Kotlin 的对比，也许你觉得用 Java 写代码感觉良好，那都是错觉，就好比你从小生活在炎热的天气从来不开空调，就根本不知道开空调有多舒服。</p><p>大家往往在推动别人使用 Kotlin 的时候，只会提到它的开发效率，安全性之类的，其实还要一个更重要的就是，它的很多语法特性与最新的编程思维接轨，你可以只学一门语言就可以领略众多编程方法、思路，所谓窥一斑而知全豹，一门语言让你既可以面向对象，也可以面向函数，既可以线程，也可以协程，既可以 Android 又可以 iOS。开阔眼界，提升思维能力是从码农到可以秀的码农的重要一环。</p><p>说到这里再引用别人的一个观点：当你掌握两门以上外语的时候才能够真正领略到外语的对你思考方式的影响。大意如此吧，说这话的人我估计是要算上英语之外要大家再掌握一门语言的，我不想过分纠结外语的问题，只是想告诉大家，编程语言也是如此。如果你只掌握了一门语言比如 Java，实际上你甚至相当于连一门语言都没有掌握，我在学习 Kotlin 的过程中与 Java 做了大量的对比，这个过程不仅没有让我的 Java 水平受任何负面影响，还实实在在的促进了对 Java 语言体系的认识和理解。</p><p>所谓身在其中自然不得其全貌，多学几门语言，你才能够解锁上帝视角。如果你想要在技术这条路上走得更远，那么请多多接触，作为 Java 开发者，不只是 Kotlin，我也还建议大家认真了解下 Python、JavaScript 还有 Go（如果。。算了，要学 Haskell 的人应该不需要看这篇文章） ，他们背后的生态差异会让你打开一扇又一扇新世界的大门。</p><p>共勉吧。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;如果你觉得天气热不舒服，那一定是享受过凉爽之后才会有的感觉。你没有意识到 Java 的问题，那正说明你应该试试 Kotlin。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Android" scheme="https://www.bennyhuo.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(6) - 协程挂起篇</title>
    <link href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/"/>
    <id>https://www.bennyhuo.com/2019/05/07/coroutine-suspend/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程的挂起最初是一个很神秘的东西，因为我们总是用线程的概念去思考，所以我们只能想到阻塞。不阻塞的挂起到底是怎么回事呢？说出来你也许会笑~~（哭？。。抱歉这篇文章我实在是没办法写的更通俗易懂了，大家一定要亲手实践！）</p></blockquote><a id="more"></a><h2 id="1-先看看-delay"><a href="#1-先看看-delay" class="headerlink" title="1. 先看看 delay"></a>1. 先看看 delay</h2><p>我们刚刚学线程的时候，最常见的模拟各种延时用的就是 <code>Thread.sleep</code> 了，而在协程里面，对应的就是 <code>delay</code>。<code>sleep</code> 让线程进入休眠状态，直到指定时间之后某种信号或者条件到达，线程就尝试恢复执行，而 <code>delay</code> 会让协程挂起，这个过程并不会阻塞 CPU，甚至可以说从硬件使用效率上来讲是“什么都不耽误”，从这个意义上讲 <code>delay</code> 也可以是让协程休眠的一种很好的手段。</p><p><code>delay</code> 的源码其实很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(timeMillis: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeMillis &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="comment">// don't delay</span></span><br><span class="line">    <span class="keyword">return</span> suspendCancellableCoroutine <span class="symbol">sc@</span> &#123; cont: CancellableContinuation&lt;<span class="built_in">Unit</span>&gt; -&gt;</span><br><span class="line">        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cont.context.delay.scheduleResumeAfterDelay</code> 这个操作，你可以类比 JavaScript 的 <code>setTimeout</code>，Android 的 <code>handler.postDelay</code>，本质上就是设置了一个延时回调，时间一到就调用 <code>cont</code> 的 resume 系列方法让协程继续执行。</p><p>剩下的最关键的就是 <code>suspendCancellableCoroutine</code> 了，这可是我们的老朋友了，前面我们用它实现了回调到协程的各种转换 —— 原来 <code>delay</code> 也是基于它实现的，如果我们再多看一些源码，你就会发现类似的还有 <code>join</code>、<code>await</code> 等等。</p><h2 id="2-再来说说-suspendCancellableCoroutine"><a href="#2-再来说说-suspendCancellableCoroutine" class="headerlink" title="2. 再来说说 suspendCancellableCoroutine"></a>2. 再来说说 suspendCancellableCoroutine</h2><p>既然大家对于 <code>suspendCancellableCoroutine</code> 已经很熟悉了，那么我们干脆直接召唤一个老朋友给大家：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">joinSuspend</span><span class="params">()</span></span> = suspendCancellableCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; cont -&gt;</span><br><span class="line">    cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(<span class="keyword">this</span>, cont).asHandler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Job.join()</code> 这个方法会首先检查调用者 <code>Job</code> 的状态是否已经完成，如果是，就直接返回并继续执行后面的代码而不再挂起，否则就会走到这个 <code>joinSuspend</code> 的分支当中。我们看到这里只是注册了一个完成时的回调，那么传说中的 <code>suspendCancellableCoroutine</code> 内部究竟做了什么呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCancellableCoroutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">crossinline</span> block: (<span class="type">CancellableContinuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: T =</span><br><span class="line">    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class="line">        <span class="keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)</span><br><span class="line">        block(cancellable)</span><br><span class="line">        cancellable.getResult() <span class="comment">// 这里的类型是 Any?</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>suspendCoroutineUninterceptedOrReturn</code> 这个方法调用的源码是看不到的，因为它根本没有源码：P 它的逻辑就是帮大家拿到 <code>Continuation</code> 实例，真的就只有这样。不过这样说起来还是很抽象，因为有一处非常的可疑：<code>suspendCoroutineUninterceptedOrReturn</code> 的返回值类型是 <code>T</code>，而传入的 lambda 的返回值类型是 <code>Any?</code>， 也就是我们看到的 <code>cancellable.getResult()</code> 的类型是 <code>Any?</code>，这是为什么？</p><p>我记得在协程系列文章的开篇，我就提到过 <code>suspend</code> 函数的签名，当时是以 <code>await</code> 为例的，这个方法大致相当于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">User</span>&gt;)</span></span>: Any &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>suspend</code> 一方面为这个方法添加了一个 <code>Continuation</code> 的参数，另一方面，原先的返回值类型 <code>User</code> 成了 <code>Continuation</code> 的泛型实参，而真正的返回值类型竟然是 <code>Any</code>。当然，这里因为定义的逻辑返回值类型 <code>User</code> 是不可空的，因此真实的返回值类型也用了 <code>Any</code> 来示意，如果泛型实参是个可空的类型，那么真实的返回值类型也就是 <code>Any?</code> 了，这正与前面提到的 <code>cancellable.getResult()</code> 返回的这个 <code>Any?</code> 相对应。</p><blockquote><p>如果大家去查 <code>await</code> 的源码，你同样会看到这个 <code>getResult()</code> 的调用。</p></blockquote><p>简单来说就是，对于 <code>suspend</code> 函数，不是一定要挂起的，可以在需要的时候挂起，也就是要等待的协程还没有执行完的时候，等待协程执行完再继续执行；而如果在开始 <code>join</code> 或者 <code>await</code> 或者其他 <code>suspend</code> 函数，如果目标协程已经完成，那么就没必要等了，直接拿着结果走人即可。那么这个神奇的逻辑就在于 <code>cancellable.getResult()</code> 究竟返回什么了，且看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult</span><span class="params">()</span></span>: Any? &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (trySuspend()) <span class="keyword">return</span> COROUTINE_SUSPENDED <span class="comment">// ① 触发挂起逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (state <span class="keyword">is</span> CompletedExceptionally)  <span class="comment">// ② 异常立即抛出</span></span><br><span class="line">        <span class="keyword">throw</span> recoverStackTrace(state.cause, <span class="keyword">this</span>) </span><br><span class="line">    <span class="keyword">return</span> getSuccessfulResult(state) <span class="comment">// ③ 正常结果立即返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码 ① 处就是挂起逻辑了，表示这时候目标协程还没有执行完，需要等待结果，②③是协程已经执行完可以直接拿到异常和正常结果的两种情况。②③好理解，关键是 ①，它要挂起，这返回的是个什么东西？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> COROUTINE_SUSPENDED: Any <span class="keyword">get</span>() = CoroutineSingletons.COROUTINE_SUSPENDED</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineSingletons</span> </span>&#123; COROUTINE_SUSPENDED, UNDECIDED, RESUMED &#125;</span><br></pre></td></tr></table></figure><p>这是 1.3 的实现，1.3 以前的实现更有趣，就是一个白板 <code>Any</code>。其实是什么不重要，关键是这个东西是一个单例，任何时候协程见到它就知道自己该挂起了。</p><h2 id="3-深入挂起操作"><a href="#3-深入挂起操作" class="headerlink" title="3. 深入挂起操作"></a>3. 深入挂起操作</h2><p>既然说到挂起，大家可能觉得还是一知半解，还是不知道挂起究竟怎么做到的，怎么办？说真的这个挂起是个什么操作其实一直没有拿出来给大家看，不是我们太小气了，只是太早拿出来会比较吓人。。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">        continuation.resume(<span class="number">1024</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    COROUTINE_SUSPENDED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我写了这么一个 <code>suspend</code> 函数，在 <code>suspendCoroutineUninterceptedOrReturn</code> 当中直接返回了这个传说中的白板 <code>COROUTINE_SUSPENDED</code>，正常来说我们应该在一个协程当中调用这个方法对吧，可是我偏不，我写一段 Java 代码去调用这个方法，结果会怎样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallCoroutine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        Object value = SuspendTestKt.hello(<span class="keyword">new</span> Continuation&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@NotNull</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> CoroutineContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeWith</span><span class="params">(@NotNull Object o)</span> </span>&#123; <span class="comment">// ①</span></span><br><span class="line">                <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">                    handleResult(o);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Throwable throwable = (Throwable) o;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(value == IntrinsicsKt.getCOROUTINE_SUSPENDED())&#123; <span class="comment">// ②</span></span><br><span class="line">            LogKt.log(<span class="string">"Suspended."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handleResult(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        LogKt.log(<span class="string">"The result is "</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看上去比较奇怪，可能会让人困惑的有两处：</p><p>① 处，我们在 Kotlin 当中看到的 <code>resumeWith</code> 的参数类型是 <code>Result</code>，怎么这儿成了 <code>Object</code> 了？因为 <code>Result</code> 是内联类，编译时会用它唯一的成员替换掉它，因此就替换成了 <code>Object</code> （在Kotlin 里面是 <code>Any?</code>）</p><p>② 处 <code>IntrinsicsKt.getCOROUTINE_SUSPENDED()</code> 就是 Kotlin 的 <code>COROUTINE_SUSPENDED</code></p><p>剩下的其实并不难理解，运行结果自然就是如下所示了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">07:52:55:288 [main] 1</span><br><span class="line">07:52:55:293 [main] 3</span><br><span class="line">07:52:55:296 [main] Suspended.</span><br><span class="line">07:52:56:298 [Thread-0] 2</span><br><span class="line">07:52:56:306 [Thread-0] The result is 1024</span><br></pre></td></tr></table></figure><p>其实这段 Java 代码的调用方式与 Kotlin 下面的调用已经很接近了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过我们在 Kotlin 当中还是不太容易拿到 <code>hello</code> 在挂起时的真正返回值，其他的返回结果完全相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12:44:08:290 [main] 1</span><br><span class="line">12:44:08:292 [main] 3</span><br><span class="line">12:44:09:296 [Thread-0] 2</span><br><span class="line">12:44:09:296 [Thread-0] 1024</span><br></pre></td></tr></table></figure><p>很有可能你看到这里都会觉得晕头转向，没有关系，我现在已经开始尝试揭示一些协程挂起的背后逻辑了，比起简单的使用，概念的理解和接受需要有个小小的过程。</p><h2 id="4-深入理解协程的状态转移"><a href="#4-深入理解协程的状态转移" class="headerlink" title="4. 深入理解协程的状态转移"></a>4. 深入理解协程的状态转移</h2><p>前面我们已经对协程的原理做了一些揭示，显然 Java 的代码让大家能够更容易理解，那么接下来我们再来看一个更复杂的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">returnSuspended</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt;&#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        continuation.resume(<span class="string">"Return suspended."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    COROUTINE_SUSPENDED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">returnImmediately</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt;&#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="string">"Return immediately."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先定义两个挂起函数，第一个会真正挂起，第二个则会直接返回结果，这类似于我们前面讨论 <code>join</code> 或者 <code>await</code> 的两条路径。我们再用 Kotlin 给出一个调用它们的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    log(returnSuspended())</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    log(returnImmediately())</span><br><span class="line">    log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">08:09:37:090 [main] 1</span><br><span class="line">08:09:38:096 [Thread-0] Return suspended.</span><br><span class="line">08:09:38:096 [Thread-0] 2</span><br><span class="line">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class="line">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] Return immediately.</span><br><span class="line">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 4</span><br></pre></td></tr></table></figure><p>好，现在我们要揭示这段协程代码的真实面貌，为了做到这一点，我们用 Java 来仿写一下这段逻辑：</p><blockquote><p>注意，下面的代码逻辑上并不能做到十分严谨，不应该出现在生产当中，仅供学习理解协程使用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContinuationImpl</span> <span class="keyword">implements</span> <span class="title">Continuation</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> label = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Continuation&lt;Unit&gt; completion;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContinuationImpl</span><span class="params">(Continuation&lt;Unit&gt; completion)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completion = completion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CoroutineContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeWith</span><span class="params">(@NotNull Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = o;</span><br><span class="line">            <span class="keyword">switch</span> (label) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                    LogKt.log(<span class="number">1</span>);</span><br><span class="line">                    result = SuspendFunctionsKt.returnSuspended( <span class="keyword">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                    LogKt.log(result);</span><br><span class="line">                    LogKt.log(<span class="number">2</span>);</span><br><span class="line">                    result = DelayKt.delay(<span class="number">1000</span>, <span class="keyword">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                    LogKt.log(<span class="number">3</span>);</span><br><span class="line">                    result = SuspendFunctionsKt.returnImmediately( <span class="keyword">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">                    LogKt.log(result);</span><br><span class="line">                    LogKt.log(<span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completion.resumeWith(Unit.INSTANCE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            completion.resumeWith(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSuspended</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result == IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个 Java 类 <code>ContinuationImpl</code>，它就是一个 <code>Continuation</code> 的实现。</p><blockquote><p>实际上如果你愿意，你还真得可以在 Kotlin 的标准库当中找到一个名叫 <code>ContinuationImpl</code> 的类，只不过，它的 <code>resumeWith</code> 最终调用到了 <code>invokeSuspend</code>，而这个 <code>invokeSuspend</code> 实际上就是我们的协程体，通常也就是一个 Lambda 表达式 —— 我们通过 <code>launch</code>启动协程，传入的那个 Lambda 表达式，实际上会被编译成一个 <code>SuspendLambda</code> 的子类，而它又是 <code>ContinuationImpl</code> 的子类。</p></blockquote><p>有了这个类我们还需要准备一个 completion 用来接收结果，这个类仿照标准库的 <code>RunSuspend</code> 类实现，如果你有阅读前面的文章，那么你应该知道 suspend main 的实现就是基于这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunSuspend</span> <span class="keyword">implements</span> <span class="title">Continuation</span>&lt;<span class="title">Unit</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CoroutineContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeWith</span><span class="params">(@NotNull Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">            notifyAll(); <span class="comment">// 协程已经结束，通知下面的 wait() 方法停止阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Object result = <span class="keyword">this</span>.result;</span><br><span class="line">                <span class="keyword">if</span>(result == <span class="keyword">null</span>) wait(); <span class="comment">// 调用了 Object.wait()，阻塞当前线程，在 notify 或者 notifyAll 调用时返回</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(result <span class="keyword">instanceof</span> Throwable)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Throwable) result;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的关键点在于 <code>await()</code> 方法，它在其中起了一个死循环，不过大家不要害怕，这个死循环是个纸老虎，如果 <code>result</code> 是 <code>null</code>，那么当前线程会被立即阻塞，直到结果出现。具体的使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RunSuspend runSuspend = <span class="keyword">new</span> RunSuspend();</span><br><span class="line">        ContinuationImpl table = <span class="keyword">new</span> ContinuationImpl(runSuspend);</span><br><span class="line">        table.resumeWith(Unit.INSTANCE);</span><br><span class="line">        runSuspend.await();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>这写法简直就是 suspend main 的真实面貌了。</p></blockquote><p>我们看到，作为 completion 传入的 <code>RunSuspend</code> 实例的 <code>resumeWith</code> 实际上是在 <code>ContinuationImpl</code> 的 <code>resumeWtih</code> 的最后才会被调用，因此它的 <code>await()</code> 一旦进入阻塞态，直到 <code>ContinuationImpl</code> 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕正常退出了。</p><p>于是这段代码的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">08:36:51:305 [main] 1</span><br><span class="line">08:36:52:315 [Thread-0] Return suspended.</span><br><span class="line">08:36:52:315 [Thread-0] 2</span><br><span class="line">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class="line">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] Return immediately.</span><br><span class="line">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 4</span><br></pre></td></tr></table></figure><p>我们看到，这段普通的 Java 代码与前面的 Kotlin 协程调用完全一样。那么我这段 Java 代码的编写根据是什么呢？就是 Kotlin 协程编译之后产生的字节码。当然，字节码是比较抽象的，我这样写出来就是为了让大家更容易的理解协程是如何执行的，看到这里，相信大家对于协程的本质有了进一步的认识：</p><ul><li>协程的挂起函数本质上就是一个回调，回调类型就是 <code>Continuation</code></li><li>协程体的执行就是一个状态机，每一次遇到挂起函数，都是一次状态转移，就像我们前面例子中的 <code>label</code> 不断的自增来实现状态流转一样</li></ul><p>如果能够把这两点认识清楚，那么相信你在学习协程其他概念的时候就都将不再是问题了。如果想要进行线程调度，就按照我们讲到的调度器的做法，在 <code>resumeWith</code> 处执行线程切换就好了，其实非常容易理解的。官方的协程框架本质上就是在做这么几件事儿，如果你去看源码，可能一时云里雾里，主要是因为框架除了实现核心逻辑外还需要考虑跨平台实现，还需要优化性能，但不管怎么样，这源码横竖看起来就是五个字：状态机回调。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>不同以往，我们从这一篇开始毫无保留的为大家尝试揭示协程背后的逻辑，也许一时间可能有些难懂，不过不要紧，你可以使用协程一段时间之后再来阅读这些内容，相信一定会豁然开朗的。</p><p>当然，这一篇内容的安排更多是为后面的序列篇开路，Kotlin 的 <code>Sequence</code> 就是基于协程实现的，它的用法很简单，几乎与普通的 <code>Iterable</code> 没什么区别，因此序列篇我们会重点关注它的内部实现原理，欢迎大家关注。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;协程的挂起最初是一个很神秘的东西，因为我们总是用线程的概念去思考，所以我们只能想到阻塞。不阻塞的挂起到底是怎么回事呢？说出来你也许会笑~~（哭？。。抱歉这篇文章我实在是没办法写的更通俗易懂了，大家一定要亲手实践！）&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(5) - 协程取消篇</title>
    <link href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/"/>
    <id>https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程的任务的取消需要靠协程内部调用的协作支持，这就类似于我们线程中断以及对中断状态的响应一样。</p></blockquote><a id="more"></a><h2 id="1-线程的中断"><a href="#1-线程的中断" class="headerlink" title="1. 线程的中断"></a>1. 线程的中断</h2><p>我们先从大家熟悉的话题讲起。线程有一个被废弃的 <code>stop</code> 方法，这个方法会让线程立即死掉，并且释放它持有的锁，这样会让它正在读写的存储处于一个不安全的状态，因此 <code>stop</code> 被废弃了。如果我们启动了一个线程并让它执行一些任务，但很快我们就后悔了，<code>stop</code> 还不让用，那该怎么办？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = thread &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">thread.stop() <span class="comment">// !!! Deprecated!!!</span></span><br></pre></td></tr></table></figure><p>我们应该想办法让线程内部正在运行的任务跟我们合作把任务停掉，这样线程内部的任务停止之前还有机会清理一些资源，比如关闭流等等。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = thread &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">        log(<span class="string">"Interrupted, do cleaning stuff."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread.interrupt()</span><br></pre></td></tr></table></figure><p>像 <code>sleep</code> 这样的方法调用，文档明确指出它支持 <code>InterruptedException</code>，因此当线程被标记为中断状态时，它就会抛出 <code>InterruptedException</code> ，那么我们自然就可以捕获异常并做资源清理了。</p><p>所以请注意所谓的协作式的任务终止，协程的取消也就是 <code>cancel</code> 机制的思路也是如此。</p><h2 id="2-协程类似的例子"><a href="#2-协程类似的例子" class="headerlink" title="2. 协程类似的例子"></a>2. 协程类似的例子</h2><p>我们来看一个协程取消的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job1 = launch &#123; <span class="comment">// ①</span></span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        delay(<span class="number">1000</span>) <span class="comment">// ②</span></span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    job1.cancel() <span class="comment">// ③</span></span><br><span class="line">    log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们用了一个不一样的写法，我们没有用 suspend main，而是直接用 <code>runBlocking</code> 启动协程，这个方法在 Native 上也存在，都是基于当前线程启动一个类似于 Android 的 Looper 的死循环，或者叫消息队列，可以不断的发送消息给它进行处理。<code>runBlocking</code> 会启动一个 <code>Job</code>，因此这里也存在默认的作用域，不过这对于我们今天的讨论暂时没有太大影响。</p><p>这段代码 ① 处启动了一个子协程，它内部先输出 1，接着开始 <code>delay</code>， <code>delay</code> 与线程的 <code>sleep</code> 不同，它不会阻塞线程，你可以认为它实际上就是触发了一个延时任务，告诉协程调度系统 1000ms 之后再来执行后面的这段代码（也就是 log(2)）；而在这期间，我们在 ③ 处对刚才启动的协程触发了取消，因此在 ② 处的 <code>delay</code> 还没有回调的时候协程就被取消了，因为 <code>delay</code> 可以响应取消，因此 <code>delay</code> 后面的代码就不会再次调度了，不调度的原因也很简单，② 处的 <code>delay</code> 会抛一个 <code>CancellationException</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    log(<span class="string">"cancelled. <span class="variable">$e</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">2</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么输出的结果就不一样了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">06:54:56:361 [main] 1</span><br><span class="line">06:54:56:408 [main] 3</span><br><span class="line">06:54:56:411 [main] 4</span><br><span class="line">06:54:56:413 [main] cancelled. kotlinx.coroutines.JobCancellationException: Job was cancelled; job&#x3D;StandaloneCoroutine&#123;Cancelling&#125;@e73f9ac</span><br><span class="line">06:54:56:413 [main] 2</span><br></pre></td></tr></table></figure><p>大家看，这与线程的中断逻辑是不是非常的类似呢？</p><h2 id="3-完善我们之前的例子"><a href="#3-完善我们之前的例子" class="headerlink" title="3. 完善我们之前的例子"></a>3. 完善我们之前的例子</h2><p>之前我们有个例子，上一篇文章已经加入了异常处理逻辑，那么这次我们给它加上取消逻辑。之前是这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class="line">    getUser(<span class="keyword">object</span> : Callback&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            continuation.resume(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            continuation.resumeWithException(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加取消逻辑，那需要我们的 <code>getUser</code> 回调版本支持取消，我们看下我们的 <code>getUser</code> 是怎么实现的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(callback: <span class="type">Callback</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> call = OkHttpClient().newCall(</span><br><span class="line">            Request.Builder()</span><br><span class="line">                    .<span class="keyword">get</span>().url(<span class="string">"https://api.github.com/users/bennyhuo"</span>)</span><br><span class="line">                    .build())</span><br><span class="line"></span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : okhttp3.Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">            callback.onError(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            response.body()?.let &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    callback.onSuccess(User.from(it.string()))</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    callback.onError(e) <span class="comment">// 这里可能是解析异常</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;?: callback.onError(NullPointerException(<span class="string">"ResponseBody is null."</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发了个网络请求给 Github，让它把一个叫 <code>bennyhuo</code> 的用户信息返回来，我们知道 OkHttp 的这个 <code>Call</code> 是支持 <code>cancel</code> 的， 取消后，网络请求过程中如果读取到这个取消的状态，就会把请求给停止掉。既然这样，我们干脆直接改造 <code>getUser</code> 好了，这样还能省掉我们自己的 <code>Callback</code> 回调过程：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCancellableCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class="line">    <span class="keyword">val</span> call = OkHttpClient().newCall(...)</span><br><span class="line"></span><br><span class="line">    continuation.invokeOnCancellation &#123; <span class="comment">// ①</span></span><br><span class="line">        log(<span class="string">"invokeOnCancellation: cancel the request."</span>)</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : okhttp3.Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">            log(<span class="string">"onFailure: <span class="variable">$e</span>"</span>)</span><br><span class="line">            continuation.resumeWithException(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            log(<span class="string">"onResponse: <span class="subst">$&#123;response.code()&#125;</span>"</span>)</span><br><span class="line">            response.body()?.let &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    continuation.resume(User.from(it.string()))</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    continuation.resumeWithException(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; ?: continuation.resumeWithException(NullPointerException(<span class="string">"ResponseBody is null."</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里用到了 <code>suspendCancellableCoroutine</code>，而不是之前的 <code>suspendCoroutine</code>，这就是为了让我们的挂起函数支持协程的取消。该方法将获取到的 <code>Continuation</code> 包装成了一个 <code>CancellableContinuation</code>，通过调用它的 <code>invokeOnCancellation</code> 方法可以设置一个取消事件的回调，一旦这个回调被调用，那么意味着 <code>getUserCoroutine</code> 调用所在的协程被取消了，这时候我们也要相应的做出取消的响应，也就是把 OkHttp 发出去的请求给取消掉。</p><p>那么我们在调用它的时候，如果遇到了取消，会怎么样呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job1 = launch &#123; <span class="comment">//①</span></span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> user = getUserCoroutine()</span><br><span class="line">    log(user)</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">10</span>)</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">job1.cancel()</span><br><span class="line">log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>注意我们启动 ① 之后仅仅延迟了 10ms 就取消了它，网络请求的速度一般来讲还不会这么快，因此取消的时候大概率 <code>getUserCoroutine</code> 被挂起了，因此结果大概率是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">07</span>:<span class="number">31</span>:<span class="number">30</span>:<span class="number">751</span> [main] <span class="number">1</span></span><br><span class="line"><span class="number">07</span>:<span class="number">31</span>:<span class="number">31</span>:<span class="number">120</span> [main] <span class="number">3</span></span><br><span class="line"><span class="number">07</span>:<span class="number">31</span>:<span class="number">31</span>:<span class="number">124</span> [main] invokeOnCancellation: cancel the request.</span><br><span class="line"><span class="number">07</span>:<span class="number">31</span>:<span class="number">31</span>:<span class="number">129</span> [main] <span class="number">4</span></span><br><span class="line"><span class="number">07</span>:<span class="number">31</span>:<span class="number">31</span>:<span class="number">131</span> [OkHttp https:<span class="comment">//api.github.com/...] onFailure: java.io.IOException: Canceled</span></span><br></pre></td></tr></table></figure><p>我们发现，取消的回调被调用了，OkHttp 在收到我们的取消指令之后，也确实停止了网络请求，并且回调给我们一个 IO 异常，这时候我们的协程已经被取消，在处于取消状态的协程上调用 <code>Continuation.resume</code> 、 <code>Continuation.resumeWithException</code> 或者 <code>Continuation.resumeWith</code> 都会被忽略，因此 OkHttp 回调中我们收到 IO 异常后调用的 <code>continuation.resumeWithException(e)</code> 不会有任何副作用。</p><h2 id="4-再谈-Retrofit-的协程扩展"><a href="#4-再谈-Retrofit-的协程扩展" class="headerlink" title="4. 再谈 Retrofit 的协程扩展"></a>4. 再谈 Retrofit 的协程扩展</h2><h3 id="4-1-Jake-Wharton-的-Adapter-存在的问题"><a href="#4-1-Jake-Wharton-的-Adapter-存在的问题" class="headerlink" title="4.1 Jake Wharton 的 Adapter 存在的问题"></a>4.1 Jake Wharton 的 Adapter 存在的问题</h3><p>我在<a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程 - 入门篇</a> 提到了 Jake Wharton 大神为 Retrofit 写的 协程 Adapter，</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'</span></span><br></pre></td></tr></table></figure><p>它确实可以完成网络请求，不过有细心的小伙伴发现了它的问题：它怎么取消呢？我们把使用它的代码贴出来：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubServiceApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"users/&#123;login&#125;"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"login"</span>)</span> login: <span class="type">String</span>)</span></span>: Deferred&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好接口，创建 Retrofit 实例的时候传入对应的 Adapter：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> gitHubServiceApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .addCallAdapterFactory(CoroutineCallAdapterFactory()) <span class="comment">// 这里添加 Adapter</span></span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    retrofit.create(GitHubServiceApi::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用的时候就这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class="string">"bennyhuo"</span>)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    showUser(deferred.await())</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    showError(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要取消，我们可以直接调用 <code>deferred.cancel()</code>，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class="string">"bennyhuo"</span>)</span><br><span class="line">log(<span class="string">"2"</span>)</span><br><span class="line">withContext(Dispatchers.IO)&#123;</span><br><span class="line">    deferred.cancel()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    showUser(deferred.await())</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    showError(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12:59:54:185 [DefaultDispatcher-worker-1] 1</span><br><span class="line">12:59:54:587 [DefaultDispatcher-worker-1] 2</span><br><span class="line">kotlinx.coroutines.JobCancellationException: Job was cancelled; job&#x3D;CompletableDeferredImpl&#123;Cancelled&#125;@36699211</span><br></pre></td></tr></table></figure><p>这种情况下，其实网络请求确实是被取消的，这一点我们可以看下源码的处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">adapt</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;)</span></span>: Deferred&lt;T&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> deferred = CompletableDeferred&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">      deferred.invokeOnCompletion &#123; <span class="comment">// ①</span></span><br><span class="line">        <span class="keyword">if</span> (deferred.isCancelled) &#123;</span><br><span class="line">          call.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      call.enqueue(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;     </span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意 ① 处，<code>invokeOnCompletion</code> 在协程进入完成状态时触发，包括异常和正常完成，那么在这时候如果发现它的状态是已经取消的，那么结果就直接调用 <code>Call</code> 的取消即可。</p><p>这看上去确实很正常啊~ 不过 @阿永 在公众号的评论里面提到了一个 Case，仔细一看还真是有问题。我们给出示例来复现这个 Case：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">    log(<span class="string">"1"</span>)</span><br><span class="line">    <span class="keyword">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class="string">"bennyhuo"</span>)</span><br><span class="line">    log(<span class="string">"2"</span>)</span><br><span class="line">    deferred.invokeOnCompletion &#123;</span><br><span class="line">        log(<span class="string">"invokeOnCompletion, <span class="variable">$it</span>, <span class="subst">$&#123;deferred.isCancelled&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        showUser(deferred.await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">10</span>)</span><br><span class="line">job.cancelAndJoin()</span><br></pre></td></tr></table></figure><p>我们启动一个协程，在其中执行网络请求，那么正常来说，这时候 <code>getUserCoroutine</code> 返回的 <code>Deferred</code> 可以当做一个子协程，它应当遵循默认的作用域规则，在父作用域取消时被取消掉，但现实却并不是这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">54</span>:<span class="number">332</span> [DefaultDispatcher-worker-<span class="number">1</span>] <span class="number">1</span></span><br><span class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">54</span>:<span class="number">829</span> [DefaultDispatcher-worker-<span class="number">1</span>] <span class="number">2</span></span><br><span class="line">kotlinx.coroutines.JobCancellationException: Job was cancelled; job=StandaloneCoroutine&#123;Cancelling&#125;@<span class="number">19</span>aea38c</span><br><span class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">54</span>:<span class="number">846</span> [DefaultDispatcher-worker-<span class="number">1</span>] <span class="number">3</span></span><br><span class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">56</span>:<span class="number">937</span> [OkHttp https:<span class="comment">//api.github.com/...] invokeOnCompletion, null, false</span></span><br></pre></td></tr></table></figure><p>我们看到在调用 <code>deferred.await()</code> 的时候抛了个取消异常，这主要是因为 <code>await()</code> 所在的协程已经被我们用 <code>cancelAndJoin()</code> 取消，但从随后 <code>invokeOnCompletion</code> 的回调结果来看， <code>getUserCoroutine</code> 返回的 <code>Deferred</code> 并没有被取消，再仔细一看，时间上这个回调比前面的操作晚了 2s，那必然是网络请求返回之后才回调的。</p><p>所以问题究竟在哪里？在 <code>CoroutineCallAdapterFactory</code> 的实现中，为了实现异步转换，手动创建了一个 <code>CompletableDeferred</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">adapt</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;)</span></span>: Deferred&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> deferred = CompletableDeferred&lt;T&gt;() <span class="comment">// ①</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>CompletableDeferred</code> 本身就是一个 <code>Job</code> 的实现，它的构造可接受一个 <code>Job</code> 实例作为它的父协程，那么问题来了，这里并没有告诉它父协程究竟是谁，因此也就谈不上作用域的事儿了，这好像我们用 <code>GlobalScope.launch</code> 启动了一个协程一样。如果大家在 Android 当中使用 <code>MainScope</code>，那么同样因为前面说到的这个原因，导致 <code>CompletableDeferred</code> 没有办法被取消。</p><blockquote><p>@阿永 在公众号评论中提到这个问题，并提到了一个比较好的解决方案，下面我们为大家详细介绍。感谢 @阿永。</p></blockquote><p>说到这里我们再简单回顾下，作用域主要有 <code>GlobalScope</code>、<code>coroutineScope</code>、<code>supervisorScope</code>，对于取消，除了 <code>supervisorScope</code> 比较特别是单向取消，即父协程取消后子协程都取消，Android 中 <code>MainScope</code> 就是一个调度到 UI 线程的 <code>supervisorScope</code>；<code>coroutineScope</code> 的逻辑则是父子相互取消的逻辑；而 <code>GlobalScope</code> 会启动一个全新的作用域，与它外部隔离，内部遵循默认的协程作用域规则。</p><p>那么有没有办法解决这个问题呢？</p><p>直接解决还是比较困难的，因为 <code>CompletableDeferred</code> 构造所处的调用环境不是 suspend 函数，因而也没有办法拿到（很可能根本就没有！）父协程。</p><h3 id="4-2-如何正确的将回调转换为协程"><a href="#4-2-如何正确的将回调转换为协程" class="headerlink" title="4.2 如何正确的将回调转换为协程"></a>4.2 如何正确的将回调转换为协程</h3><p>前面我们提到既然 <code>adapt</code> 方法不是 suspend 方法，那么我们是不是应该在其他位置创建协程呢？</p><p>其实我们前面在讲 <code>getUserCoroutine</code> 的时候就不断为大家展示了如何将一个回调转换为协程调用的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCancellableCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>suspendCancellableCoroutine</code> 跟最初我们提到的 <code>suspendCoroutine</code> 一样，都是要获取当前协程的 <code>Continuation</code> 实例，这实际上就相当于要继承当前协程的上下文，因此我们只需要在真正需要切换协程的时候再去做这个转换即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> Call<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">        enqueue(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;?, response: <span class="type">Response</span>&lt;<span class="type">T</span>?&gt;)</span></span> &#123;</span><br><span class="line">                continuation.resumeWith(runCatching &#123; <span class="comment">// ①</span></span><br><span class="line">                    <span class="keyword">if</span> (response.isSuccessful) &#123;</span><br><span class="line">                        response.body()</span><br><span class="line">                            ?: <span class="keyword">throw</span> NullPointerException(<span class="string">"Response body is null: <span class="variable">$response</span>"</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> HttpException(response)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (continuation.isCancelled) <span class="keyword">return</span> <span class="comment">// ②</span></span><br><span class="line">                continuation.resumeWithException(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        continuation.invokeOnCancellation &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cancel()</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ex: Throwable) &#123;  <span class="comment">// ③</span></span><br><span class="line">                <span class="comment">//Ignore cancel exception </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看着这段代码会不会很眼熟？这与我们 <code>getUserCoroutine</code> 的写法几乎如出一辙，不过有几处细节值得关注，我用数字标注了他们的位置：</p><ul><li>① 处 <code>runCatching</code> 可以将一段代码的运行结果或者抛出的异常封装到一个 <code>Result</code> 类型当中，Kotlin 1.3 开始新增了 <code>Continuation.resumeWith(Result)</code> 这个方法， 这个点比起我们前面的写法更具 Kotlin 风格。</li><li>② 处在异常抛出时，判断了是否已经被取消。实际上如果网络请求被取消，这个回调确实会被调到，那么由于取消的操作是协程的由 <code>Continuation</code> 的取消发起的，因此这时候没必要再调用 <code>continuation.resumeWithException(t)</code> 来将异常再抛回来了。尽管我们前面其实也提到过，这时候继续调用 <code>continuation.resumeWithException(t)</code> 也没有任何逻辑上的副作用，但性能上多少还是会有一些开销。</li><li>③ 处，尽管 <code>Call.cancel</code> 的调用比较安全，但网络环境和状态难免情况复杂，因此对异常进行捕获会让这段代码更加健壮。如果 <code>cancel</code> 抛异常而没有捕获的话，那么等同于协程体内部抛出异常，具体如何传播看所在作用域的相关定义了。</li></ul><p>需要指出的是，这段代码片段源自 <a href="https://github.com/gildor/kotlin-coroutines-retrofit" target="_blank" rel="noopener">gildor/kotlin-coroutines-retrofit</a> ，大家也可以直接添加依赖进行使用：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'ru.gildor.coroutines:kotlin-coroutines-retrofit:1.1.0'</span></span><br></pre></td></tr></table></figure><p>这个框架代码量很少，但经过各路 Kotlin 协程专家的锤炼，逻辑手法很细腻，值得大家学习。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>这篇文章我们从线程中断的概念切入，类比学习协程的取消，实际上大家就会发现这二者从逻辑上和场景上有多么的相似。接着我们将之前我们一直提到的回调转协程的例子进一步升级，支持取消，这样大家就可以轻易的将回调转变为协程的挂起调用了。最后我们还分析了一下 Retrofit 的协程扩展的一些问题和解决方法，这个例子也进一步可以引发我们对协程作用域以及如何将现有程序协程化的思考。</p><p>再稍微提一句，协程不是一个简单的东西，毕竟它的原理涉及到对操作系统调度、程序运行机制这样程序界毕竟原始的话题，但你说如果我对前面提到的这些都不是很熟悉或者根本没有接触过，是不是就要跟协程拜拜了呢，其实也不是，只不过如果你对这些都不熟悉，那么可能需要多加练习培养出感觉，而不必一开始就关注原理和细节，依样画葫芦一样可以用的很好，就像大家不知道 RxJava 原理一样可以用的很好一样，协程也可以做到这一点的。</p><p>当然，作为一个有追求的程序员，我们不止要会用，还要用得好，无论如何我们都需要知道来龙去脉，这其中涉及到的基础知识的欠缺也是需要尽快补充的，不能偷懒哈 ：）</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;协程的任务的取消需要靠协程内部调用的协作支持，这就类似于我们线程中断以及对中断状态的响应一样。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(4) - 异常处理篇</title>
    <link href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/"/>
    <id>https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>异步代码的异常处理通常都比较让人头疼，而协程则再一次展现了它的威力。</p></blockquote><a id="more"></a><h2 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h2><p>我们在前面一篇文章当中提到了这样一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Callback = (User) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(callback: <span class="type">Callback</span>)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通常会定义这样的回调接口来实现异步数据的请求，我们可以很方便的将它转换成协程的接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    getUser &#123;</span><br><span class="line">        continuation.resume(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并最终交给按钮点击事件或者其他事件去触发这个异步请求：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserBtn.setOnClickListener &#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        userNameView.text = getUserCoroutine().name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，既然是请求，总会有失败的情形，而我们这里并没有对错误的处理，接下来我们就完善这个例子。</p><h2 id="2-添加异常处理逻辑"><a href="#2-添加异常处理逻辑" class="headerlink" title="2. 添加异常处理逻辑"></a>2. 添加异常处理逻辑</h2><p>首先我们加上异常回调接口函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callback</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们在改造一下我们的 <code>getUserCoroutine</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class="line">    getUser(<span class="keyword">object</span> : Callback&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            continuation.resume(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            continuation.resumeWithException(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到，我们似乎就是完全把 <code>Callback</code> 转换成了一个 <code>Continuation</code>，在调用的时候我们只需要：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userNameView.text = getUserCoroutine().name</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        userNameView.text = <span class="string">"Get User Error: <span class="variable">$e</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，你没看错，一个异步的请求异常，我们只需要在我们的代码中捕获就可以了，这样做的好处就是，请求的全流程异常都可以在一个 <code>try ... catch ...</code> 当中捕获，那么我们可以说真正做到了把异步代码变成了同步的写法。</p><p>如果你一直在用 RxJava 处理这样的逻辑，那么你的请求接口可能是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserObservable</span><span class="params">()</span></span>: Single&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Single.create&lt;User&gt; &#123; emitter -&gt;</span><br><span class="line">        getUser(<span class="keyword">object</span> : Callback&lt;User&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">                emitter.onSuccess(value)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                emitter.onError(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时大概是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getUserObservable()</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe (&#123; user -&gt;</span><br><span class="line">            userNameView.text = user.name</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            userNameView.text = <span class="string">"Get User Error: <span class="variable">$it</span>"</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>其实你很容易就能发现在这里 RxJava 做的事儿跟协程的目的是一样的，只不过协程用了一种更自然的方式。</p><blockquote><p>也许你已经对 RxJava 很熟悉并且感到很自然，但相比之下，RxJava 的代码比协程的复杂度更高，更让人费解，这一点我们后面的文章中也会持续用例子来说明这一点。</p></blockquote><h2 id="3-全局异常处理"><a href="#3-全局异常处理" class="headerlink" title="3. 全局异常处理"></a>3. 全局异常处理</h2><p>线程也好、RxJava 也好，都有全局处理异常的方式，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler &#123;t: Thread, e: Throwable -&gt;</span><br><span class="line">        <span class="comment">//handle exception here</span></span><br><span class="line">        println(<span class="string">"Thread '<span class="subst">$&#123;t.name&#125;</span>' throws an exception with message '<span class="subst">$&#123;e.message&#125;</span>'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> ArithmeticException(<span class="string">"Hey!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以为线程设置全局的异常捕获，当然也可以为 RxJava 来设置全局异常捕获：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RxJavaPlugins.setErrorHandler(e -&gt; &#123;</span><br><span class="line">        <span class="comment">//handle exception here</span></span><br><span class="line">        println(<span class="string">"Throws an exception with message '<span class="subst">$&#123;e.message&#125;</span>'"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>协程显然也可以做到这一点。类似于通过 <code>Thread.setUncaughtExceptionHandler</code> 为线程设置一个异常捕获器，我们也可以为每一个协程单独设置 <code>CoroutineExceptionHandler</code>，这样协程内部未捕获的异常就可以通过它来捕获：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        log(<span class="string">"Throws an exception with message: <span class="subst">$&#123;throwable.message&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    GlobalScope.launch(exceptionHandler) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException(<span class="string">"Hey!"</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">19:06:35:087 [main] 1</span><br><span class="line">19:06:35:208 [DefaultDispatcher-worker-1 @coroutine#1] Throws an exception with message: Hey!</span><br><span class="line">19:06:35:211 [DefaultDispatcher-worker-1 @coroutine#1] 2</span><br></pre></td></tr></table></figure><p><code>CoroutineExceptionHandler</code> 竟然也是一个上下文，协程的这个上下文可真是灵魂一般的存在，这倒是一点儿也不让人感到意外。</p><p>当然，这并不算是一个全局的异常捕获，因为它只能捕获对应协程内未捕获的异常，如果你想做到真正的全局捕获，在 Jvm 上我们可以自己定义一个捕获类实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalCoroutineExceptionHandler</span>: <span class="type">CoroutineExceptionHandler &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptionHandler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleException</span><span class="params">(context: <span class="type">CoroutineContext</span>, exception: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Coroutine exception: <span class="variable">$exception</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 classpath 中创建 META-INF/services/kotlinx.coroutines.CoroutineExceptionHandler，文件名实际上就是 <code>CoroutineExceptionHandler</code> 的全类名，文件内容就写我们的实现类的全类名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.bennyhuo.coroutines.sample2.exceptions.GlobalCoroutineExceptionHandler</span><br></pre></td></tr></table></figure><p>这样协程中没有被捕获的异常就会最终交给它处理。</p><blockquote><p>Jvm 上全局 <code>CoroutineExceptionHandler</code> 的配置，本质上是对 <code>ServiceLoader</code> 的应用，之前我们在讲 <code>Dispatchers.Main</code> 的时候提到过，Jvm 上它的实现也是通过 <code>ServiceLoader</code> 来加载的。</p></blockquote><p>需要明确的一点是，通过 <code>async</code> 启动的协程出现未捕获的异常时会忽略 <code>CoroutineExceptionHandler</code>，这与 <code>launch</code> 的设计思路是不同的。</p><h2 id="4-异常传播"><a href="#4-异常传播" class="headerlink" title="4. 异常传播"></a>4. 异常传播</h2><p>异常传播还涉及到协程作用域的概念，例如我们启动协程的时候一直都是用的 <code>GlobalScope</code>，意味着这是一个独立的顶级协程作用域，此外还有 <code>coroutineScope { ... }</code> 以及 <code>supervisorScope { ... }</code>。</p><ul><li>通过 GlobeScope 启动的协程单独启动一个协程作用域，内部的子协程遵从默认的作用域规则。通过 GlobeScope 启动的协程“自成一派”。</li><li>coroutineScope 是继承外部 Job 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常也会向上传递给父协程。它更适合一系列对等的协程并发的完成一项工作，任何一个子协程异常退出，那么整体都将退出，简单来说就是”一损俱损“。这也是协程内部再启动子协程的默认作用域。</li><li>supervisorScope 同样继承外部作用域的上下文，但其内部的取消操作是单向传播的，父协程向子协程传播，反过来则不然，这意味着子协程出了异常并不会影响父协程以及其他兄弟协程。它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，简单来说就是”自作自受“，例如 UI，我点击一个按钮出了异常，其实并不会影响手机状态栏的刷新。需要注意的是，supervisorScope 内部启动的子协程内部再启动子协程，如无明确指出，则遵守默认作用域规则，也即 supervisorScope 只作用域其直接子协程。</li></ul><p>这么说还是比较抽象，因此我们拿一些例子来分析一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        coroutineScope &#123; <span class="comment">//①</span></span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            launch &#123; <span class="comment">// ②</span></span><br><span class="line">                log(<span class="number">3</span>)</span><br><span class="line">                launch &#123; <span class="comment">// ③ </span></span><br><span class="line">                    log(<span class="number">4</span>)</span><br><span class="line">                    delay(<span class="number">100</span>)</span><br><span class="line">                    <span class="keyword">throw</span> ArithmeticException(<span class="string">"Hey!!"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="number">5</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            log(<span class="number">6</span>)</span><br><span class="line">            <span class="keyword">val</span> job = launch &#123; <span class="comment">// ④</span></span><br><span class="line">                log(<span class="number">7</span>)</span><br><span class="line">                delay(<span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="number">8</span>)</span><br><span class="line">                 job.join()</span><br><span class="line">                log(<span class="string">"9"</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                log(<span class="string">"10. <span class="variable">$e</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="number">11</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">"12. <span class="variable">$e</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">13</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这例子稍微有点儿复杂，但也不难理解，我们在一个 <code>coroutineScope</code> 当中启动了两个协程 ②④，在 ② 当中启动了一个子协程 ③，作用域直接创建的协程记为①。那么 ③ 当中抛异常会发生什么呢？我们先来看下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">11:37:36:208 [main] 1</span><br><span class="line">11:37:36:255 [main] 2</span><br><span class="line">11:37:36:325 [DefaultDispatcher-worker-1] 3</span><br><span class="line">11:37:36:325 [DefaultDispatcher-worker-1] 5</span><br><span class="line">11:37:36:326 [DefaultDispatcher-worker-3] 4</span><br><span class="line">11:37:36:331 [main] 6</span><br><span class="line">11:37:36:336 [DefaultDispatcher-worker-1] 7</span><br><span class="line">11:37:36:336 [main] 8</span><br><span class="line">11:37:36:441 [DefaultDispatcher-worker-1] 10. kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job&#x3D;ScopeCoroutine&#123;Cancelling&#125;@2bc92d2f</span><br><span class="line">11:37:36:445 [DefaultDispatcher-worker-1] 12. java.lang.ArithmeticException: Hey!!</span><br><span class="line">11:37:36:445 [DefaultDispatcher-worker-1] 13</span><br></pre></td></tr></table></figure><p>注意两个位置，一个是 10，我们调用 <code>join</code>，收到了一个取消异常，在协程当中支持取消的操作的suspend方法在取消时会抛出一个 <code>CancellationException</code>，这类似于线程中对 <code>InterruptException</code> 的响应，遇到这种情况表示 <code>join</code> 调用所在的协程已经被取消了，那么这个取消究竟是怎么回事呢？</p><p>原来协程 ③ 抛出了未捕获的异常，进入了异常完成的状态，它与父协程 ② 之间遵循默认的作用域规则，因此 ③ 会通知它的父协程也就是 ② 取消，② 根据作用域规则通知父协程 ① 也就是整个作用域取消，这是一个自下而上的一次传播，这样身处 ① 当中的 <code>job.join</code> 调用就会抛异常，也就是 10 处的结果了。如果不是很理解这个操作，想一下我们说到的，<code>coroutineScope</code> 内部启动的协程就是“一损俱损”。实际上由于父协程 ① 被取消，协程④ 也不能幸免，如果大家有兴趣的话，也可以对 ④ 当中的 <code>delay</code>进行捕获，一样会收获一枚取消异常。</p><p>还有一个位置就是 12，这个是我们对 <code>coroutineScope</code> 整体的一个捕获，如果 <code>coroutineScope</code> 内部以为异常而结束，那么我们是可以对它直接 <code>try ... catch ...</code> 来捕获这个异常的，这再一次表明协程把异步的异常处理到同步代码逻辑当中。</p><p>那么如果我们把 <code>coroutineScope</code> 换成 <code>supervisorScope</code>，其他不变，运行结果会是怎样呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">11:52:48:632 [main] 1</span><br><span class="line">11:52:48:694 [main] 2</span><br><span class="line">11:52:48:875 [main] 6</span><br><span class="line">11:52:48:892 [DefaultDispatcher-worker-1 @coroutine#1] 3</span><br><span class="line">11:52:48:895 [DefaultDispatcher-worker-1 @coroutine#1] 5</span><br><span class="line">11:52:48:900 [DefaultDispatcher-worker-3 @coroutine#3] 4</span><br><span class="line">11:52:48:905 [DefaultDispatcher-worker-2 @coroutine#2] 7</span><br><span class="line">11:52:48:907 [main] 8</span><br><span class="line">Exception in thread &quot;DefaultDispatcher-worker-3 @coroutine#3&quot; java.lang.ArithmeticException: Hey!!</span><br><span class="line">at com.bennyhuo.coroutines.sample2.exceptions.ScopesKt$main$2$1$1.invokeSuspend(Scopes.kt:17)</span><br><span class="line">at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)</span><br><span class="line">at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:238)</span><br><span class="line">at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)</span><br><span class="line">at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)</span><br><span class="line">at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)</span><br><span class="line">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 9</span><br><span class="line">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 11</span><br><span class="line">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 13</span><br></pre></td></tr></table></figure><p>我们可以看到，1-8 的输出其实没有本质区别，顺序上的差异是线程调度的前后造成的，并不会影响协程的语义。差别主要在于 9 与 10、11与12的区别，如果把 scope 换成 <code>supervisorScope</code>，我们发现 ③ 的异常并没有影响作用域以及作用域内的其他子协程的执行，也就是我们所说的“自作自受”。</p><p>这个例子其实我们再稍做一些改动，为 ② 和 ③ 增加一个 <code>CoroutineExceptionHandler</code>，就可以证明我们前面提到的另外一个结论：</p><p>首先我们定义一个 <code>CoroutineExceptionHandler</code>，我们通过上下文获取一下异常对应的协程的名字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">    log(<span class="string">"<span class="subst">$&#123;coroutineContext[CoroutineName]&#125;</span> <span class="variable">$throwable</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，基于前面的例子我们为 ② 和 ③ 添加 <code>CoroutineExceptionHandler</code> 和名字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">supervisorScope &#123; <span class="comment">//①</span></span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    launch(exceptionHandler + CoroutineName(<span class="string">"②"</span>)) &#123; <span class="comment">// ②</span></span><br><span class="line">        log(<span class="number">3</span>)</span><br><span class="line">        launch(exceptionHandler + CoroutineName(<span class="string">"③"</span>)) &#123; <span class="comment">// ③</span></span><br><span class="line">            log(<span class="number">4</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再运行这段程序，结果就比较有意思了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">07:30:11:519 [DefaultDispatcher-worker-1] CoroutineName(②) java.lang.ArithmeticException: Hey!!</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们发现触发的 <code>CoroutineExceptionHandler</code> 竟然是协程 ② 的，意外吗？不意外，因为我们前面已经提到，对于 <code>supervisorScope</code> 的子协程 （例如 ②）的子协程（例如 ③），如果没有明确指出，它是遵循默认的作用于规则的，也就是 <code>coroutineScope</code> 的规则了，出现未捕获的异常会尝试传递给父协程并尝试取消父协程。</p><p>究竟使用什么 Scope，大家自己根据实际情况来确定，我给出一些建议：</p><ul><li>对于没有协程作用域，但需要启动协程的时候，适合用 GlobalScope</li><li>对于已经有协程作用域的情况（例如通过 GlobalScope 启动的协程体内），直接用协程启动器启动</li><li>对于明确要求子协程之间相互独立不干扰时，使用 supervisorScope</li><li>对于通过标准库 API 创建的协程，这样的协程比较底层，没有 Job、作用域等概念的支撑，例如我们前面提到过 suspend main 就是这种情况，对于这种情况优先考虑通过 coroutineScope 创建作用域；更进一步，大家尽量不要直接使用标准库 API，除非你对 Kotlin 的协程机制非常熟悉。</li></ul><p>当然，对于可能出异常的情况，请大家尽量做好异常处理，不要将问题复杂化。</p><h3 id="5-join-和-await"><a href="#5-join-和-await" class="headerlink" title="5. join 和 await"></a>5. join 和 await</h3><p>前面我们举例子一直用的是 <code>launch</code>，启动协程其实常用的还有 <code>async</code>、<code>actor</code> 和 <code>produce</code>，其中 <code>actor</code> 和 <code>launch</code> 的行为类似，在未捕获的异常出现以后，会被当做为处理的异常抛出，就像前面的例子那样。而 <code>async</code> 和 <code>produce</code> 则主要是用来输出结果的，他们内部的异常只在外部消费他们的结果时抛出。这两组协程的启动器，你也可以认为分别是“消费者”和“生产者”，消费者异常立即抛出，生产者只有结果消费时抛出异常。</p><blockquote><p><code>actor</code> 和 <code>produce</code> 这两个 API 目前处于比较微妙的境地，可能会被废弃或者后续提供替代方案，不建议大家使用，我们在这里就不展开细讲了。</p></blockquote><p>那么消费结果指的是什么呢？对于 <code>async</code> 来讲，就是 <code>await</code>，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = GlobalScope.async&lt;<span class="built_in">Int</span>&gt; &#123; </span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> value = deferred.await()</span><br><span class="line">        log(<span class="string">"1. <span class="variable">$value</span>"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">"2. <span class="variable">$e</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个从逻辑上很好理解，我们调用 <code>await</code> 时，期望 <code>deferred</code> 能够给我们提供一个合适的结果，但它因为出异常，没有办法做到这一点，因此只好给我们丢出一个异常了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13:25:14:693 [main] 2. java.lang.ArithmeticException</span><br></pre></td></tr></table></figure><p>我们自己实现的 <code>getUserCoroutine</code> 也属于类似的情况，在获取结果时，如果请求出了异常，我们就只能拿到一个异常，而不是正常的结果。相比之下，<code>join</code> 就有趣的多了，它只关注是否执行完，至于是因为什么完成，它不关心，因此如果我们在这里替换成 <code>join</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = GlobalScope.async&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred.join()</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">"2. <span class="variable">$e</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就会发现，异常被吞掉了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13:26:15:034 [main] 1</span><br></pre></td></tr></table></figure><p>如果例子当中我们用 <code>launch</code> 替换 <code>async</code>，<code>join</code> 处仍然不会有任何异常抛出，还是那句话，它只关心有没有完成，至于怎么完成的它不关心。不同之处在于， <code>launch</code> 中未捕获的异常与 <code>async</code> 的处理方式不同，<code>launch</code> 会直接抛出给父协程，如果没有父协程（顶级作用域中）或者处于 <code>supervisorScope</code> 中父协程不响应，那么就交给上下文中指定的 <code>CoroutineExceptionHandler</code>处理，如果没有指定，那传给全局的 <code>CoroutineExceptionHandler</code> 等等，而 <code>async</code> 则要等 <code>await</code> 来消费。</p><blockquote><p>不管是哪个启动器，在应用了作用域之后，都会按照作用域的语义进行异常扩散，进而触发相应的取消操作，对于 <code>async</code> 来说就算不调用 <code>await</code> 来获取这个异常，它也会在 <code>coroutineScope</code> 当中触发父协程的取消逻辑，这一点请大家注意。</p></blockquote><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><p>这一篇我们讲了协程的异常处理。这一块儿稍微显得有点儿复杂，但仔细理一下主要有三条线：</p><ol><li><strong>协程内部异常处理流程</strong>：launch 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看作用域的定义，如果取消成功，那么异常传递给父协程，否则传递给启动时上下文中配置的 CoroutineExceptionHandler 中，如果没有配置，会查找全局（JVM上）的 CoroutineExceptionHandler 进行处理，如果仍然没有，那么就将异常交给当前线程的 UncaughtExceptionHandler 处理；而 async 则在未捕获的异常出现时同样会尝试取消父协程，但不管是否能够取消成功都不会后其他后续的异常处理，直到用户主动调用 await 时将异常抛出。</li><li><strong>异常在作用域内的传播</strong>：当协程出现异常时，会根据当前作用域触发异常传递，GlobalScope 会创建一个独立的作用域，所谓“自成一派”，而 在 coroutineScope 当中协程异常会触发父协程的取消，进而将整个协程作用域取消掉，如果对 coroutineScope 整体进行捕获，也可以捕获到该异常，所谓“一损俱损”；如果是 supervisorScope，那么子协程的异常不会向上传递，所谓“自作自受”。</li><li><strong>join 和 await 的不同</strong>：join 只关心协程是否执行完，await 则关心运行的结果，因此 join 在协程出现异常时也不会抛出该异常，而 await 则会；考虑到作用域的问题，如果协程抛异常，可能会导致父协程的取消，因此调用 join 时尽管不会对协程本身的异常进行抛出，但如果 join 调用所在的协程被取消，那么它会抛出取消异常，这一点需要留意。</li></ol><p>如果大家能把这三点理解清楚了，那么协程的异常处理可以说就非常清晰了。文中因为异常传播的原因，我们提到了取消，但没有展开详细讨论，后面我们将会专门针对取消输出一篇文章，帮助大家加深理解。</p><h3 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h3><p>join 在父协程被取消时有一个 bug 会导致不抛出取消异常，我在准备本文时发现该问题，目前已经提交到官方并得到了修复，预计合入到 1.2.1 发版，大家有兴趣可以查看这个 issue：<a href="https://github.com/Kotlin/kotlinx.coroutines/issues/1123" target="_blank" rel="noopener">No CancellationException thrown when join on a crashed Job</a>。</p><p>当然，这个 bug 对于生成环境的影响很小，大家也不要担心。</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;异步代码的异常处理通常都比较让人头疼，而协程则再一次展现了它的威力。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(3) - 协程调度篇</title>
    <link href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/"/>
    <id>https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/</id>
    <published>2019-04-10T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一篇我们知道了协程启动的几种模式，也通过示例认识了 <code>launch</code> 启动协程的使用方法，本文将延续这些内容从调度的角度来进一步为大家揭示协程的奥义。</p></blockquote><a id="more"></a><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15550227714805.jpg" alt=""></p><h2 id="1-协程上下文"><a href="#1-协程上下文" class="headerlink" title="1. 协程上下文"></a>1. 协程上下文</h2><p>调度器本质上就是一个协程上下文的实现，我们先来介绍下上下文。</p><p>前面我们提到 <code>launch</code> 函数有三个参数，第一个参数叫 <strong>上下文</strong>，它的接口类型是 <code>CoroutineContext</code>，通常我们见到的上下文的类型是 <code>CombinedContext</code> 或者 <code>EmptyCoroutineContext</code>，一个表示上下文的组合，另一个表示什么都没有。我们来看下 <code>CoroutineContext</code> 的接口方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.3"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext = ...</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Key</span>&lt;<span class="type">E : Element</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext &#123;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道大家有没有发现，它简直就是一个以 <code>Key</code> 为索引的 <code>List</code>：</p><table><thead><tr><th>CoroutineContext</th><th>List</th></tr></thead><tbody><tr><td>get(Key)</td><td>get(Int)</td></tr><tr><td>plus(CoroutineContext)</td><td>plus(List)</td></tr><tr><td>minusKey(Key)</td><td>removeAt(Int)</td></tr></tbody></table><blockquote><p>表中的 <code>List.plus(List)</code> 实际上指的是扩展方法 <code>Collection&lt;T&gt;.plus(elements: Iterable&lt;T&gt;): List&lt;T&gt;</code></p></blockquote><p><code>CoroutineContext</code> 作为一个集合，它的元素就是源码中看到的 <code>Element</code>，每一个 <code>Element</code> 都有一个 <code>key</code>，因此它可以作为元素出现，同时它也是 <code>CoroutineContext</code> 的子接口，因此也可以作为集合出现。</p><p>讲到这里，大家就会明白，<code>CoroutineContext</code> 原来是个数据结构啊。如果大家对于 <code>List</code> 的递归定义比较熟悉的话，那么对于 <code>CombinedContext</code> 和 <code>EmptyCoroutineContext</code> 也就很容易理解了，例如 scala 的 <code>List</code>是这么定义的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>[+<span class="type">A</span>] <span class="keyword">extends</span> ... </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">List</span>[<span class="type">A</span>]</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模式匹配的时候，<code>List(1,2,3,4)</code> 是可以匹配 <code>x::y</code> 的，<code>x</code> 就是 1，<code>y</code> 则是 <code>List(2,3,4)</code>。</p><p><code>CombinedContext</code> 的定义也非常类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedContext</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> left: CoroutineContext,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> element: Element</span><br><span class="line">) : CoroutineContext, Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过它是反过来的，前面是集合，后面是单独的一个元素。我们在协程体里面访问到的 <code>coroutineContext</code> 大多是这个 <code>CombinedContext</code> 类型，表示有很多具体的上下文实现的集合，我们如果想要找到某一个特别的上下文实现，就需要用对应的 <code>Key</code> 来查找，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(coroutineContext[Job]) <span class="comment">// "coroutine#1":StandaloneCoroutine&#123;Active&#125;@1ff62014</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(coroutineContext[Job]) <span class="comment">// null，suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>Job</code> 实际上是对它的 <code>companion object</code> 的引用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Job</span> : <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Key for [Job] instance in the coroutine context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt; &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以我们也可以仿照 <code>Thread.currentThread()</code> 来一个获取当前 <code>Job</code> 的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> Job.Key.<span class="title">currentJob</span><span class="params">()</span></span> = coroutineContext[Job]</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">coroutineJob</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        log(Job.currentJob())</span><br><span class="line">    &#125;</span><br><span class="line">    log(Job.currentJob())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>我们可以通过指定上下文为协程添加一些特性，一个很好的例子就是为协程添加名称，方便调试：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(CoroutineName(<span class="string">"Hello"</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个上下文需要添加，直接用 <code>+</code> 就可以了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main + CoroutineName(<span class="string">"Hello"</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Dispatchers.Main</code> 是调度器的一个实现，不用担心，我们很快就会认识它了。</p></blockquote><h2 id="2-协程拦截器"><a href="#2-协程拦截器" class="headerlink" title="2. 协程拦截器"></a>2. 协程拦截器</h2><p>费了好大劲儿说完上下文，这里就要说一个比较特殊的存在了——拦截器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器也是一个上下文的实现方向，拦截器可以左右你的协程的执行，同时为了保证它的功能的正确性，协程上下文集合永远将它放在最后面，这真可谓是天选之子了。</p><p>它拦截协程的方法也很简单，因为协程的本质就是回调 + “黑魔法”，而这个回调就是被拦截的 <code>Continuation</code> 了。用过 OkHttp 的小伙伴一下就兴奋了，拦截器我常用的啊，OkHttp 用拦截器做缓存，打日志，还可以模拟请求，协程拦截器也是一样的道理。调度器就是基于拦截器实现的，换句话说调度器就是拦截器的一种。</p><p>我们可以自己定义一个拦截器放到我们的协程上下文中，看看会发生什么。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContinuationInterceptor</span>: <span class="type">ContinuationInterceptor&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key = ContinuationInterceptor</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span> = MyContinuation(continuation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContinuation</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = continuation.context</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        log(<span class="string">"&lt;MyContinuation&gt; <span class="variable">$result</span>"</span> )</span><br><span class="line">        continuation.resumeWith(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只是在回调处打了一行日志。接下来我们把用例拿出来：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch(MyContinuationInterceptor()) &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> job = async &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">3</span>)</span><br><span class="line">            <span class="string">"Hello"</span></span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> result = job.await()</span><br><span class="line">        log(<span class="string">"5. <span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可能是迄今而止我们给出的最复杂的例子了，不过请大家不要被它吓到，它依然很简单。我们通过 <code>launch</code> 启动了一个协程，为它指定了我们自己的拦截器作为上下文，紧接着在其中用 <code>async</code> 启动了一个协程，<code>async</code> 与 <code>launch</code> 从功能上是同等类型的函数，它们都被称作协程的 Builder 函数，不同之处在于 <code>async</code> 启动的 <code>Job</code> 也就是实际上的 <code>Deferred</code> 可以有返回结果，可以通过 <code>await</code> 方法获取。</p><p>可想而知，<code>result</code> 的值就是 Hello。那么这段程序运行的结果如何呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">15:31:55:989 [main] &lt;MyContinuation&gt; Success(kotlin.Unit)  &#x2F;&#x2F; ①</span><br><span class="line">15:31:55:992 [main] 1</span><br><span class="line">15:31:56:000 [main] &lt;MyContinuation&gt; Success(kotlin.Unit) &#x2F;&#x2F; ②</span><br><span class="line">15:31:56:000 [main] 2</span><br><span class="line">15:31:56:031 [main] 4</span><br><span class="line">15:31:57:029 [kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(kotlin.Unit) &#x2F;&#x2F; ③</span><br><span class="line">15:31:57:029 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class="line">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(Hello) &#x2F;&#x2F; ④</span><br><span class="line">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 5. Hello</span><br><span class="line">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 6</span><br></pre></td></tr></table></figure><blockquote><p>“// ①” 不是程序输出的内容，仅为后续讲解方便而做的标注。</p></blockquote><p>大家可能就要奇怪了，你不是说 <code>Continuation</code> 是回调么，这里面回调调用也就一次啊（<code>await</code> 那里），怎么日志打印了四次呢？</p><p>别慌，我们按顺序给大家介绍。</p><p>首先，所有协程启动的时候，都会有一次 <code>Continuation.resumeWith</code> 的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于此。 ①、② 两处都是这种情况。</p><p>其次，<code>delay</code> 是挂起点，1000ms 之后需要继续调度执行该协程，因此就有了 ③ 处的日志。</p><p>最后，④ 处的日志就很容易理解了，正是我们的返回结果。</p><p>可能有朋友还会有疑问，我并没有在拦截器当中切换线程，为什么从 ③ 处开始有了线程切换的操作？这个切换线程的逻辑源自于 <code>delay</code>，在 JVM 上 <code>delay</code> 实际上是在一个 <code>ScheduledExcecutor</code> 里面添加了一个延时任务，因此会发生线程切换；而在 JavaScript 环境中则是基于 setTimeout，如果运行在 Nodejs 上，<code>delay</code> 就不会切线程了，毕竟人家是单线程的。</p><p>如果我们在拦截器当中自己处理了线程切换，那么就实现了自己的一个简单的调度器，大家有兴趣可以自己去尝试。</p><blockquote><p>思考：拦截器可以有多个吗？</p></blockquote><h2 id="3-调度器"><a href="#3-调度器" class="headerlink" title="3. 调度器"></a>3. 调度器</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>有了前面的基础，我们对于调度器的介绍就变得水到渠成了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineDispatcher</span> :<span class="type"></span></span></span><br><span class="line">    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它本身是协程上下文的子类，同时实现了拦截器的接口， <code>dispatch</code> 方法会在拦截器的方法 <code>interceptContinuation</code> 中调用，进而实现协程的调度。所以如果我们想要实现自己的调度器，继承这个类就可以了，不过通常我们都用现成的，它们定义在 <code>Dispatchers</code> 当中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Default: CoroutineDispatcher</span><br><span class="line"><span class="keyword">val</span> Main: MainCoroutineDispatcher</span><br><span class="line"><span class="keyword">val</span> Unconfined: CoroutineDispatcher</span><br></pre></td></tr></table></figure><p>这个类的定义涉及到了 Kotlin MPP 的支持，因此你在 Jvm 版本当中还会看到 <code>val IO: CoroutineDispatcher</code>，在 js 和 native 当中就只有前面提到的这三个了（对 Jvm 好偏心呐）。</p><table><thead><tr><th></th><th>Jvm</th><th>Js</th><th>Native</th></tr></thead><tbody><tr><td>Default</td><td>线程池</td><td>主线程循环</td><td>主线程循环</td></tr><tr><td>Main</td><td>UI 线程</td><td>与 Default 相同</td><td>与 Default 相同</td></tr><tr><td>Unconfined</td><td>直接执行</td><td>直接执行</td><td>直接执行</td></tr><tr><td>IO</td><td>线程池</td><td>–</td><td>–</td></tr></tbody></table><ul><li>IO 仅在 Jvm 上有定义，它基于 Default 调度器背后的线程池，并实现了独立的队列和限制，因此协程调度器从 Default 切换到 IO 并不会触发线程切换。</li><li>Main 主要用于 UI 相关程序，在 Jvm 上包括 Swing、JavaFx、Android，可将协程调度到各自的 UI 线程上。</li><li>Js 本身就是单线程的事件循环，与 Jvm 上的 UI 程序比较类似。</li></ul><h3 id="3-2-编写-UI-相关程序"><a href="#3-2-编写-UI-相关程序" class="headerlink" title="3.2 编写 UI 相关程序"></a>3.2 编写 UI 相关程序</h3><p>Kotlin 的用户绝大多数都是 Android 开发者，大家对 UI 的开发需求还是比较大的。我们举一个很常见的场景，点击一个按钮做点儿异步的操作再回调刷新 UI：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getUserBtn.setOnClickListener &#123; </span><br><span class="line">    getUser &#123; user -&gt;</span><br><span class="line">        handler.post &#123;</span><br><span class="line">            userNameView.text = user.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单得给出 <code>getUser</code> 函数的声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Callback = (User) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(callback: <span class="type">Callback</span>)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>getUser</code> 函数需要切到其他线程执行，因此回调通常也会在这个非 UI 的线程中调用，所以为了确保 UI 正确被刷新，我们需要用 <code>handler.post</code> 切换到 UI 线程。上面的写法就是我们最古老的写法了。</p><p>后来又有了 RxJava，那么事情开始变得有趣了起来：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserObservable</span><span class="params">()</span></span>: Observable&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create&lt;User&gt; &#123; emitter -&gt;</span><br><span class="line">        getUser &#123;</span><br><span class="line">            emitter.onNext(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是点击按钮的事件可以这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getUserBtn.setOnClickListener &#123;</span><br><span class="line">    getUserObservable()</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe &#123; user -&gt;</span><br><span class="line">                userNameView.text = user.name</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 RxJava 在线程切换上的表现是非常优秀的，也正是如此，很多人甚至用它只是为了切线程方便！</p><p>那么我们现在把这段代码过渡到协程的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    getUser &#123;</span><br><span class="line">        continuation.resume(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按钮点击时，我们可以：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserBtn.setOnClickListener &#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        userNameView.text = getUserCoroutine().name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>大家也可以用 anko-coroutines 当中的 View.onClick 扩展，这样我们就无需自己在这里用 <code>launch</code> 启动协程了。有关 Anko 对协程的支持，我们后面专门安排一篇文章介绍。</p></blockquote><p>这里又有大家没见过的内容啦，<code>suspendCoroutine</code> 这个方法并不是帮我们启动协程的，它运行在协程当中并且帮我们获取到当前协程的 <code>Continuation</code> 实例，也就是拿到回调，方便后面我们调用它的 <code>resume</code> 或者 <code>resumeWithException</code> 来返回结果或者抛出异常。</p><blockquote><p>如果你重复调用 <code>resume</code> 或者 <code>resumeWithException</code> 会收获一枚 <code>IllegalStateException</code>，仔细想想这是为什么。</p></blockquote><p>对比前面的 RxJava 的做法，你会发现这段代码其实很容易理解，你甚至会发现协程的使用场景与 RxJava 竟是如此的相似。这里我们用到了 <code>Dispatchers.Main</code> 来确保 <code>launch</code> 启动的协程在调度时始终调度到 UI 线程，那么下面我们来看看 <code>Dispatchers.Main</code> 的具体实现。</p><p>在 Jvm 上，<code>Main</code> 的实现也比较有意思：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> MainDispatcherLoader &#123;</span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">val</span> dispatcher: MainCoroutineDispatcher = loadMainDispatcher()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadMainDispatcher</span><span class="params">()</span></span>: MainCoroutineDispatcher &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> factories = MainDispatcherFactory::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">let</span> </span>&#123; clz -&gt;</span><br><span class="line">                ServiceLoader.load(clz, clz.classLoader).toList()</span><br><span class="line">            &#125;</span><br><span class="line">            factories.maxBy &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)</span><br><span class="line">                ?: MissingMainCoroutineDispatcher(<span class="literal">null</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">            MissingMainCoroutineDispatcher(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android 当中，协程框架通过注册 <code>AndroidDispatcherFactory</code> 使得 <code>Main</code> 最终被赋值为 <code>HandlerDispatcher</code> 的实例，有兴趣的可以去看下 kotlinx-coroutines-android 的源码实现。</p><blockquote><p>注意前面对于 RxJava 和协程的实现，我们都没有考虑异常和取消的问题。有关异常和取消的话题，我们会在后面的文章中详细介绍。</p></blockquote><h3 id="3-3-绑定到任意线程的调度器"><a href="#3-3-绑定到任意线程的调度器" class="headerlink" title="3.3 绑定到任意线程的调度器"></a>3.3 绑定到任意线程的调度器</h3><p>调度器的目的就是切线程，你不要想着我在 <code>dispatch</code> 的时候根据自己的心情来随机调用，那你是在害你自己（不怕各位笑话，这样的代码我还真写过，仅供娱乐）。那么问题就简单了，我们只要提供线程，调度器就应该很方便的创建出来：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> myDispatcher= Executors.newSingleThreadExecutor&#123; r -&gt; Thread(r, <span class="string">"MyThread"</span>) &#125;.asCoroutineDispatcher()</span><br><span class="line">    GlobalScope.launch(myDispatcher) &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的信息就表明协程运行在我们自己的线程上。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">10</span>:<span class="number">57</span>:<span class="number">130</span> [MyThread] <span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">10</span>:<span class="number">57</span>:<span class="number">136</span> [MyThread] <span class="number">2</span></span><br></pre></td></tr></table></figure><p>不过请大家注意，由于这个线程池是我们自己创建的，因此我们需要在合适的时候关闭它，不然的话：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546248040111.jpg" alt=""></p><p>我们可以通过主动关闭线程池或者调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myDispatcher.close()</span><br></pre></td></tr></table></figure><p>来结束它的生命周期，再次运行程序就会正常退出了。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546249279403.jpg" alt=""></p><p>当然有人会说你创建的线程池的线程不是 daemon 的，所以主线程结束时 Jvm 不会停止运行。说的没错，但该释放的还是要及时释放，如果你只是在程序的整个生命周期当中短暂的用了一下这个调度器，那么一直不关闭它对应的线程池岂不是会有线程泄露吗？这就很尴尬了。</p><p>Kotlin 协程设计者也特别害怕大家注意不到这一点，还特地废弃了两个 API 并且开了一个 issue 说我们要重做这套 API，这两个可怜的家伙是谁呢？</p><p><strong>废弃的两个基于线程池创建调度器的 API</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newSingleThreadContext</span><span class="params">(name: <span class="type">String</span>)</span></span>: ExecutorCoroutineDispatcher</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newFixedThreadPoolContext</span><span class="params">(nThreads: <span class="type">Int</span>, name: <span class="type">String</span>)</span></span>: ExecutorCoroutineDispatcher</span><br></pre></td></tr></table></figure><p>这二者可以很方便的创建绑定到特定线程的调度器，但过于简洁的 API 似乎会让人忘记它的风险。Kotlin 一向不爱做这种不清不楚的事儿，所以您呢，还是像我们这一节例子当中那样自己去构造线程池吧，这样好歹自己忘了关闭也怨不着别人（哈哈哈）。</p><p>其实在多个线程上运行协程，线程总是这样切来切去其实并不会显得很轻量级，例如下面的例子就是比较可怕的了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="number">10</span>)</span><br><span class="line">        .asCoroutineDispatcher().use &#123; dispatcher -&gt;</span><br><span class="line">            GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">                log(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> job = async &#123;</span><br><span class="line">                    log(<span class="number">2</span>)</span><br><span class="line">                    delay(<span class="number">1000</span>)</span><br><span class="line">                    log(<span class="number">3</span>)</span><br><span class="line">                    <span class="string">"Hello"</span></span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="number">4</span>)</span><br><span class="line">                <span class="keyword">val</span> result = job.await()</span><br><span class="line">                log(<span class="string">"5. <span class="variable">$result</span>"</span>)</span><br><span class="line">            &#125;.join()</span><br><span class="line">            log(<span class="number">6</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里面除了 <code>delay</code> 那里有一次不可避免的线程切换外，其他几处协程挂起点的继续操作（<code>Continuation.resume</code>）都会切线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">16:28:04:771 [pool-1-thread-1] 1</span><br><span class="line">16:28:04:779 [pool-1-thread-1] 4</span><br><span class="line">16:28:04:779 [pool-1-thread-2] 2</span><br><span class="line">16:28:05:790 [pool-1-thread-3] 3</span><br><span class="line">16:28:05:793 [pool-1-thread-4] 5. Hello</span><br><span class="line">16:28:05:794 [pool-1-thread-4] 6</span><br></pre></td></tr></table></figure><p>如果我们的线程池只开 1 个线程，那么这里所有的输出都将在这唯一的线程中打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">16:40:14:685 [pool-1-thread-1] 1</span><br><span class="line">16:40:14:706 [pool-1-thread-1] 4</span><br><span class="line">16:40:14:710 [pool-1-thread-1] 2</span><br><span class="line">16:40:15:723 [pool-1-thread-1] 3</span><br><span class="line">16:40:15:725 [pool-1-thread-1] 5. Hello</span><br><span class="line">16:40:15:725 [pool-1-thread-1] 6</span><br></pre></td></tr></table></figure><p>对比这二者，10个线程的情况线程切换次数最少 3次，而 1 个线程的情况则只要 <code>delay</code> 1000ms 之后恢复执行的时候那一次。只是多两次线程切换，到底会有多大影响呢？我在我自己的 2015 款 mbp 上对于两种不同的情况分别循环运行 100 次，得到的平均时间如下：</p><table><thead><tr><th>线程数</th><th>10</th><th>1</th></tr></thead><tbody><tr><td>耗时ms</td><td>1006.00</td><td>1004.97</td></tr></tbody></table><blockquote><p>注意，为了测试的公平性，在运行 100 次循环之前已经做好了预热，确保所有类都已经加载。测试结果仅供参考。</p></blockquote><p>也就是说多两次线程切换平均能多出 1ms 的耗时。生产环境当中的代码当然会更复杂，如果这样用线程池去调度，结果可想而知。</p><p>实际上通常我们只需要在一个线程当中处理自己的业务逻辑，只有一些耗时的 IO 才需要切换到 IO 线程中处理，所以好的做法可以参考 UI 对应的调度器，自己通过线程池定义调度器的做法本身没什么问题，但最好只用一个线程，因为多线程除了前面说的线程切换的开销外，还有线程安全的问题。</p><h3 id="3-4-线程安全问题"><a href="#3-4-线程安全问题" class="headerlink" title="3.4 线程安全问题"></a>3.4 线程安全问题</h3><p>Js 和 Native 的并发模型与 Jvm 不同，Jvm 暴露了线程 API 给用户，这也使得协程的调度可以由用户更灵活的选择。越多的自由，意味着越多的代价，我们在 Jvm 上面编写协程代码时需要明白一点的是，线程安全问题在调度器不同的协程之间仍然存在。</p><p>好的做法，就像我们前面一节提到的，尽量把自己的逻辑控制在一个线程之内，这样一方面节省了线程切换的开销，另一方面还可以避免线程安全问题，两全其美。</p><p>如果大家在协程代码中使用锁之类的并发工具就反而增加了代码的复杂度，对此我的建议是大家在编写协程代码时尽量避免对外部作用域的可变变量进行引用，尽量使用参数传递而非对全局变量进行引用。</p><p>以下是一个错误的例子，大家很容易就能想明白：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    Executors.newFixedThreadPool(<span class="number">10</span>)</span><br><span class="line">            .asCoroutineDispatcher().use &#123; dispatcher -&gt;</span><br><span class="line">                List(<span class="number">1000000</span>) &#123;</span><br><span class="line">                    GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">                        i++</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.forEach &#123;</span><br><span class="line">                    it.join()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16:59:28:080 [main] 999593</span><br></pre></td></tr></table></figure><h2 id="4-suspend-main-函数如何调度？"><a href="#4-suspend-main-函数如何调度？" class="headerlink" title="4. suspend main 函数如何调度？"></a>4. suspend main 函数如何调度？</h2><p>上一篇文章我们提到了 suspend main 会启动一个协程，我们示例中的协程都是它的子协程，可是这个最外层的协程到底是怎么来的呢？</p><p>我们先给出一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它等价于下面的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runSuspend &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">        &#125;.join()</span><br><span class="line">        log(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那你说这个 <code>runSuspend</code> 又是何妨神圣？它是 Kotlin 标准库的一个方法，注意它不是 kotlinx.coroutines 当中的，它实际上属于更底层的 API 了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">runSuspend</span><span class="params">(block: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> run = RunSuspend()</span><br><span class="line">    block.startCoroutine(run)</span><br><span class="line">    run.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里面的 <code>RunSuspend</code> 则是 <code>Continuation</code> 的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RunSuspend</span> : <span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result: Result&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Unit</span>&gt;)</span></span> = synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result</span><br><span class="line">        (<span class="keyword">this</span> <span class="keyword">as</span> Object).notifyAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span> = synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">when</span> (<span class="keyword">val</span> result = <span class="keyword">this</span>.result) &#123;</span><br><span class="line">                <span class="literal">null</span> -&gt; (<span class="keyword">this</span> <span class="keyword">as</span> Object).wait()</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    result.getOrThrow() <span class="comment">// throw up failure</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的上下文是空的，因此 suspend main 启动的协程并不会有任何调度行为。</p><p>通过这个例子我们可以知道，实际上启动一个协程只需要有一个 lambda 表达式就可以了，想当年 Kotlin 1.1 刚发布的时候，我写了一系列的教程都是以标准库 API 为基础的，后来发现标准库的 API 也许真的不是给我们用的，所以看看就好。</p><blockquote><p>上述代码在标准库当中被修饰为 <code>internal</code>，因此我们无法直接使用它们。不过你可以把 <strong>RunSuspend.kt</strong> 当中的内容复制到你的工程当中，这样你就可以直接使用啦，其中的 <code>var result: Result&lt;Unit&gt;? = null</code> 可能会报错，没关系，改成 <code>private var result: Result&lt;Unit&gt;? = null</code> 就可以了。</p></blockquote><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>在这篇文章当中，我们介绍了协程上下文，介绍了拦截器，进而最终引出了我们的调度器，截止目前，我们还有异常处理、协程取消、Anko 对协程的支持等话题没有讲到，如果大家有协程相关想了解的话题，可以留言哈~</p><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;上一篇我们知道了协程启动的几种模式，也通过示例认识了 &lt;code&gt;launch&lt;/code&gt; 启动协程的使用方法，本文将延续这些内容从调度的角度来进一步为大家揭示协程的奥义。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>破解 Kotlin 协程(2) - 协程启动篇</title>
    <link href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/"/>
    <id>https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2020-02-03T08:48:04.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在你已经知道协程大概是怎么回事了，也应该想要自己尝试一把了吧。本文将为大家详细介绍协程的几种启动模式之间的不同，当然，我不打算现在就开始深入源码剖析原理，大家只需要记住这些规则就能很好的使用协程了。</p></blockquote><a id="more"></a><h2 id="1-回想一下刚学-Thread-的时候"><a href="#1-回想一下刚学-Thread-的时候" class="headerlink" title="1. 回想一下刚学 Thread 的时候"></a>1. 回想一下刚学 Thread 的时候</h2><p>我相信现在接触 Kotlin 的开发者绝大多数都有 Java 基础，我们刚开始学习 Thread 的时候，一定都是这样干的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = <span class="keyword">object</span> : Thread()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.run()</span><br><span class="line">        <span class="comment">//do what you want to do.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure><p>肯定有人忘了调用 <code>start</code>，还特别纳闷为啥我开的线程不启动呢。说实话，这个线程的 <code>start</code> 的设计其实是很奇怪的，不过我理解设计者们，毕竟当年还有 <code>stop</code> 可以用，结果他们很快发现设计 <code>stop</code> 就是一个错误，因为不安全而在 JDK 1.1 就废弃，称得上是最短命的 API 了吧。</p><blockquote><p>既然 <code>stop</code> 是错误，那么总是让初学者丢掉的 <code>start</code> 是不是也是一个错误呢？</p></blockquote><p>哈，有点儿跑题了。我们今天主要说 Kotlin。Kotlin 的设计者就很有想法，他们为线程提供了一个便捷的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myThread = thread &#123;</span><br><span class="line">    <span class="comment">//do what you want</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>thread</code> 方法有个参数 <code>start</code> 默认为 <code>true</code>，换句话说，这样创造出来的线程默认就是启动的，除非你实在不想让它马上投入工作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myThread = thread(start = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">//do what you want</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//later on ...</span></span><br><span class="line">myThread.start()</span><br></pre></td></tr></table></figure><p>这样看上去自然多了。接口设计就应该让默认值满足 80% 的需求嘛。</p><h2 id="2-再来看看协程的启动"><a href="#2-再来看看协程的启动" class="headerlink" title="2. 再来看看协程的启动"></a>2. 再来看看协程的启动</h2><p>说了这么多线程，原因嘛，毕竟大家对它是最熟悉的。协程的 API 设计其实也与之一脉相承，我们来看一段最简单的启动协程的方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="comment">//do what you want</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这段代码会怎么执行呢？我们说过，启动协程需要三样东西，分别是 <strong>上下文</strong>、<strong>启动模式</strong>、<strong>协程体</strong>，<strong>协程体</strong> 就好比 <code>Thread.run</code> 当中的代码，自不必说。</p><p>本文将为大家详细介绍 <strong>启动模式</strong>。在 Kotlin 协程当中，启动模式是一个枚举：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineStart</span> </span>&#123;</span><br><span class="line">    DEFAULT,</span><br><span class="line">    LAZY,</span><br><span class="line">    <span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line">    ATOMIC,</span><br><span class="line">    <span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line">    UNDISPATCHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>模式</th><th>功能</th></tr></thead><tbody><tr><td>DEFAULT</td><td>立即执行协程体</td></tr><tr><td>ATOMIC</td><td>立即执行协程体，但在开始运行之前无法取消</td></tr><tr><td>UNDISPATCHED</td><td>立即在当前线程执行协程体，直到第一个 suspend 调用</td></tr><tr><td>LAZY</td><td>只有在需要的情况下运行</td></tr></tbody></table><h3 id="2-1-DEFAULT"><a href="#2-1-DEFAULT" class="headerlink" title="2.1 DEFAULT"></a>2.1 DEFAULT</h3><p>四个启动模式当中我们最常用的其实是 <code>DEFAULT</code> 和 <code>LAZY</code>。</p><p><code>DEFAULT</code> 是饿汉式启动，<code>launch</code> 调用后，会立即进入待调度状态，一旦调度器 OK 就可以开始执行。我们来看个简单的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    job.join()</span><br><span class="line">    log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明： main 函数 支持 suspend 是从 Kotlin 1.3 开始的。另外，main 函数省略参数也是 Kotlin 1.3 的特性。后面的示例没有特别说明都是直接运行在 suspend main 函数当中。</p></blockquote><p>这段程序采用默认的启动模式，由于我们也没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现与其他语言的实现类似，它在后台专门会有一些线程处理异步任务，所以上述程序的运行结果可能是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">51</span>:<span class="number">08</span>:<span class="number">160</span> [main] <span class="number">1</span></span><br><span class="line"><span class="number">19</span>:<span class="number">51</span>:<span class="number">08</span>:<span class="number">603</span> [main] <span class="number">3</span></span><br><span class="line"><span class="number">19</span>:<span class="number">51</span>:<span class="number">08</span>:<span class="number">606</span> [DefaultDispatcher-worker-<span class="number">1</span>] <span class="number">2</span></span><br><span class="line"><span class="number">19</span>:<span class="number">51</span>:<span class="number">08</span>:<span class="number">624</span> [main] <span class="number">4</span></span><br></pre></td></tr></table></figure><p>也可能是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">19</span>:<span class="number">06</span>:<span class="number">367</span> [main] <span class="number">1</span></span><br><span class="line"><span class="number">20</span>:<span class="number">19</span>:<span class="number">06</span>:<span class="number">541</span> [DefaultDispatcher-worker-<span class="number">1</span>] <span class="number">2</span></span><br><span class="line"><span class="number">20</span>:<span class="number">19</span>:<span class="number">06</span>:<span class="number">550</span> [main] <span class="number">3</span></span><br><span class="line"><span class="number">20</span>:<span class="number">19</span>:<span class="number">06</span>:<span class="number">551</span> [main] <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这取决于 CPU 对于当前线程与后台线程的调度顺序，不过不要担心，很快你就会发现这个例子当中 2 和 3 的输出顺序其实并没有那么重要。</p><blockquote><p>JVM 上默认调度器的实现也许你已经猜到，没错，就是开了一个线程池，但区区几个线程足以调度成千上万个协程，而且每一个协程都有自己的调用栈，这与纯粹的开线程池去执行异步任务有本质的区别。</p><p>当然，我们说 Kotlin 是一门跨平台的语言，因此上述代码还可以运行在 JavaScript 环境中，例如 Nodejs。在 Nodejs 中，Kotlin 协程的默认调度器则并没有实现线程的切换，输出结果也会略有不同，这样似乎更符合 JavaScript 的执行逻辑。</p><p>更多调度器的话题，我们后续还会进一步讨论。</p></blockquote><h3 id="2-2-LAZY"><a href="#2-2-LAZY" class="headerlink" title="2.2 LAZY"></a>2.2 LAZY</h3><p><code>LAZY</code> 是懒汉式启动，<code>launch</code> 后并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。这其实就有点儿费解了，什么叫我们需要它执行的时候呢？就是需要它的运行结果的时候， <code>launch</code> 调用后会返回一个 <code>Job</code> 实例，对于这种情况，我们可以：</p><ul><li>调用 <code>Job.start</code>，主动触发协程的调度执行</li><li>调用 <code>Job.join</code>，隐式的触发协程的调度执行</li></ul><p>所以这个所谓的”需要“，其实是一个很有趣的措辞，后面你还会看到我们也可以通过 <code>await</code> 来表达对 <code>Deferred</code> 的需要。这个行为与 <code>Thread.join</code> 不一样，后者如果没有启动的话，调用 <code>join</code> 不会有任何作用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">job.start()</span><br><span class="line">log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>基于此，对于上面的示例，输出的结果可能是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">14:56:28:374 [main] 1</span><br><span class="line">14:56:28:493 [main] 3</span><br><span class="line">14:56:28:511 [main] 4</span><br><span class="line">14:56:28:516 [DefaultDispatcher-worker-1] 2</span><br></pre></td></tr></table></figure><p>当然如果你运气够好，也可能出现 2 比 4 在前面的情况。而对于 <code>join</code>，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">job.join()</span><br><span class="line">log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>因为要等待协程执行完毕，因此输出的结果一定是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">14:47:45:963 [main] 1</span><br><span class="line">14:47:46:054 [main] 3</span><br><span class="line">14:47:46:069 [DefaultDispatcher-worker-1] 2</span><br><span class="line">14:47:46:090 [main] 4</span><br></pre></td></tr></table></figure><h3 id="2-3-ATOMIC"><a href="#2-3-ATOMIC" class="headerlink" title="2.3 ATOMIC"></a>2.3 ATOMIC</h3><p><code>ATOMIC</code> 只有涉及 cancel 的时候才有意义，cancel 本身也是一个值得详细讨论的话题，在这里我们就简单认为 cancel 后协程会被取消掉，也就是不再执行了。那么调用 cancel 的时机不同，结果也是有差异的，例如协程调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等。</p><p>为了搞清楚它与 <code>DEFAULT</code> 的区别，我们来看一段例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br><span class="line">log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>我们创建了协程后立即 cancel，但由于是 <code>ATOMIC</code> 模式，因此协程一定会被调度，因此 1、2、3 一定都会输出，只是 2 和 3 的顺序就难说了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20:42:42:783 [main] 1</span><br><span class="line">20:42:42:879 [main] 3</span><br><span class="line">20:42:42:879 [DefaultDispatcher-worker-1] 2</span><br></pre></td></tr></table></figure><p>对应的，如果是 <code>DEFAULT</code> 模式，在第一次调度该协程时如果 cancel 就已经调用，那么协程就会直接被 cancel 而不会有任何调用，当然也有可能协程开始时尚未被 cancel，那么它就可以正常启动了。所以前面的例子如果改用 <code>DEFAULT</code> 模式，那么 2 有可能会输出，也可能不会。</p><p>需要注意的是，cancel 调用一定会将该 job 的状态置为 cancelling，只不过<code>ATOMIC</code> 模式的协程在启动时无视了这一状态。为了证明这一点，我们可以让例子稍微复杂一些：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br><span class="line">log(<span class="number">4</span>)</span><br><span class="line">job.join()</span><br></pre></td></tr></table></figure><p>我们在 2 和 3 之间加了一个 <code>delay</code>，<code>delay</code> 会使得协程体的执行被挂起，1000ms 之后再次调度后面的部分，因此 3 会在 2 执行之后 1000ms 时输出。对于 <code>ATOMIC</code> 模式，我们已经讨论过它一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 <code>delay</code> 是一个 suspend 函数，这时我们的协程迎来了自己的第一个挂起点，恰好 <code>delay</code> 是支持 cancel 的，因此后面的 3 将不会被打印。</p><blockquote><p>我们使用线程的时候，想要让线程里面的任务停止执行也会面临类似的问题，但遗憾的是线程中看上去与 cancel 相近的 stop 接口已经被废弃，因为存在一些安全的问题。不过随着我们不断地深入探讨，你就会发现协程的 cancel 某种意义上更像线程的 interrupt。</p></blockquote><h3 id="2-4-UNDISPATCHED"><a href="#2-4-UNDISPATCHED" class="headerlink" title="2.4 UNDISPATCHED"></a>2.4 UNDISPATCHED</h3><p>有了前面的基础，<code>UNDISPATCHED</code> 就很容易理解了。协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这听起来有点儿像前面的 <code>ATOMIC</code>，不同之处在于 <code>UNDISPATCHED</code> 不经过任何调度器即开始执行协程体。当然遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文当中的调度器了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">4</span>)</span><br><span class="line">job.join()</span><br><span class="line">log(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>我们还是以这样一个例子来认识下 <code>UNDISPATCHED</code> 模式，按照我们前面的讨论，协程启动后会立即在当前线程执行，因此 1、2 会连续在同一线程中执行，<code>delay</code> 是挂起点，因此 3 会等 100ms 后再次调度，这时候 4 执行，<code>join</code> 要求等待协程执行完，因此等 3 输出后再执行 5。以下是运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">22:00:31:693 [main] 1</span><br><span class="line">22:00:31:782 [main @coroutine#1] 2</span><br><span class="line">22:00:31:800 [main] 4</span><br><span class="line">22:00:31:914 [DefaultDispatcher-worker-1 @coroutine#1] 3</span><br><span class="line">22:00:31:916 [DefaultDispatcher-worker-1 @coroutine#1] 5</span><br></pre></td></tr></table></figure><blockquote><p>方括号当中是线程名，我们发现协程执行时会修改线程名来让自己显得颇有存在感。运行结果看上去还有一个细节可能会让人困惑，<code>join</code> 之后的 5 的线程与 3 一样，这是为什么？我们在前面提到我们的示例都运行在 suspend main 函数当中，所以 suspend main 函数会帮我们直接启动一个协程，而我们示例的协程都是它的子协程，所以这里 5 的调度取决于这个最外层的协程的调度规则了。关于协程的调度，我们后面再聊。</p></blockquote><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>本文通过一些例子来给大家逐步揭开协程的面纱。相信大家读完对于协程的执行机制有了一个大概的认识，同时对于协程的调度这个话题想必也非常好奇或者感到困惑，这是正常的——因为我们还没有讲嘛，放心，调度器的内容已经安排了 : )。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><code>log</code> 函数的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dateFormat = SimpleDateFormat(<span class="string">"HH:mm:ss:SSS"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> now = &#123;</span><br><span class="line">    dateFormat.format(Date(System.currentTimeMillis()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">Any</span>?)</span></span> = println(<span class="string">"<span class="subst">$&#123;now()&#125;</span> [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br></pre></td></tr></table></figure><hr><p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p><p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html" target="_blank" rel="noopener">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png" alt=""></p><p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:kf@imooc.com">kf@imooc.com</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p><hr><p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p><p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR" target="_blank" rel="noopener">《破解Android高级面试》</a>即可进入课程啦！</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;现在你已经知道协程大概是怎么回事了，也应该想要自己尝试一把了吧。本文将为大家详细介绍协程的几种启动模式之间的不同，当然，我不打算现在就开始深入源码剖析原理，大家只需要记住这些规则就能很好的使用协程了。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="Coroutine" scheme="https://www.bennyhuo.com/tags/coroutine/"/>
    
  </entry>
  
</feed>
